{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/engine/types.ts", "../library/src/utils/text.ts", "../library/src/plugins/official/core/attributes/computed.ts", "../library/src/plugins/official/core/attributes/signals.ts", "../library/src/plugins/official/core/attributes/star.ts", "../library/src/utils/dom.ts", "../library/src/engine/errors.ts", "../library/src/vendored/preact-core.ts", "../library/src/engine/signals.ts", "../library/src/engine/engine.ts", "../library/src/engine/index.ts", "../library/src/plugins/official/backend/shared.ts", "../library/src/vendored/fetch-event-source.ts", "../library/src/plugins/official/backend/actions/sse.ts", "../library/src/plugins/official/backend/actions/delete.ts", "../library/src/plugins/official/backend/actions/get.ts", "../library/src/plugins/official/backend/actions/patch.ts", "../library/src/plugins/official/backend/actions/post.ts", "../library/src/plugins/official/backend/actions/put.ts", "../library/src/plugins/official/backend/attributes/indicator.ts", "../library/src/plugins/official/backend/watchers/executeScript.ts", "../library/src/utils/view-transtions.ts", "../library/src/vendored/idiomorph.esm.js", "../library/src/plugins/official/backend/watchers/mergeFragments.ts", "../library/src/plugins/official/backend/watchers/mergeSignals.ts", "../library/src/plugins/official/backend/watchers/removeFragments.ts", "../library/src/plugins/official/backend/watchers/removeSignals.ts", "../library/src/plugins/official/browser/actions/clipboard.ts", "../library/src/plugins/official/browser/attributes/customValidity.ts", "../library/src/utils/tags.ts", "../library/src/utils/timing.ts", "../library/src/plugins/official/browser/attributes/onIntersect.ts", "../library/src/plugins/official/browser/attributes/onInterval.ts", "../library/src/plugins/official/browser/attributes/onLoad.ts", "../library/src/plugins/official/browser/attributes/onRaf.ts", "../library/src/utils/paths.ts", "../library/src/plugins/official/browser/attributes/onSignalChange.ts", "../library/src/plugins/official/browser/attributes/persist.ts", "../library/src/plugins/official/browser/attributes/replaceUrl.ts", "../library/src/plugins/official/browser/attributes/scrollIntoView.ts", "../library/src/plugins/official/browser/attributes/viewTransition.ts", "../library/src/plugins/official/dom/attributes/attr.ts", "../library/src/plugins/official/dom/attributes/bind.ts", "../library/src/plugins/official/dom/attributes/class.ts", "../library/src/plugins/official/dom/attributes/on.ts", "../library/src/plugins/official/dom/attributes/ref.ts", "../library/src/plugins/official/dom/attributes/show.ts", "../library/src/plugins/official/dom/attributes/text.ts", "../library/src/plugins/official/logic/actions/fit.ts", "../library/src/plugins/official/logic/actions/setAll.ts", "../library/src/plugins/official/logic/actions/toggleAll.ts", "../library/src/bundles/datastar.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n// The default attributes for <script/> element use when executing scripts. It is a set of key-value pairs delimited by a newline \\\\n character.\nexport const DefaultExecuteScriptAttributes = \"type module\";\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should fragments be merged using the ViewTransition API?\nexport const DefaultFragmentsUseViewTransitions = false;\n\n// Should a given set of signals merge if they are missing?\nexport const DefaultMergeSignalsOnlyIfMissing = false;\n\n// Should script element remove itself after execution?\nexport const DefaultExecuteScriptAutoRemove = true;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a fragment is merged into the DOM.\nexport const FragmentMergeModes = {\n    // Morphs the fragment into the existing element using idiomorph.\n    Morph: \"morph\",\n    // Replaces the inner HTML of the existing element.\n    Inner: \"inner\",\n    // Replaces the outer HTML of the existing element.\n    Outer: \"outer\",\n    // Prepends the fragment to the existing element.\n    Prepend: \"prepend\",\n    // Appends the fragment to the existing element.\n    Append: \"append\",\n    // Inserts the fragment before the existing element.\n    Before: \"before\",\n    // Inserts the fragment after the existing element.\n    After: \"after\",\n    // Upserts the attributes of the existing element.\n    UpsertAttributes: \"upsertAttributes\",\n} as const;\n\n// Default value for FragmentMergeMode\nexport const DefaultFragmentMergeMode = FragmentMergeModes.Morph;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\nexport const EventTypes = {\n    // An event for merging HTML fragments into the DOM.\n    MergeFragments: \"datastar-merge-fragments\",\n    // An event for merging signals.\n    MergeSignals: \"datastar-merge-signals\",\n    // An event for removing HTML fragments from the DOM.\n    RemoveFragments: \"datastar-remove-fragments\",\n    // An event for removing signals.\n    RemoveSignals: \"datastar-remove-signals\",\n    // An event for executing <script/> elements in the browser.\n    ExecuteScript: \"datastar-execute-script\",\n} as const;\n// #endregion\n\n// #endregion", "import type { EffectFn, Signal } from '../vendored/preact-core'\nimport { DATASTAR } from './consts'\nimport type { SignalsRoot } from './signals'\n\nexport type OnRemovalFn = () => void\n\nexport enum PluginType {\n  Attribute = 1,\n  Watcher = 2,\n  Action = 3,\n}\n\nexport interface DatastarPlugin {\n  type: PluginType // The type of plugin\n  name: string // The name of the plugin\n}\n\nexport enum Requirement {\n  Allowed = 0,\n  Must = 1,\n  Denied = 2,\n  Exclusive = 3,\n}\n\nexport interface DatastarSignalEvent {\n  added: Array<string>\n  removed: Array<string>\n  updated: Array<string>\n}\nexport const DATASTAR_SIGNAL_EVENT = `${DATASTAR}-signals`\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_EVENT]: CustomEvent<DatastarSignalEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accesible via a `data-${name}` attribute on an element\nexport interface AttributePlugin extends DatastarPlugin {\n  type: PluginType.Attribute\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the DastaStar instance\nexport interface WatcherPlugin extends DatastarPlugin {\n  type: PluginType.Watcher\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport interface ActionPlugin extends DatastarPlugin {\n  type: PluginType.Action\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type InitContext = {\n  plugin: DatastarPlugin\n  signals: SignalsRoot\n  effect: (fn: EffectFn) => OnRemovalFn\n  actions: Readonly<ActionPlugins>\n  removals: Map<string, Map<number, OnRemovalFn>>\n  applyToElement: (el: HTMLorSVGElement) => void\n}\n\nexport type HTMLorSVGElement = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\n\nexport type RuntimeContext = InitContext & {\n  plugin: DatastarPlugin // The name of the plugin\n  el: HTMLorSVGElement // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the tags and their arguments\n  genRX: () => <T>(...args: any[]) => T // a reactive expression\n  fnContent?: string // the content of the function\n}\n\nexport type NestedValues = { [key: string]: NestedValues | any }\nexport type NestedSignal = {\n  [key: string]: NestedSignal | Signal<any>\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n\nexport type EventCallbackHandler = (...args: any[]) => void\n", "import type { Modifiers } from '../engine/types'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str.replace(\n    /[A-Z]+(?![a-z])|[A-Z]/g,\n    ($, ofs) => (ofs ? '-' : '') + $.toLowerCase(),\n  )\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/^./, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) =>\n  new Function(`return Object.assign({}, ${raw})`)()\n\nexport const trimDollarSignPrefix = (str: string) =>\n  str.startsWith('$') ? str.slice(1) : str\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing } from '../../../../utils/text'\n\nconst name = 'computed'\nexport const Computed: AttributePlugin = {\n  type: PluginType.Attribute,\n  name,\n  keyReq: Requirement.Must,\n  valReq: Requirement.Must,\n  onLoad: ({ key, mods, signals, genRX }) => {\n    key = modifyCasing(key, mods)\n    const rx = genRX()\n    signals.setComputed(key, rx)\n  },\n}\n", "import {\n  type AttributePlugin,\n  type NestedValues,\n  PluginType,\n} from '../../../../engine/types'\nimport { jsStrToObject, modifyCasing } from '../../../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'signals',\n  onLoad: (ctx) => {\n    const { key, mods, signals, value, genRX } = ctx\n    const ifMissing = mods.has('ifmissing')\n\n    if (key !== '') {\n      const k = modifyCasing(key, mods)\n      const v = value === '' ? value : genRX()()\n      if (ifMissing) {\n        signals.upsertIfMissing(k, v)\n      } else {\n        signals.setValue(k, v)\n      }\n    } else {\n      const obj = jsStrToObject(ctx.value)\n      ctx.value = JSON.stringify(obj)\n      const rx = genRX()\n      const nv = rx<NestedValues>()\n      signals.merge(nv, ifMissing)\n    }\n  },\n}\n", "import {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const Star: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'star',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Denied,\n  onLoad: () => {\n    alert('YOU ARE PROBABLY OVERCOMPLICATING IT')\n  },\n}\n", "import { DATASTAR } from '../engine/consts'\nimport type { HTMLorSVGElement } from '../engine/types'\n\nexport class Hash {\n  #value = 0\n  #prefix: string\n\n  constructor(prefix = DATASTAR) {\n    this.#prefix = prefix\n  }\n\n  with(x: number | string | boolean): Hash {\n    if (typeof x === 'string') {\n      for (const c of x.split('')) {\n        this.with(c.charCodeAt(0))\n      }\n    } else if (typeof x === 'boolean') {\n      this.with(1 << (x ? 7 : 3))\n    } else {\n      // use djb2 favored by bernstein http://www.cse.yorku.ca/~oz/hash.html\n      this.#value = (this.#value * 33) ^ x\n    }\n    return this\n  }\n\n  get value() {\n    return this.#value\n  }\n\n  get string() {\n    return this.#prefix + Math.abs(this.#value).toString(36)\n  }\n}\n\nexport function elUniqId(el: Element) {\n  if (el.id) return el.id\n  const hash = new Hash()\n\n  let currentEl = el\n  while (currentEl) {\n    hash.with(currentEl.tagName || '')\n    if (currentEl.id) {\n      hash.with(currentEl.id)\n      break\n    }\n    const p = currentEl?.parentNode\n    if (p) hash.with([...p.children].indexOf(currentEl))\n\n    currentEl = p as Element\n  }\n  return hash.string\n}\n\nexport function attrHash(key: number | string, val: number | string) {\n  return new Hash().with(key).with(val).value\n}\n\nexport function walkDOM(\n  element: Element | null,\n  callback: (el: HTMLorSVGElement) => void,\n) {\n  if (\n    !element ||\n    !(element instanceof HTMLElement || element instanceof SVGElement)\n  ) {\n    return null\n  }\n  const dataset = element.dataset\n  if ('starIgnore' in dataset) {\n    return null\n  }\n  if (!('starIgnore__self' in dataset)) {\n    callback(element)\n  }\n  let el = element.firstElementChild\n  while (el) {\n    walkDOM(el, callback)\n    el = el.nextElementSibling\n  }\n}\n", "import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport { type InitContext, PluginType, type RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(reason: string, ctx: InitContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(reason: string, ctx: RuntimeContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: PluginType[ctx.plugin.type],\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      validSignals: ctx.signals.paths(),\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { internalErr } from '../engine/errors'\nimport type { OnRemovalFn } from '../engine/types'\n\nconst from = 'preact-signals'\n\n// An named symbol/brand for detecting Signal instances even when they weren't\n// created using the same signals library version.\nconst BRAND_SYMBOL = Symbol.for('preact-signals')\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0\nconst NOTIFIED = 1 << 1\nconst OUTDATED = 1 << 2\nconst DISPOSED = 1 << 3\nconst HAS_ERROR = 1 << 4\nconst TRACKING = 1 << 5\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n  // A source whose value the target depends on.\n  _source: Signal\n  _prevSource?: Node\n  _nextSource?: Node\n\n  // A target that depends on the source and should be notified when the source changes.\n  _target: Computed | Effect\n  _prevTarget?: Node\n  _nextTarget?: Node\n\n  // The version number of the source that target has last seen. We use version numbers\n  // instead of storing the source value, because source values can take arbitrary amount\n  // of memory, and computeds could hang on to them forever because they're lazily evaluated.\n  // Use the special value -1 to mark potentially unused but recyclable nodes.\n  _version: number\n\n  // Used to remember & roll back the source's previous `._node` value when entering &\n  // exiting a new evaluation context.\n  _rollbackNode?: Node\n}\n\nfunction startBatch() {\n  batchDepth++\n}\n\nfunction endBatch() {\n  if (batchDepth > 1) {\n    batchDepth--\n    return\n  }\n\n  let error: unknown\n  let hasError = false\n\n  while (batchedEffect !== undefined) {\n    let effect: Effect | undefined = batchedEffect\n    batchedEffect = undefined\n\n    batchIteration++\n\n    while (effect !== undefined) {\n      const next: Effect | undefined = effect._nextBatchedEffect\n      effect._nextBatchedEffect = undefined\n      effect._flags &= ~NOTIFIED\n\n      if (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n        try {\n          effect._callback()\n        } catch (err) {\n          if (!hasError) {\n            error = err\n            hasError = true\n          }\n        }\n      }\n      effect = next\n    }\n  }\n  batchIteration = 0\n  batchDepth--\n\n  if (hasError) throw error\n}\n\n/**\n * Combine multiple value updates into one \"commit\" at the end of the provided callback.\n *\n * Batches can be nested and changes are only flushed once the outermost batch callback\n * completes.\n *\n * Accessing a signal that has been modified within a batch will reflect its updated\n * value.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction batch<T>(fn: () => T): T {\n  if (batchDepth > 0) {\n    return fn()\n  }\n  /*@__INLINE__**/ startBatch()\n  try {\n    return fn()\n  } finally {\n    endBatch()\n  }\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined\n\n/**\n * Run a callback function that can access signal values without\n * subscribing to the signal updates.\n *\n * @param fn The callback function.\n * @returns The value returned by the callback.\n */\nfunction untracked<T>(fn: () => T): T {\n  const prevContext = evalContext\n  evalContext = undefined\n  try {\n    return fn()\n  } finally {\n    evalContext = prevContext\n  }\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined\nlet batchDepth = 0\nlet batchIteration = 0\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0\n\nfunction addDependency(signal: Signal): Node | undefined {\n  if (evalContext === undefined) {\n    return undefined\n  }\n\n  let node = signal._node\n  if (node === undefined || node._target !== evalContext) {\n    /**\n     * `signal` is a new dependency. Create a new dependency node, and set it\n     * as the tail of the current context's dependency list. e.g:\n     *\n     * { A <-> B       }\n     *         \u2191     \u2191\n     *        tail  node (new)\n     *               \u2193\n     * { A <-> B <-> C }\n     *               \u2191\n     *              tail (evalContext._sources)\n     */\n    node = {\n      _version: 0,\n      _source: signal,\n      _prevSource: evalContext._sources,\n      _nextSource: undefined,\n      _target: evalContext,\n      _prevTarget: undefined,\n      _nextTarget: undefined,\n      _rollbackNode: node,\n    }\n\n    if (evalContext._sources !== undefined) {\n      evalContext._sources._nextSource = node\n    }\n    evalContext._sources = node\n    signal._node = node\n\n    // Subscribe to change notifications from this dependency if we're in an effect\n    // OR evaluating a computed signal that in turn has subscribers.\n    if (evalContext._flags & TRACKING) {\n      signal._subscribe(node)\n    }\n    return node\n  }\n  if (node._version === -1) {\n    // `signal` is an existing dependency from a previous evaluation. Reuse it.\n    node._version = 0\n\n    /**\n     * If `node` is not already the current tail of the dependency list (i.e.\n     * there is a next node in the list), then make the `node` the new tail. e.g:\n     *\n     * { A <-> B <-> C <-> D }\n     *         \u2191           \u2191\n     *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n     *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n     *               \u2193     \u2193\n     * { A <-> C <-> D <-> B }\n     *                     \u2191\n     *                    tail (evalContext._sources)\n     */\n    if (node._nextSource !== undefined) {\n      node._nextSource._prevSource = node._prevSource\n\n      if (node._prevSource !== undefined) {\n        node._prevSource._nextSource = node._nextSource\n      }\n\n      node._prevSource = evalContext._sources\n      node._nextSource = undefined\n\n      evalContext._sources!._nextSource = node\n      evalContext._sources = node\n    }\n\n    // We can assume that the currently evaluated effect / computed signal is already\n    // subscribed to change notifications from `signal` if needed.\n    return node\n  }\n  return undefined\n}\n\n/**\n * The base class for plain and computed signals.\n */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A function with the same name is defined later, so we need to ignore TypeScript's\n// warning about a redeclared variable.\n//\n// The class is declared here, but later implemented with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\ndeclare class Signal<T = any> {\n  /** @internal */\n  _onChange: (change: { old: T; revised: T }) => void\n\n  /** @internal */\n  _value: unknown\n\n  /**\n   * @internal\n   * Version numbers should always be >= 0, because the special value -1 is used\n   * by Nodes to signify potentially unused but recyclable nodes.\n   */\n  _version: number\n\n  /** @internal */\n  _node?: Node\n\n  /** @internal */\n  _targets?: Node\n\n  constructor(value?: T)\n\n  /** @internal */\n  _refresh(): boolean\n\n  /** @internal */\n  _subscribe(node: Node): void\n\n  /** @internal */\n  _unsubscribe(node: Node): void\n\n  subscribe(fn: (value: T) => void): () => void\n\n  valueOf(): T\n\n  toString(): string\n\n  toJSON(): T\n\n  peek(): T\n\n  brand: typeof BRAND_SYMBOL\n\n  get value(): T\n  set value(value: T)\n}\n\n/** @internal */\n// @ts-ignore: \"Cannot redeclare exported variable 'Signal'.\"\n//\n// A class with the same name has already been declared, so we need to ignore\n// TypeScript's warning about a redeclared variable.\n//\n// The previously declared class is implemented here with ES5-style protoTYPEOF_\n// This enables better control of the transpiled output size.\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nfunction Signal(this: Signal, value?: unknown) {\n  this._value = value\n  this._version = 0\n  this._node = undefined\n  this._targets = undefined\n}\n\nSignal.prototype.brand = BRAND_SYMBOL\n\nSignal.prototype._refresh = () => true\n\nSignal.prototype._subscribe = function (node) {\n  if (this._targets !== node && node._prevTarget === undefined) {\n    node._nextTarget = this._targets\n    if (this._targets !== undefined) {\n      this._targets._prevTarget = node\n    }\n    this._targets = node\n  }\n}\n\nSignal.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the signal has any subscribers to begin with.\n  if (this._targets !== undefined) {\n    const prev = node._prevTarget\n    const next = node._nextTarget\n    if (prev !== undefined) {\n      prev._nextTarget = next\n      node._prevTarget = undefined\n    }\n    if (next !== undefined) {\n      next._prevTarget = prev\n      node._nextTarget = undefined\n    }\n    if (node === this._targets) {\n      this._targets = next\n    }\n  }\n}\n\nSignal.prototype.subscribe = function (fn) {\n  return effect(() => {\n    const value = this.value\n\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      fn(value)\n    } finally {\n      evalContext = prevContext\n    }\n  })\n}\n\nSignal.prototype.valueOf = function () {\n  return this.value\n}\n\nSignal.prototype.toString = function () {\n  return `${this.value}`\n}\n\nSignal.prototype.toJSON = function () {\n  return this.value\n}\n\nSignal.prototype.peek = function () {\n  const prevContext = evalContext\n  evalContext = undefined\n  try {\n    return this.value\n  } finally {\n    evalContext = prevContext\n  }\n}\n\nObject.defineProperty(Signal.prototype, 'value', {\n  get(this: Signal) {\n    const node = addDependency(this)\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    return this._value\n  },\n  set(this: Signal, value) {\n    if (value !== this._value) {\n      if (batchIteration > 100) {\n        throw internalErr(from, 'SignalCycleDetected')\n      }\n      const old = this._value\n      const revised = value\n\n      this._value = value\n      this._version++\n      globalVersion++\n\n      /**@__INLINE__*/ startBatch()\n      try {\n        for (\n          let node = this._targets;\n          node !== undefined;\n          node = node._nextTarget\n        ) {\n          node._target._notify()\n        }\n      } finally {\n        endBatch()\n      }\n\n      this?._onChange({ old, revised })\n    }\n  },\n})\n\n/**\n * Create a new plain signal.\n *\n * @param value The initial value for the signal.\n * @returns A new signal.\n */\nexport function signal<T>(value: T): Signal<T>\nexport function signal<T = undefined>(): Signal<T | undefined>\nexport function signal<T>(value?: T): Signal<T> {\n  return new Signal(value)\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n  // Check the dependencies for changed values. The dependency list is already\n  // in order of use. Therefore if multiple dependencies have changed values, only\n  // the first used dependency is re-evaluated at this point.\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    // If there's a new version of the dependency before or after refreshing,\n    // or the dependency has something blocking it from refreshing at all (e.g. a\n    // dependency cycle), then we need to recompute.\n    if (\n      node._source._version !== node._version ||\n      !node._source._refresh() ||\n      node._source._version !== node._version\n    ) {\n      return true\n    }\n  }\n  // If none of the dependencies have changed values since last recompute then\n  // there's no need to recompute.\n  return false\n}\n\nfunction prepareSources(target: Computed | Effect) {\n  /**\n   * 1. Mark all current sources as re-usable nodes (version: -1)\n   * 2. Set a rollback node if the current node is being used in a different context\n   * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n   *\n   *    { undefined <- A <-> B <-> C -> undefined }\n   *                   \u2191           \u2191\n   *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   * target._sources = A; (node is head)  \u2502\n   *                   \u2193                  \u2502\n   * target._sources = C; (node is tail) \u2500\u2518\n   */\n  for (\n    let node = target._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    const rollbackNode = node._source._node\n    if (rollbackNode !== undefined) {\n      node._rollbackNode = rollbackNode\n    }\n    node._source._node = node\n    node._version = -1\n\n    if (node._nextSource === undefined) {\n      target._sources = node\n      break\n    }\n  }\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n  let node = target._sources\n  let head: Node | undefined = undefined\n\n  /**\n   * At this point 'target._sources' points to the tail of the doubly-linked list.\n   * It contains all existing sources + new sources in order of use.\n   * Iterate backwards until we find the head node while dropping old dependencies.\n   */\n  while (node !== undefined) {\n    const prev = node._prevSource\n\n    /**\n     * The node was not re-used, unsubscribe from its change notifications and remove itself\n     * from the doubly-linked list. e.g:\n     *\n     * { A <-> B <-> C }\n     *         \u2193\n     *    { A <-> C }\n     */\n    if (node._version === -1) {\n      node._source._unsubscribe(node)\n\n      if (prev !== undefined) {\n        prev._nextSource = node._nextSource\n      }\n      if (node._nextSource !== undefined) {\n        node._nextSource._prevSource = prev\n      }\n    } else {\n      /**\n       * The new head is the last node seen which wasn't removed/unsubscribed\n       * from the doubly-linked list. e.g:\n       *\n       * { A <-> B <-> C }\n       *   \u2191     \u2191     \u2191\n       *   \u2502     \u2502     \u2514 head = node\n       *   \u2502     \u2514 head = node\n       *   \u2514 head = node\n       */\n      head = node\n    }\n\n    node._source._node = node._rollbackNode\n    if (node._rollbackNode !== undefined) {\n      node._rollbackNode = undefined\n    }\n\n    node = prev\n  }\n\n  target._sources = head\n}\n\nexport declare class Computed<T = any> extends Signal<T> {\n  _fn: () => T\n  _sources?: Node\n  _globalVersion: number\n  _flags: number\n\n  constructor(fn: () => T)\n\n  _notify(): void\n  get value(): T\n}\n\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nexport function Computed(this: Computed, fn: () => unknown) {\n  Signal.call(this, undefined)\n\n  this._fn = fn\n  this._sources = undefined\n  this._globalVersion = globalVersion - 1\n  this._flags = OUTDATED\n}\n\nComputed.prototype = new Signal() as Computed\n\nComputed.prototype._refresh = function () {\n  this._flags &= ~NOTIFIED\n\n  if (this._flags & RUNNING) {\n    return false\n  }\n\n  // If this computed signal has subscribed to updates from its dependencies\n  // (TRACKING flag set) and none of them have notified about changes (OUTDATED\n  // flag not set), then the computed value can't have changed.\n  if ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n    return true\n  }\n  this._flags &= ~OUTDATED\n\n  if (this._globalVersion === globalVersion) {\n    return true\n  }\n  this._globalVersion = globalVersion\n\n  // Mark this computed signal running before checking the dependencies for value\n  // changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n  this._flags |= RUNNING\n  if (this._version > 0 && !needsToRecompute(this)) {\n    this._flags &= ~RUNNING\n    return true\n  }\n\n  const prevContext = evalContext\n  try {\n    prepareSources(this)\n    evalContext = this\n    const value = this._fn()\n    if (\n      this._flags & HAS_ERROR ||\n      this._value !== value ||\n      this._version === 0\n    ) {\n      this._value = value\n      this._flags &= ~HAS_ERROR\n      this._version++\n    }\n  } catch (err) {\n    this._value = err\n    this._flags |= HAS_ERROR\n    this._version++\n  }\n  evalContext = prevContext\n  cleanupSources(this)\n  this._flags &= ~RUNNING\n  return true\n}\n\nComputed.prototype._subscribe = function (node) {\n  if (this._targets === undefined) {\n    this._flags |= OUTDATED | TRACKING\n\n    // A computed signal subscribes lazily to its dependencies when it\n    // gets its first subscriber.\n    for (\n      let node = this._sources;\n      node !== undefined;\n      node = node._nextSource\n    ) {\n      node._source._subscribe(node)\n    }\n  }\n  Signal.prototype._subscribe.call(this, node)\n}\n\nComputed.prototype._unsubscribe = function (node) {\n  // Only run the unsubscribe step if the computed signal has any subscribers.\n  if (this._targets !== undefined) {\n    Signal.prototype._unsubscribe.call(this, node)\n\n    // Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n    // This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n    if (this._targets === undefined) {\n      this._flags &= ~TRACKING\n\n      for (\n        let node = this._sources;\n        node !== undefined;\n        node = node._nextSource\n      ) {\n        node._source._unsubscribe(node)\n      }\n    }\n  }\n}\n\nComputed.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= OUTDATED | NOTIFIED\n\n    for (\n      let node = this._targets;\n      node !== undefined;\n      node = node._nextTarget\n    ) {\n      node._target._notify()\n    }\n  }\n}\n\nObject.defineProperty(Computed.prototype, 'value', {\n  get(this: Computed) {\n    if (this._flags & RUNNING) {\n      // Cycle detected\n      throw internalErr(from, 'SignalCycleDetected')\n    }\n    const node = addDependency(this)\n    this._refresh()\n    if (node !== undefined) {\n      node._version = this._version\n    }\n    if (this._flags & HAS_ERROR) {\n      throw internalErr(from, 'GetComputedError', { value: this._value })\n    }\n    return this._value\n  },\n})\n\n/**\n * An interface for read-only signals.\n */\ninterface ReadonlySignal<T = any> {\n  readonly value: T\n  peek(): T\n\n  subscribe(fn: (value: T) => void): () => void\n  valueOf(): T\n  toString(): string\n  toJSON(): T\n  brand: typeof BRAND_SYMBOL\n}\n\n/**\n * Create a new signal that is computed based on the values of other signals.\n *\n * The returned computed signal is read-only, and its value is automatically\n * updated when any signals accessed from within the callback function change.\n *\n * @param fn The effect callback.\n * @returns A new read-only signal.\n */\nfunction computed<T>(fn: () => T): ReadonlySignal<T> {\n  return new Computed(fn)\n}\n\nfunction cleanupEffect(effect: Effect) {\n  const cleanup = effect._cleanup\n  effect._cleanup = undefined\n\n  if (typeof cleanup === 'function') {\n    /*@__INLINE__**/ startBatch()\n\n    // Run cleanup functions always outside of any context.\n    const prevContext = evalContext\n    evalContext = undefined\n    try {\n      cleanup!()\n    } catch (error) {\n      effect._flags &= ~RUNNING\n      effect._flags |= DISPOSED\n      disposeEffect(effect)\n      throw internalErr(from, 'CleanupEffectError', { error })\n    } finally {\n      evalContext = prevContext\n      endBatch()\n    }\n  }\n}\n\nfunction disposeEffect(effect: Effect) {\n  for (\n    let node = effect._sources;\n    node !== undefined;\n    node = node._nextSource\n  ) {\n    node._source._unsubscribe(node)\n  }\n  effect._fn = undefined\n  effect._sources = undefined\n\n  cleanupEffect(effect)\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n  if (evalContext !== this) {\n    throw internalErr(from, 'EndEffectError')\n  }\n  cleanupSources(this)\n  evalContext = prevContext\n\n  this._flags &= ~RUNNING\n  if (this._flags & DISPOSED) {\n    disposeEffect(this)\n  }\n  endBatch()\n}\n\nexport type EffectFn = () => OnRemovalFn | void | Promise<OnRemovalFn | void>\n\ndeclare class Effect {\n  _fn?: EffectFn\n  _cleanup?: () => void\n  _sources?: Node\n  _nextBatchedEffect?: Effect\n  _flags: number\n\n  constructor(fn: EffectFn)\n\n  _callback(): void\n  _start(): () => void\n  _notify(): void\n  _dispose(): void\n}\n\n// biome-ignore lint/suspicious/noRedeclare: <explanation>\nfunction Effect(this: Effect, fn: EffectFn) {\n  this._fn = fn\n  this._cleanup = undefined\n  this._sources = undefined\n  this._nextBatchedEffect = undefined\n  this._flags = TRACKING\n}\n\nEffect.prototype._callback = function () {\n  const finish = this._start()\n  try {\n    if (this._flags & DISPOSED) return\n    if (this._fn === undefined) return\n\n    const cleanup = this._fn()\n    if (typeof cleanup === 'function') {\n      this._cleanup = cleanup!\n    }\n  } finally {\n    finish()\n  }\n}\n\nEffect.prototype._start = function () {\n  if (this._flags & RUNNING) {\n    throw internalErr(from, 'SignalCycleDetected')\n  }\n  this._flags |= RUNNING\n  this._flags &= ~DISPOSED\n  cleanupEffect(this)\n  prepareSources(this)\n\n  /*@__INLINE__**/ startBatch()\n  const prevContext = evalContext\n  evalContext = this\n  return endEffect.bind(this, prevContext)\n}\n\nEffect.prototype._notify = function () {\n  if (!(this._flags & NOTIFIED)) {\n    this._flags |= NOTIFIED\n    this._nextBatchedEffect = batchedEffect\n    batchedEffect = this\n  }\n}\n\nEffect.prototype._dispose = function () {\n  this._flags |= DISPOSED\n\n  if (!(this._flags & RUNNING)) {\n    disposeEffect(this)\n  }\n}\n\n/**\n * Create an effect to run arbitrary code in response to signal changes.\n *\n * An effect tracks which signals are accessed within the given callback\n * function `fn`, and re-runs the callback when those signals change.\n *\n * The callback may return a cleanup function. The cleanup function gets\n * run once, either when the callback is next called or when the effect\n * gets disposed, whichever happens first.\n *\n * @param fn The effect callback.\n * @returns A function for disposing the effect.\n */\nfunction effect(fn: EffectFn): () => void {\n  const effect = new Effect(fn)\n  try {\n    effect._callback()\n  } catch (error) {\n    effect._dispose()\n    // Throw the error, since it is already a Datastar error.\n    throw error\n  }\n  // Return a bound function instead of a wrapper like `() => effect._dispose()`,\n  // because bound functions seem to be just as fast and take up a lot less memory.\n  return effect._dispose.bind(effect)\n}\n\nexport { batch, computed, effect, Signal, untracked }\nexport type { ReadonlySignal }\n", "import { type Computed, Signal, computed } from '../vendored/preact-core'\nimport { internalErr } from './errors'\nimport {\n  DATASTAR_SIGNAL_EVENT,\n  type DatastarSignalEvent,\n  type NestedSignal,\n  type NestedValues,\n} from './types'\n\nconst from = 'namespacedSignals'\n\nconst dispatchSignalEvent = (evt: Partial<DatastarSignalEvent>) => {\n  document.dispatchEvent(\n    new CustomEvent<DatastarSignalEvent>(DATASTAR_SIGNAL_EVENT, {\n      detail: Object.assign({ added: [], removed: [], updated: [] }, evt),\n    }),\n  )\n}\n// If onlyPublic is true, only signals not starting with an underscore are included\nfunction nestedValues(\n  signal: NestedSignal,\n  onlyPublic = false,\n): Record<string, any> {\n  const kv: Record<string, any> = {}\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      if (onlyPublic && key.startsWith('_')) {\n        continue\n      }\n      const value = signal[key]\n      if (value instanceof Signal) {\n        kv[key] = value.value\n      } else {\n        kv[key] = nestedValues(value)\n      }\n    }\n  }\n  return kv\n}\n\nfunction mergeNested(\n  target: NestedValues,\n  values: NestedValues,\n  onlyIfMissing = false,\n) {\n  const evt: DatastarSignalEvent = {\n    added: [],\n    removed: [],\n    updated: [],\n  }\n  for (const key in values) {\n    if (Object.hasOwn(values, key)) {\n      if (key.match(/\\_\\_+/)) {\n        throw internalErr(from, 'InvalidSignalKey', { key })\n      }\n\n      const value = values[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        if (!target[key]) {\n          target[key] = {}\n        }\n        const subEvt = mergeNested(\n          target[key] as NestedValues,\n          value as NestedValues,\n          onlyIfMissing,\n        )\n        evt.added.push(...subEvt.added.map((k) => `${key}.${k}`))\n        evt.removed.push(...subEvt.removed.map((k) => `${key}.${k}`))\n        evt.updated.push(...subEvt.updated.map((k) => `${key}.${k}`))\n      } else {\n        const hasKey = Object.hasOwn(target, key)\n        if (hasKey) {\n          if (onlyIfMissing) continue\n          const t = target[key]\n          if (t instanceof Signal) {\n            const oldValue = t.value\n            t.value = value\n            if (oldValue !== value) {\n              evt.updated.push(key)\n            }\n            continue\n          }\n        }\n\n        const s = new Signal(value)\n        s._onChange = () => {\n          dispatchSignalEvent({ updated: [key] })\n        }\n        target[key] = s\n\n        evt.added.push(key)\n      }\n    }\n  }\n  return evt\n}\n\nfunction walkNestedSignal(\n  signal: NestedSignal,\n  cb: (dotDeliminatedPath: string, signal: Signal<any>) => void,\n): void {\n  for (const key in signal) {\n    if (Object.hasOwn(signal, key)) {\n      const value = signal[key]\n      if (value instanceof Signal) {\n        cb(key, value)\n      } else {\n        walkNestedSignal(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      }\n    }\n  }\n}\n\n// Recursive function to subset a nested object, each key is a dot-delimited path\nfunction nestedSubset(original: NestedValues, ...keys: string[]): NestedValues {\n  const subset: NestedValues = {}\n  for (const key of keys) {\n    const parts = key.split('.')\n    let subOriginal = original\n    let subSubset = subset\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subOriginal[part]) {\n        return {}\n      }\n      if (!subSubset[part]) {\n        subSubset[part] = {}\n      }\n      subOriginal = subOriginal[part] as NestedValues\n      subSubset = subSubset[part] as NestedValues\n    }\n    const last = parts[parts.length - 1]\n    subSubset[last] = subOriginal[last]\n  }\n  return subset\n}\n\n// Recursively walk a NestedValue with a callback and dot-delimited path\nexport function walkNestedValues(\n  nv: NestedValues,\n  cb: (path: string, value: any) => void,\n) {\n  for (const key in nv) {\n    if (Object.hasOwn(nv, key)) {\n      const value = nv[key]\n      if (value instanceof Object && !Array.isArray(value)) {\n        walkNestedValues(value, (path, value) => {\n          cb(`${key}.${path}`, value)\n        })\n      } else {\n        cb(key, value)\n      }\n    }\n  }\n}\n\nexport class SignalsRoot {\n  #signals: NestedSignal = {}\n\n  exists(dotDelimitedPath: string): boolean {\n    return !!this.signal(dotDelimitedPath)\n  }\n\n  signal<T>(dotDelimitedPath: string): Signal<T> | null {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        return null\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n    const signal = subSignals[last]\n    if (!signal)\n      throw internalErr(from, 'SignalNotFound', { path: dotDelimitedPath })\n    return signal as Signal<T>\n  }\n\n  setSignal<T extends Signal<T>>(dotDelimitedPath: string, signal: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n    subSignals[last] = signal\n  }\n\n  setComputed<T>(dotDelimitedPath: string, fn: () => T) {\n    const signal = computed(() => fn()) as Computed\n    this.setSignal(dotDelimitedPath, signal)\n  }\n\n  value<T>(dotDelimitedPath: string): T {\n    const signal = this.signal(dotDelimitedPath) as Signal<T>\n    return signal?.value\n  }\n\n  setValue<T>(dotDelimitedPath: string, value: T) {\n    const { signal } = this.upsertIfMissing(dotDelimitedPath, value)\n    const oldValue = signal.value\n    signal.value = value\n    if (oldValue !== value) {\n      dispatchSignalEvent({ updated: [dotDelimitedPath] })\n    }\n  }\n\n  upsertIfMissing<T>(dotDelimitedPath: string, defaultValue: T) {\n    const parts = dotDelimitedPath.split('.')\n    let subSignals = this.#signals\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i]\n      if (!subSignals[part]) {\n        subSignals[part] = {}\n      }\n      subSignals = subSignals[part] as NestedSignal\n    }\n    const last = parts[parts.length - 1]\n\n    const current = subSignals[last]\n    if (current instanceof Signal) {\n      return { signal: current as Signal<T>, inserted: false }\n    }\n\n    const signal = new Signal(defaultValue)\n    signal._onChange = () => {\n      dispatchSignalEvent({ updated: [dotDelimitedPath] })\n    }\n    subSignals[last] = signal\n\n    dispatchSignalEvent({ added: [dotDelimitedPath] })\n\n    return { signal: signal, inserted: true }\n  }\n\n  remove(...dotDelimitedPaths: string[]) {\n    if (!dotDelimitedPaths.length) {\n      this.#signals = {}\n      return\n    }\n    const removed = Array<string>()\n    for (const path of dotDelimitedPaths) {\n      const parts = path.split('.')\n      let subSignals = this.#signals\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i]\n        if (!subSignals[part]) {\n          return\n        }\n        subSignals = subSignals[part] as NestedSignal\n      }\n      const last = parts[parts.length - 1]\n      delete subSignals[last]\n      removed.push(path)\n    }\n    dispatchSignalEvent({ removed })\n  }\n\n  merge(other: NestedValues, onlyIfMissing = false) {\n    const evt = mergeNested(this.#signals, other, onlyIfMissing)\n    if (evt.added.length || evt.removed.length || evt.updated.length) {\n      dispatchSignalEvent(evt)\n    }\n  }\n\n  subset(...keys: string[]): NestedValues {\n    return nestedSubset(this.values(), ...keys)\n  }\n\n  walk(cb: (name: string, signal: Signal<any>) => void) {\n    walkNestedSignal(this.#signals, cb)\n  }\n\n  paths() {\n    const signalNames = new Array<string>()\n    this.walk((path) => signalNames.push(path))\n    return signalNames\n  }\n\n  values(onlyPublic = false): NestedValues {\n    return nestedValues(this.#signals, onlyPublic)\n  }\n\n  JSON(shouldIndent = true, onlyPublic = false) {\n    const values = this.values(onlyPublic)\n    if (!shouldIndent) {\n      return JSON.stringify(values)\n    }\n    return JSON.stringify(values, null, 2)\n  }\n\n  public toString() {\n    return this.JSON()\n  }\n}\n", "import { Hash, attrHash, elUniqId, walkDOM } from '../utils/dom'\nimport { camel } from '../utils/text'\nimport { effect } from '../vendored/preact-core'\nimport { DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport { SignalsRoot } from './signals'\nimport {\n  type ActionPlugin,\n  type ActionPlugins,\n  type AttributePlugin,\n  type DatastarPlugin,\n  type GlobalInitializer,\n  type HTMLorSVGElement,\n  type InitContext,\n  type OnRemovalFn,\n  PluginType,\n  Requirement,\n  type RuntimeContext,\n  type RuntimeExpressionFunction,\n  type WatcherPlugin,\n} from './types'\n\nconst signals: SignalsRoot = new SignalsRoot()\nconst actions: ActionPlugins = {}\nconst plugins: AttributePlugin[] = []\n\n// Map of cleanup functions by element ID, keyed by a dataset key-value hash\nconst removals = new Map<string, Map<number, OnRemovalFn>>()\n\nlet mutationObserver: MutationObserver | null = null\n\nlet alias = ''\nexport function setAlias(value: string) {\n  alias = value\n}\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n  for (const plugin of pluginsToLoad) {\n    const ctx: InitContext = {\n      plugin,\n      signals,\n      effect: (cb: () => void): OnRemovalFn => effect(cb),\n      actions,\n      removals,\n      applyToElement,\n    }\n\n    let globalInitializer: GlobalInitializer | undefined\n    switch (plugin.type) {\n      case PluginType.Action: {\n        actions[plugin.name] = plugin as ActionPlugin\n        break\n      }\n      case PluginType.Attribute: {\n        const ap = plugin as AttributePlugin\n        plugins.push(ap)\n        globalInitializer = ap.onGlobalInit\n        break\n      }\n      case PluginType.Watcher: {\n        const wp = plugin as WatcherPlugin\n        globalInitializer = wp.onGlobalInit\n        break\n      }\n      default: {\n        throw initErr('InvalidPluginType', ctx)\n      }\n    }\n    if (globalInitializer) {\n      globalInitializer(ctx)\n    }\n  }\n\n  // Sort attribute plugins by descending length then alphabetically\n  plugins.sort((a, b) => {\n    const lenDiff = b.name.length - a.name.length\n    if (lenDiff !== 0) return lenDiff\n    return a.name.localeCompare(b.name)\n  })\n}\n\n// Apply all plugins to all elements in the DOM\nexport function apply() {\n  // Delay applying plugins to give custom plugins a chance to load\n  queueMicrotask(() => {\n    applyToElement(document.documentElement)\n    observe()\n  })\n}\n\n// Apply all plugins to the element and its children\nfunction applyToElement(rootElement: HTMLorSVGElement) {\n  walkDOM(rootElement, (el) => {\n    // Check if the element has any data attributes already\n    const toApply = new Array<string>()\n    const elCleanups = removals.get(el.id) || new Map()\n    const toCleanup = new Map<number, OnRemovalFn>([...elCleanups])\n    const hashes = new Map<string, number>()\n\n    // Apply the plugins to the element in order of application\n    // since DOMStringMap is ordered, we can be deterministic\n    for (const datasetKey of Object.keys(el.dataset)) {\n      // Ignore data attributes that don\u2019t start with the alias\n      if (!datasetKey.startsWith(alias)) {\n        break\n      }\n\n      const datasetValue = el.dataset[datasetKey] || ''\n      const currentHash = attrHash(datasetKey, datasetValue)\n      hashes.set(datasetKey, currentHash)\n\n      // If the hash hasn't changed, ignore\n      // otherwise keep the old cleanup and add new to applys\n      if (elCleanups.has(currentHash)) {\n        toCleanup.delete(currentHash)\n      } else {\n        toApply.push(datasetKey)\n      }\n    }\n\n    // Clean up any old plugins and apply the new ones\n    for (const [_, cleanup] of toCleanup) {\n      cleanup()\n    }\n    for (const key of toApply) {\n      const h = hashes.get(key)!\n      applyAttributePlugin(el, key, h)\n    }\n  })\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe() {\n  if (mutationObserver) {\n    return\n  }\n\n  mutationObserver = new MutationObserver((mutations) => {\n    const toRemove = new Set<HTMLorSVGElement>()\n    const toApply = new Set<HTMLorSVGElement>()\n    for (const { target, type, addedNodes, removedNodes } of mutations) {\n      switch (type) {\n        case 'childList':\n          {\n            for (const node of removedNodes) {\n              toRemove.add(node as HTMLorSVGElement)\n            }\n            for (const node of addedNodes) {\n              toApply.add(node as HTMLorSVGElement)\n            }\n          }\n          break\n        case 'attributes': {\n          toApply.add(target as HTMLorSVGElement)\n\n          break\n        }\n      }\n    }\n    for (const el of toRemove) {\n      const elTracking = removals.get(el.id)\n      if (elTracking) {\n        for (const [hash, cleanup] of elTracking) {\n          cleanup()\n          elTracking.delete(hash)\n        }\n        if (elTracking.size === 0) {\n          removals.delete(el.id)\n        }\n      }\n    }\n    for (const el of toApply) {\n      applyToElement(el)\n    }\n  })\n\n  mutationObserver.observe(document.body, {\n    attributes: true,\n    attributeOldValue: true,\n    childList: true,\n    subtree: true,\n  })\n}\n\nfunction applyAttributePlugin(\n  el: HTMLorSVGElement,\n  camelCasedKey: string,\n  hash: number,\n) {\n  // Extract the raw key from the dataset\n  const rawKey = camel(camelCasedKey.slice(alias.length))\n\n  // Find the plugin that matches, since the plugins are sorted by length descending and alphabetically. The first match will be the most specific.\n  const plugin = plugins.find((p) => {\n    // Ignore keys with the plugin name as a prefix (ignores `classes` but not `classBold`)\n    const regex = new RegExp(`^${p.name}([A-Z]|_|$)`)\n    return regex.test(rawKey)\n  })\n\n  // Skip if no plugin is found\n  if (!plugin) return\n\n  // Ensure the element has an id\n  if (!el.id.length) el.id = elUniqId(el)\n\n  // Extract the key and modifiers\n  let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/\\_\\_+/)\n\n  const hasKey = key.length > 0\n  if (hasKey) {\n    key = camel(key)\n  }\n  const value = el.dataset[camelCasedKey] || ''\n  const hasValue = value.length > 0\n\n  // Create the runtime context\n  const ctx: RuntimeContext = {\n    signals,\n    applyToElement,\n    effect: (cb: () => void): OnRemovalFn => effect(cb),\n    actions,\n    removals,\n    genRX: () => genRX(ctx, ...(plugin.argNames || [])),\n    plugin,\n    el,\n    rawKey,\n    key,\n    value,\n    mods: new Map(),\n  }\n\n  // Check the requirements\n  const keyReq = plugin.keyReq || Requirement.Allowed\n  if (hasKey) {\n    if (keyReq === Requirement.Denied) {\n      throw runtimeErr(`${plugin.name}KeyNotAllowed`, ctx)\n    }\n  } else if (keyReq === Requirement.Must) {\n    throw runtimeErr(`${plugin.name}KeyRequired`, ctx)\n  }\n\n  const valReq = plugin.valReq || Requirement.Allowed\n  if (hasValue) {\n    if (valReq === Requirement.Denied) {\n      throw runtimeErr(`${plugin.name}ValueNotAllowed`, ctx)\n    }\n  } else if (valReq === Requirement.Must) {\n    throw runtimeErr(`${plugin.name}ValueRequired`, ctx)\n  }\n\n  // Check for exclusive requirements\n  if (keyReq === Requirement.Exclusive || valReq === Requirement.Exclusive) {\n    if (hasKey && hasValue) {\n      throw runtimeErr(`${plugin.name}KeyAndValueProvided`, ctx)\n    }\n    if (!hasKey && !hasValue) {\n      throw runtimeErr(`${plugin.name}KeyOrValueRequired`, ctx)\n    }\n  }\n\n  for (const rawMod of rawModifiers) {\n    const [label, ...mod] = rawMod.split('.')\n    ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())))\n  }\n\n  // Load the plugin\n  const cleanup = plugin.onLoad(ctx) ?? (() => {})\n\n  // Store the cleanup function\n  let elTracking = removals.get(el.id)\n  if (!elTracking) {\n    elTracking = new Map()\n    removals.set(el.id, elTracking)\n  }\n  elTracking.set(hash, cleanup)\n}\n\nfunction genRX(\n  ctx: RuntimeContext,\n  ...argNames: string[]\n): RuntimeExpressionFunction {\n  let userExpression = ''\n\n  // This regex allows Datastar expressions to support nested\n  // regex and strings that contain ; without breaking.\n  //\n  // Each of these regex defines a block type we want to match\n  // (importantly we ignore the content within these blocks):\n  //\n  // regex            \\/(\\\\\\/|[^\\/])*\\/\n  // double quotes      \"(\\\\\"|[^\\\"])*\"\n  // single quotes      '(\\\\'|[^'])*'\n  // ticks              `(\\\\`|[^`])*`\n  //\n  // We also want to match the non delimiter part of statements\n  // note we only support ; statement delimiters:\n  //\n  // [^;]\n  //\n  const statementRe =\n    /(\\/(\\\\\\/|[^\\/])*\\/|\"(\\\\\"|[^\\\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|[^;])+/gm\n  const statements = ctx.value.trim().match(statementRe)\n  if (statements) {\n    const lastIdx = statements.length - 1\n    const last = statements[lastIdx].trim()\n    if (!last.startsWith('return')) {\n      statements[lastIdx] = `return (${last});`\n    }\n    userExpression = statements.join(';\\n')\n  }\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = new RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  for (const match of userExpression.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = new Hash('dsEscaped').with(k).string\n    escaped.set(v, k)\n    userExpression = userExpression.replace(DSP + k + DSS, v)\n  }\n\n  const fnCall = /@(\\w*)\\(/gm\n  const matches = userExpression.matchAll(fnCall)\n  const methodsCalled = new Set<string>()\n  for (const match of matches) {\n    methodsCalled.add(match[1])\n  }\n\n  // Replace any action calls\n  const actionsRe = new RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm')\n\n  // Add ctx to action calls\n  userExpression = userExpression.replaceAll(\n    actionsRe,\n    'ctx.actions.$1.fn(ctx,',\n  )\n\n  // Replace any signal calls\n  const signalNames = ctx.signals.paths()\n  if (signalNames.length) {\n    // Match any valid `$signalName` followed by a non-word character or end of string\n    const signalsRe = new RegExp(`\\\\$(${signalNames.join('|')})(\\\\W|$)`, 'gm')\n    userExpression = userExpression.replaceAll(\n      signalsRe,\n      `ctx.signals.signal('$1').value$2`,\n    )\n  }\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    userExpression = userExpression.replace(k, v)\n  }\n\n  const fnContent = `return (() => {\\n${userExpression}\\n})()` // Wrap in IIFE\n  ctx.fnContent = fnContent\n\n  try {\n    const fn = new Function('ctx', ...argNames, fnContent)\n    return (...args: any[]) => {\n      try {\n        return fn(ctx, ...args)\n      } catch (error: any) {\n        throw runtimeErr('ExecuteExpression', ctx, {\n          error: error.message,\n        })\n      }\n    }\n  } catch (error: any) {\n    throw runtimeErr('GenerateExpression', ctx, {\n      error: error.message,\n    })\n  }\n}\n", "import { DSP } from '../engine/consts'\n// @ts-ignore\nconst _ = DSP // This is to force the import of DSP first in the compiled code\n\nimport { Computed } from '../plugins/official/core/attributes/computed'\nimport { Signals } from '../plugins/official/core/attributes/signals'\nimport { Star } from '../plugins/official/core/attributes/star'\nimport { apply, load, setAlias } from './engine'\n\nload(Star, Signals, Computed)\n\nexport { apply, load, setAlias }\n", "import { DATASTAR } from '../../../engine/consts'\n\nexport const DATASTAR_SSE_EVENT = `${DATASTAR}-sse`\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\nexport const RETRIES_FAILED = 'retries-failed'\n\nexport interface DatastarSSEEvent {\n  type: string\n  elId: string\n  argsRaw: Record<string, string>\n}\n\nexport interface CustomEventMap {\n  [DATASTAR_SSE_EVENT]: CustomEvent<DatastarSSEEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\n\ndeclare global {\n  interface Document {\n    //adds definition to Document, but you can do the same with HTMLElement\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n  }\n}\n\nexport function datastarSSEEventWatcher(\n  eventType: string,\n  fn: (argsRaw: Record<string, string>) => void,\n) {\n  document.addEventListener(\n    DATASTAR_SSE_EVENT,\n    (event: CustomEvent<DatastarSSEEvent>) => {\n      if (event.detail.type !== eventType) return\n      const { argsRaw } = event.detail\n      fn(argsRaw)\n    },\n  )\n}\n\nexport function dispatchSSE(\n  type: string,\n  elId: string,\n  argsRaw: Record<string, string>,\n) {\n  document.dispatchEvent(\n    new CustomEvent<DatastarSSEEvent>(DATASTAR_SSE_EVENT, {\n      detail: { type, elId, argsRaw },\n    }),\n  )\n}\n", "import { RETRIES_FAILED, dispatchSSE } from '../plugins/official/backend/shared'\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n  /** The event ID to set the EventSource object's last event ID value. */\n  id: string\n  /** A string identifying the type of event described. */\n  event: string\n  /** The event data */\n  data: string\n  /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n  retry?: number\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(\n  stream: ReadableStream<Uint8Array>,\n  onChunk: (arr: Uint8Array) => void,\n) {\n  const reader = stream.getReader()\n  let result: ReadableStreamReadResult<Uint8Array>\n  while (!(result = await reader.read()).done) {\n    onChunk(result.value)\n  }\n}\n\nenum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58,\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(\n  onLine: (line: Uint8Array, fieldLength: number) => void,\n) {\n  let buffer: Uint8Array | undefined\n  let position: number // current read position\n  let fieldLength: number // length of the `field` portion of the line\n  let discardTrailingNewline = false\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array) {\n    if (buffer === undefined) {\n      buffer = arr\n      position = 0\n      fieldLength = -1\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr)\n    }\n\n    const bufLength = buffer.length\n    let lineStart = 0 // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === ControlChars.NewLine) {\n          lineStart = ++position // skip to next char\n        }\n\n        discardTrailingNewline = false\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1 // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case ControlChars.Colon:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart\n            }\n            break\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          // biome-ignore lint/suspicious/noFallthroughSwitchClause: <explanation>\n          case ControlChars.CarriageReturn:\n            discardTrailingNewline = true\n          case ControlChars.NewLine:\n            lineEnd = position\n            break\n        }\n      }\n\n      if (lineEnd === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next arr and then continue parsing:\n        break\n      }\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)\n      lineStart = position // we're now on the next line\n      fieldLength = -1\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined // we've finished reading it\n    } else if (lineStart !== 0) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart)\n      position -= lineStart\n    }\n  }\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void,\n) {\n  let message = newMessage()\n  const decoder = new TextDecoder()\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(line: Uint8Array, fieldLength: number) {\n    if (line.length === 0) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message)\n      message = newMessage()\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength))\n      const valueOffset =\n        fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1)\n      const value = decoder.decode(line.subarray(valueOffset))\n\n      switch (field) {\n        case 'data':\n          // if this message already has data, append the new value to the old.\n          // otherwise, just set to the new value:\n          message.data = message.data ? `${message.data}\\n${value}` : value // otherwise,\n          break\n        case 'event':\n          message.event = value\n          break\n        case 'id':\n          onId((message.id = value))\n          break\n        case 'retry': {\n          const retry = Number.parseInt(value, 10)\n          if (!Number.isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry))\n          }\n          break\n        }\n      }\n    }\n  }\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n  const res = new Uint8Array(a.length + b.length)\n  res.set(a)\n  res.set(b, a.length)\n  return res\n}\n\nfunction newMessage(): EventSourceMessage {\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  return {\n    data: '',\n    event: '',\n    id: '',\n    retry: undefined,\n  }\n}\n\nexport const EventStreamContentType = 'text/event-stream'\n\nconst LastEventId = 'last-event-id'\n\nexport interface FetchEventSourceInit extends RequestInit {\n  /**\n   * The request headers. FetchEventSource only supports the Record<string,string> format.\n   */\n  headers?: Record<string, string>\n\n  /**\n   * Called when a response is received. Use this to validate that the response\n   * actually matches what you expect (and throw if it doesn't.) If not provided,\n   * will default to a basic validation to ensure the content-type is text/event-stream.\n   */\n  onopen?: (response: Response) => Promise<void>\n\n  /**\n   * Called when a message is received. NOTE: Unlike the default browser\n   * EventSource.onmessage, this callback is called for _all_ events,\n   * even ones with a custom `event` field.\n   */\n  onmessage?: (ev: EventSourceMessage) => void\n\n  /**\n   * Called when a response finishes. If you don't expect the server to kill\n   * the connection, you can throw an exception here and retry using onerror.\n   */\n  onclose?: () => void\n\n  /**\n   * Called when there is any error making the request / processing messages /\n   * handling callbacks etc. Use this to control the retry strategy: if the\n   * error is fatal, rethrow the error inside the callback to stop the entire\n   * operation. Otherwise, you can return an interval (in milliseconds) after\n   * which the request will automatically retry (with the last-event-id).\n   * If this callback is not specified, or it returns undefined, fetchEventSource\n   * will treat every error as retriable and will try again after 1 second.\n   */\n  onerror?: (err: any) => number | null | undefined | void\n\n  /**\n   * If true, will keep the request open even if the document is hidden.\n   * By default, fetchEventSource will close the request and reopen it\n   * automatically when the document becomes visible again.\n   */\n  openWhenHidden?: boolean\n\n  /** The Fetch function to use. Defaults to window.fetch */\n  fetch?: typeof fetch\n\n  /** The retry interval in milliseconds. Defaults to 1_000 */\n  retryInterval?: number\n\n  /** The scaler for the retry interval. Defaults to 2 */\n  retryScaler?: number\n\n  /** The maximum retry interval in milliseconds. Defaults to 30_000 */\n  retryMaxWaitMs?: number\n\n  /** The maximum number of retries before giving up. Defaults to 10 */\n  retryMaxCount?: number\n}\n\nexport function fetchEventSource(\n  input: RequestInfo,\n  elId: string,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retryInterval = 1_000,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    ...rest\n  }: FetchEventSourceInit,\n) {\n  return new Promise<void>((resolve, reject) => {\n    let retries = 0\n\n    // make a copy of the input headers since we may modify it below:\n    const headers = { ...inputHeaders }\n    if (!headers.accept) {\n      headers.accept = EventStreamContentType\n    }\n\n    let curRequestController: AbortController\n    function onVisibilityChange() {\n      curRequestController.abort() // close existing request on every visibility change\n      if (!document.hidden) {\n        create() // page is now visible again, recreate request.\n      }\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange)\n    }\n\n    let retryTimer = 0\n    function dispose() {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      window.clearTimeout(retryTimer)\n      curRequestController.abort()\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose()\n      resolve() // don't waste time constructing/logging errors\n    })\n\n    const fetch = inputFetch ?? window.fetch\n    const onopen = inputOnOpen ?? function defaultOnOpen() {}\n\n    async function create() {\n      curRequestController = new AbortController()\n      try {\n        const response = await fetch(input, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal,\n        })\n\n        await onopen(response)\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // signals the id and send it back on the next retry:\n                  headers[LastEventId] = id\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers[LastEventId]\n                }\n              },\n              (retry) => {\n                retryInterval = retry\n              },\n              onmessage,\n            ),\n          ),\n        )\n\n        onclose?.()\n        dispose()\n        resolve()\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          // if we haven't aborted the request ourselves:\n          try {\n            // check if we need to retry:\n            const interval: any = onerror?.(err) ?? retryInterval\n            window.clearTimeout(retryTimer)\n            retryTimer = window.setTimeout(create, interval)\n            retryInterval *= retryScaler // exponential backoff\n            retryInterval = Math.min(retryInterval, retryMaxWaitMs)\n            retries++\n            if (retries > retryMaxCount) {\n              dispatchSSE(RETRIES_FAILED, elId, {})\n\n              // we should not retry anymore:\n              dispose()\n              // Max retries reached, check your server or network connection\n              reject('Max retries reached.')\n            } else {\n              console.error(\n                `Datastar failed to reach ${input.toString()} retrying in ${interval}ms.`,\n              )\n            }\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose()\n            reject(innerErr)\n          }\n        }\n      }\n    }\n\n    create()\n  })\n}\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DATASTAR,\n  DATASTAR_REQUEST,\n  DefaultSseRetryDurationMs,\n} from '../../../../engine/consts'\nimport { runtimeErr } from '../../../../engine/errors'\nimport type { RuntimeContext } from '../../../../engine/types'\nimport {\n  type FetchEventSourceInit,\n  fetchEventSource,\n} from '../../../../vendored/fetch-event-source'\nimport { dispatchSSE, ERROR, FINISHED, RETRYING, STARTED } from '../shared'\n\nconst isWrongContent = (err: any) => `${err}`.includes('text/event-stream')\n\nexport type SSEArgs = {\n  headers?: Record<string, string>\n  openWhenHidden?: boolean\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  abort?: AbortSignal\n} & (\n  | {\n      contentType: 'json'\n      includeLocal?: boolean\n    }\n  | {\n      contentType: 'form'\n      selector?: string\n    }\n)\n\nexport const sse = async (\n  ctx: RuntimeContext,\n  method: string,\n  url: string,\n  args: SSEArgs,\n) => {\n  const {\n    el,\n    signals,\n  } = ctx\n  const elId = el.id\n  const {\n    headers: userHeaders,\n    contentType,\n    includeLocal,\n    selector,\n    openWhenHidden,\n    retryInterval,\n    retryScaler,\n    retryMaxWaitMs,\n    retryMaxCount,\n    abort,\n  } = Object.assign(\n    {\n      headers: {},\n      contentType: 'json',\n      includeLocal: false,\n      selector: null,\n      openWhenHidden: false, // will keep the request open even if the document is hidden.\n      retryInterval: DefaultSseRetryDurationMs, // the retry interval in milliseconds\n      retryScaler: 2, // the amount to multiply the retry interval by each time\n      retryMaxWaitMs: 30_000, // the maximum retry interval in milliseconds\n      retryMaxCount: 10, // the maximum number of retries before giving up\n      abort: undefined,\n    },\n    args,\n  )\n  const action = method.toLowerCase()\n  let cleanupFn = (): void => {}\n  try {\n    dispatchSSE(STARTED, elId, {})\n    if (!url?.length) {\n      throw runtimeErr('SseNoUrlProvided', ctx, { action })\n    }\n\n    const initialHeaders: Record<string, any> = {}\n    initialHeaders[DATASTAR_REQUEST] = true\n    // We ignore the content-type header if using form data\n    // if missing the boundary will be set automatically\n    if (contentType === 'json') {\n      initialHeaders['Content-Type'] = 'application/json'\n    }\n    const headers = Object.assign({}, initialHeaders, userHeaders)\n\n    const req: FetchEventSourceInit = {\n      method,\n      headers,\n      openWhenHidden,\n      retryInterval,\n      retryScaler,\n      retryMaxWaitMs,\n      retryMaxCount,\n      signal: abort,\n      onopen: async (response: Response) => {\n        if (response.status >= 400) {\n          const status = response.status.toString()\n          dispatchSSE(ERROR, elId, { status })\n        }\n      },\n      onmessage: (evt) => {\n        if (!evt.event.startsWith(DATASTAR)) {\n          return\n        }\n        const type = evt.event\n        const argsRawLines: Record<string, string[]> = {}\n\n        const lines = evt.data.split('\\n')\n        for (const line of lines) {\n          const colonIndex = line.indexOf(' ')\n          const key = line.slice(0, colonIndex)\n          let argLines = argsRawLines[key]\n          if (!argLines) {\n            argLines = []\n            argsRawLines[key] = argLines\n          }\n          const value = line.slice(colonIndex + 1)\n          argLines.push(value)\n        }\n\n        const argsRaw: Record<string, string> = {}\n        for (const [key, lines] of Object.entries(argsRawLines)) {\n          argsRaw[key] = lines.join('\\n')\n        }\n\n        dispatchSSE(type, elId, argsRaw)\n      },\n      onerror: (error) => {\n        if (isWrongContent(error)) {\n          // don't retry if the content-type is wrong\n          throw runtimeErr('InvalidContentType', ctx, { url })\n        }\n        // do nothing and it will retry\n        if (error) {\n          console.error(error.message)\n          dispatchSSE(RETRYING, elId, { message: error.message })\n        }\n      },\n    }\n\n    const urlInstance = new URL(url, window.location.origin)\n    const queryParams = new URLSearchParams(urlInstance.search)\n\n    if (contentType === 'json') {\n      const json = signals.JSON(false, !includeLocal)\n      if (method === 'GET') {\n        queryParams.set(DATASTAR, json)\n      } else {\n        req.body = json\n      }\n    } else if (contentType === 'form') {\n      const formEl = selector\n        ? document.querySelector(selector)\n        : el.closest('form')\n      if (formEl === null) {\n        if (selector) {\n          throw runtimeErr('SseFormNotFound', ctx, { action, selector })\n        }\n        throw runtimeErr('SseClosestFormNotFound', ctx, { action })\n      }\n      if (el !== formEl) {\n        const preventDefault = (evt: Event) => evt.preventDefault()\n        formEl.addEventListener('submit', preventDefault)\n        cleanupFn = (): void =>\n          formEl.removeEventListener('submit', preventDefault)\n      }\n      if (!formEl.checkValidity()) {\n        formEl.reportValidity()\n        cleanupFn()\n        return\n      }\n      const formData = new FormData(formEl)\n      if (method === 'GET') {\n        const formParams = new URLSearchParams(formData as any)\n        for (const [key, value] of formParams) {\n          queryParams.set(key, value)\n        }\n      } else {\n        req.body = formData\n      }\n    } else {\n      throw runtimeErr('SseInvalidContentType', ctx, { action, contentType })\n    }\n\n    urlInstance.search = queryParams.toString()\n\n    try {\n      await fetchEventSource(urlInstance.toString(), elId, req)\n    } catch (error) {\n      if (!isWrongContent(error)) {\n        throw runtimeErr('SseFetchFailed', ctx, { method, url, error })\n      }\n      // exit gracefully and do nothing if the content-type is wrong\n      // this can happen if the client is sending a request\n      // where no response is expected, and they haven't\n      // set the content-type to text/event-stream\n    }\n  } finally {\n    dispatchSSE(FINISHED, elId, {})\n    cleanupFn()\n  }\n}\n", "// Icon: material-symbols:delete-outline\n// Slug: Use a DELETE request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const DELETE: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'delete',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'DELETE', url, { ...args })\n  },\n}\n", "// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const GET: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'get',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'GET', url, { ...args })\n  },\n}\n", "// Icon: fluent:patch-24-filled\n// Slug: Use a PATCH request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const PATCH: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'patch',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'PATCH', url, { ...args })\n  },\n}\n", "// Icon: ri:signpost-fill\n// Slug: Use a POST request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const POST: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'post',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'POST', url, { ...args })\n  },\n}\n", "// Icon: material-symbols:arrows-input\n// Slug: Use a PUT request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\nimport { type SSEArgs, sse } from './sse'\n\nexport const PUT: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'put',\n  fn: async (ctx: RuntimeContext, url: string, args: SSEArgs) => {\n    return sse(ctx, 'PUT', url, { ...args })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:clock-loader-60-sharp\n// Slug: Sets the indicator signal used when fetching data via SSE\n// Description: must be a valid signal name\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing, trimDollarSignPrefix } from '../../../../utils/text'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  FINISHED,\n  STARTED,\n} from '../shared'\n\nexport const Indicator: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'indicator',\n  keyReq: Requirement.Exclusive,\n  valReq: Requirement.Exclusive,\n  onLoad: ({ el, key, mods, signals, value }) => {\n    const signalName = key\n      ? modifyCasing(key, mods)\n      : trimDollarSignPrefix(value)\n    const { signal } = signals.upsertIfMissing(signalName, false)\n    const watcher = ((event: CustomEvent<DatastarSSEEvent>) => {\n      const {\n        type,\n        elId,\n      } = event.detail\n      if (elId !== el.id) return\n      switch (type) {\n        case STARTED:\n          signal.value = true\n          break\n        case FINISHED:\n          signal.value = false\n          // Remove the event listener only when finished, in case the element is removed while the request is still in progress\n          document.removeEventListener(DATASTAR_SSE_EVENT, watcher)\n          break\n      }\n    }) as EventListener\n\n    document.addEventListener(DATASTAR_SSE_EVENT, watcher)\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: tabler:file-type-js\n// Slug: Execute JavaScript using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultExecuteScriptAttributes,\n  DefaultExecuteScriptAutoRemove,\n  EventTypes,\n} from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString } from '../../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const ExecuteScript: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.ExecuteScript,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.ExecuteScript,\n      ({\n        autoRemove: autoRemoveRaw = `${DefaultExecuteScriptAutoRemove}`,\n        attributes: attributesRaw = DefaultExecuteScriptAttributes,\n        script,\n      }) => {\n        const autoRemove = isBoolString(autoRemoveRaw)\n        if (!script?.length) {\n          throw initErr('NoScriptProvided', ctx)\n        }\n        const scriptEl = document.createElement('script')\n        for (const attr of attributesRaw.split('\\n')) {\n          const pivot = attr.indexOf(' ')\n          const key = pivot ? attr.slice(0, pivot) : attr\n          const value = pivot ? attr.slice(pivot) : ''\n          scriptEl.setAttribute(key.trim(), value.trim())\n        }\n        scriptEl.text = script\n        document.head.appendChild(scriptEl)\n        if (autoRemove) {\n          scriptEl.remove()\n        }\n      },\n    )\n  },\n}\n", "import type { EventCallbackHandler, Modifiers } from \"../engine/types\"\n\nexport interface DocumentSupportingViewTransitionAPI {\n  startViewTransition(\n    updateCallback: () => Promise<void> | void,\n  ): IViewTransition\n}\n\nexport interface IViewTransition {\n  finished: Promise<void>\n  ready: Promise<void>\n  updateCallbackDone: Promise<void>\n  skipTransition(): void\n}\n\nexport const docWithViewTransitionAPI =\n  document as unknown as DocumentSupportingViewTransitionAPI\n\nexport const supportsViewTransitions =\n  !!docWithViewTransitionAPI.startViewTransition\n\nexport function modifyViewTransition(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  if (mods.has('viewtransition') && supportsViewTransitions) {\n    const cb = callback // I hate javascript\n    callback = (...args: any[]) =>\n      document.startViewTransition(() => cb(...args))\n  }\n\n  return callback\n}", "/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n */\n\n/**\n * @typedef {Object} IdSets\n * @property {Set<string>} persistentIds\n * @property {Map<Node, Set<string>>} idMap\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Element} target\n   * @property {Element} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {ConfigInternal['restoreFocus']} restoreFocus\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  const noOp = () => {};\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  const defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: (elt) => elt.getAttribute(\"im-preserve\") === \"true\",\n      shouldReAppend: (elt) => elt.getAttribute(\"im-re-append\") === \"true\",\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n    restoreFocus: true,\n  };\n\n  /**\n   * Core idiomorph function for morphing one DOM tree to another\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    oldNode = normalizeElement(oldNode);\n    const newNode = normalizeParent(newContent);\n    const ctx = createMorphContext(oldNode, newNode, config);\n\n    const morphedNodes = saveAndRestoreFocus(ctx, () => {\n      return withHeadBlocking(\n        ctx,\n        oldNode,\n        newNode,\n        /** @param {MorphContext} ctx */ (ctx) => {\n          if (ctx.morphStyle === \"innerHTML\") {\n            morphChildren(ctx, oldNode, newNode);\n            return Array.from(oldNode.childNodes);\n          } else {\n            return morphOuterHTML(ctx, oldNode, newNode);\n          }\n        },\n      );\n    });\n\n    ctx.pantry.remove();\n    return morphedNodes;\n  }\n\n  /**\n   * Morph just the outerHTML of the oldNode to the newContent\n   * We have to be careful because the oldNode could have siblings which need to be untouched\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @returns {Node[]}\n   */\n  function morphOuterHTML(ctx, oldNode, newNode) {\n    const oldParent = normalizeParent(oldNode);\n    morphChildren(\n      ctx,\n      oldParent,\n      newNode,\n      // these two optional params are the secret sauce\n      oldNode, // start point for iteration\n      oldNode.nextSibling, // end point for iteration\n    );\n    // this is safe even with siblings, because normalizeParent returns a SlicedParentNode if needed.\n    return Array.from(oldParent.childNodes);\n  }\n\n  /**\n   * @param {MorphContext} ctx\n   * @param {Function} fn\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function saveAndRestoreFocus(ctx, fn) {\n    if (!ctx.config.restoreFocus) return fn();\n    let activeElement =\n      /** @type {HTMLInputElement|HTMLTextAreaElement|null} */ (\n        document.activeElement\n      );\n\n    // don't bother if the active element is not an input or textarea\n    if (\n      !(\n        activeElement instanceof HTMLInputElement ||\n        activeElement instanceof HTMLTextAreaElement\n      )\n    ) {\n      return fn();\n    }\n\n    const { id: activeElementId, selectionStart, selectionEnd } = activeElement;\n\n    const results = fn();\n\n    if (activeElementId && activeElementId !== document.activeElement?.id) {\n      activeElement = ctx.target.querySelector(`[id=\"${activeElementId}\"]`);\n      activeElement?.focus();\n    }\n    if (activeElement && !activeElement.selectionEnd && selectionEnd) {\n      activeElement.setSelectionRange(selectionStart, selectionEnd);\n    }\n\n    return results;\n  }\n\n  const morphChildren = (function () {\n    /**\n     * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n     * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n     * by using id sets, we are able to better match up with content deeper in the DOM.\n     *\n     * Basic algorithm:\n     * - for each node in the new content:\n     *   - search self and siblings for an id set match, falling back to a soft match\n     *   - if match found\n     *     - remove any nodes up to the match:\n     *       - pantry persistent nodes\n     *       - delete the rest\n     *     - morph the match\n     *   - elsif no match found, and node is persistent\n     *     - find its match by querying the old root (future) and pantry (past)\n     *     - move it and its children here\n     *     - morph it\n     *   - else\n     *     - create a new node from scratch as a last result\n     *\n     * @param {MorphContext} ctx the merge context\n     * @param {Element} oldParent the old content that we are merging the new content into\n     * @param {Element} newParent the parent element of the new content\n     * @param {Node|null} [insertionPoint] the point in the DOM we start morphing at (defaults to first child)\n     * @param {Node|null} [endPoint] the point in the DOM we stop morphing at (defaults to after last child)\n     */\n    function morphChildren(\n      ctx,\n      oldParent,\n      newParent,\n      insertionPoint = null,\n      endPoint = null,\n    ) {\n      // normalize\n      if (\n        oldParent instanceof HTMLTemplateElement &&\n        newParent instanceof HTMLTemplateElement\n      ) {\n        // @ts-ignore we can pretend the DocumentFragment is an Element\n        oldParent = oldParent.content;\n        // @ts-ignore ditto\n        newParent = newParent.content;\n      }\n      insertionPoint ||= oldParent.firstChild;\n\n      // run through all the new content\n      for (const newChild of newParent.childNodes) {\n        // once we reach the end of the old parent content skip to the end and insert the rest\n        if (insertionPoint && insertionPoint != endPoint) {\n          const bestMatch = findBestMatch(\n            ctx,\n            newChild,\n            insertionPoint,\n            endPoint,\n          );\n          if (bestMatch) {\n            // if the node to morph is not at the insertion point then remove/move up to it\n            if (bestMatch !== insertionPoint) {\n              removeNodesBetween(ctx, insertionPoint, bestMatch);\n            }\n            morphNode(bestMatch, newChild, ctx);\n            insertionPoint = bestMatch.nextSibling;\n            continue;\n          }\n        }\n\n        // if the matching node is elsewhere in the original content\n        if (newChild instanceof Element && ctx.persistentIds.has(newChild.id)) {\n          // move it and all its children here and morph\n          const movedChild = moveBeforeById(\n            oldParent,\n            newChild.id,\n            insertionPoint,\n            ctx,\n          );\n          morphNode(movedChild, newChild, ctx);\n          insertionPoint = movedChild.nextSibling;\n          continue;\n        }\n\n        // last resort: insert the new node from scratch\n        const insertedNode = createNode(\n          oldParent,\n          newChild,\n          insertionPoint,\n          ctx,\n        );\n        // could be null if beforeNodeAdded prevented insertion\n        if (insertedNode) {\n          insertionPoint = insertedNode.nextSibling;\n        }\n      }\n\n      // remove any remaining old nodes that didn't match up with new content\n      while (insertionPoint && insertionPoint != endPoint) {\n        const tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n    }\n\n    /**\n     * This performs the action of inserting a new node while handling situations where the node contains\n     * elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n     *\n     * @param {Element} oldParent\n     * @param {Node} newChild\n     * @param {Node|null} insertionPoint\n     * @param {MorphContext} ctx\n     * @returns {Node|null}\n     */\n    function createNode(oldParent, newChild, insertionPoint, ctx) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return null;\n      if (ctx.idMap.has(newChild)) {\n        // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n        const newEmptyChild = document.createElement(\n          /** @type {Element} */ (newChild).tagName,\n        );\n        oldParent.insertBefore(newEmptyChild, insertionPoint);\n        morphNode(newEmptyChild, newChild, ctx);\n        ctx.callbacks.afterNodeAdded(newEmptyChild);\n        return newEmptyChild;\n      } else {\n        // optimisation: no id state to preserve so we can just insert a clone of the newChild and its descendants\n        const newClonedChild = document.importNode(newChild, true); // importNode to not mutate newParent\n        oldParent.insertBefore(newClonedChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newClonedChild);\n        return newClonedChild;\n      }\n    }\n\n    //=============================================================================\n    // Matching Functions\n    //=============================================================================\n    const findBestMatch = (function () {\n      /**\n       * Scans forward from the startPoint to the endPoint looking for a match\n       * for the node. It looks for an id set match first, then a soft match.\n       * We abort softmatching if we find two future soft matches, to reduce churn.\n       * @param {Node} node\n       * @param {MorphContext} ctx\n       * @param {Node | null} startPoint\n       * @param {Node | null} endPoint\n       * @returns {Node | null}\n       */\n      function findBestMatch(ctx, node, startPoint, endPoint) {\n        let softMatch = null;\n        let nextSibling = node.nextSibling;\n        let siblingSoftMatchCount = 0;\n\n        let cursor = startPoint;\n        while (cursor && cursor != endPoint) {\n          // soft matching is a prerequisite for id set matching\n          if (isSoftMatch(cursor, node)) {\n            if (isIdSetMatch(ctx, cursor, node)) {\n              return cursor; // found an id set match, we're done!\n            }\n\n            // we haven't yet saved a soft match fallback\n            if (softMatch === null) {\n              // the current soft match will hard match something else in the future, leave it\n              if (!ctx.idMap.has(cursor)) {\n                // save this as the fallback if we get through the loop without finding a hard match\n                softMatch = cursor;\n              }\n            }\n          }\n          if (\n            softMatch === null &&\n            nextSibling &&\n            isSoftMatch(cursor, nextSibling)\n          ) {\n            // The next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling;\n\n            // If there are two future soft matches, block soft matching for this node to allow\n            // future siblings to soft match. This is to reduce churn in the DOM when an element\n            // is prepended.\n            if (siblingSoftMatchCount >= 2) {\n              softMatch = undefined;\n            }\n          }\n\n          // if the current node contains active element, stop looking for better future matches,\n          // because if one is found, this node will be moved to the pantry, reparenting it and thus losing focus\n          if (cursor.contains(document.activeElement)) break;\n\n          cursor = cursor.nextSibling;\n        }\n\n        return softMatch || null;\n      }\n\n      /**\n       *\n       * @param {MorphContext} ctx\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isIdSetMatch(ctx, oldNode, newNode) {\n        let oldSet = ctx.idMap.get(oldNode);\n        let newSet = ctx.idMap.get(newNode);\n\n        if (!newSet || !oldSet) return false;\n\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       *\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isSoftMatch(oldNode, newNode) {\n        // ok to cast: if one is not element, `id` and `tagName` will be undefined and we'll just compare that.\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        return (\n          oldElt.nodeType === newElt.nodeType &&\n          oldElt.tagName === newElt.tagName &&\n          // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n          // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n          // its not persistent, and new nodes can't have any hidden state.\n          (!oldElt.id || oldElt.id === newElt.id)\n        );\n      }\n\n      return findBestMatch;\n    })();\n\n    //=============================================================================\n    // DOM Manipulation Functions\n    //=============================================================================\n\n    /**\n     * Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n     * - Persistent nodes will be moved to the pantry for later reuse\n     * - Other nodes will have their hooks called, and then are removed\n     * @param {MorphContext} ctx\n     * @param {Node} node\n     */\n    function removeNode(ctx, node) {\n      // are we going to id set match this later?\n      if (ctx.idMap.has(node)) {\n        // skip callbacks and move to pantry\n        moveBefore(ctx.pantry, node, null);\n      } else {\n        // remove for realsies\n        if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n        node.parentNode?.removeChild(node);\n        ctx.callbacks.afterNodeRemoved(node);\n      }\n    }\n\n    /**\n     * Remove nodes between the start and end nodes\n     * @param {MorphContext} ctx\n     * @param {Node} startInclusive\n     * @param {Node} endExclusive\n     * @returns {Node|null}\n     */\n    function removeNodesBetween(ctx, startInclusive, endExclusive) {\n      /** @type {Node | null} */\n      let cursor = startInclusive;\n      // remove nodes until the endExclusive node\n      while (cursor && cursor !== endExclusive) {\n        let tempNode = /** @type {Node} */ (cursor);\n        cursor = cursor.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n      return cursor;\n    }\n\n    /**\n     * Search for an element by id within the document and pantry, and move it using moveBefore.\n     *\n     * @param {Element} parentNode - The parent node to which the element will be moved.\n     * @param {string} id - The ID of the element to be moved.\n     * @param {Node | null} after - The reference node to insert the element before.\n     *                              If `null`, the element is appended as the last child.\n     * @param {MorphContext} ctx\n     * @returns {Element} The found element\n     */\n    function moveBeforeById(parentNode, id, after, ctx) {\n      const target =\n        /** @type {Element} - will always be found */\n        (\n          (ctx.target.id === id && ctx.target) ||\n            ctx.target.querySelector(`[id=\"${id}\"]`) ||\n            ctx.pantry.querySelector(`[id=\"${id}\"]`)\n        );\n      removeElementFromAncestorsIdMaps(target, ctx);\n      moveBefore(parentNode, target, after);\n      return target;\n    }\n\n    /**\n     * Removes an element from its ancestors' id maps. This is needed when an element is moved from the\n     * \"future\" via `moveBeforeId`. Otherwise, its erstwhile ancestors could be mistakenly moved to the\n     * pantry rather than being deleted, preventing their removal hooks from being called.\n     *\n     * @param {Element} element - element to remove from its ancestors' id maps\n     * @param {MorphContext} ctx\n     */\n    function removeElementFromAncestorsIdMaps(element, ctx) {\n      const id = element.id;\n      /** @ts-ignore - safe to loop in this way **/\n      while ((element = element.parentNode)) {\n        let idSet = ctx.idMap.get(element);\n        if (idSet) {\n          idSet.delete(id);\n          if (!idSet.size) {\n            ctx.idMap.delete(element);\n          }\n        }\n      }\n    }\n\n    /**\n     * Moves an element before another element within the same parent.\n     * Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n     * This is essentialy a forward-compat wrapper.\n     *\n     * @param {Element} parentNode - The parent node containing the after element.\n     * @param {Node} element - The element to be moved.\n     * @param {Node | null} after - The reference node to insert `element` before.\n     *                              If `null`, `element` is appended as the last child.\n     */\n    function moveBefore(parentNode, element, after) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (parentNode.moveBefore) {\n        try {\n          // @ts-ignore - use proposed moveBefore feature\n          parentNode.moveBefore(element, after);\n        } catch (e) {\n          // fall back to insertBefore as some browsers may fail on moveBefore when trying to move Dom disconnected nodes to pantry\n          parentNode.insertBefore(element, after);\n        }\n      } else {\n        parentNode.insertBefore(element, after);\n      }\n    }\n\n    return morphChildren;\n  })();\n\n  //=============================================================================\n  // Single Node Morphing Code\n  //=============================================================================\n  const morphNode = (function () {\n    /**\n     * @param {Node} oldNode root node to merge content into\n     * @param {Node} newContent new content to merge\n     * @param {MorphContext} ctx the merge context\n     * @returns {Node | null} the element that ended up in the DOM\n     */\n    function morphNode(oldNode, newContent, ctx) {\n      if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n        return null;\n      }\n\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n        return oldNode;\n      }\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          oldNode,\n          /** @type {HTMLHeadElement} */ (newContent),\n          ctx,\n        );\n      } else {\n        morphAttributes(oldNode, newContent, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          // @ts-ignore newContent can be a node here because .firstChild will be null\n          morphChildren(ctx, oldNode, newContent);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n\n    /**\n     * syncs the oldNode to the newNode, copying over all attributes and\n     * inner element state from the newNode to the oldNode\n     *\n     * @param {Node} oldNode the node to copy attributes & state to\n     * @param {Node} newNode the node to copy attributes & state from\n     * @param {MorphContext} ctx the merge context\n     */\n    function morphAttributes(oldNode, newNode, ctx) {\n      let type = newNode.nodeType;\n\n      // if is an element type, sync the attributes from the\n      // new node into the new node\n      if (type === 1 /* element type */) {\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        const oldAttributes = oldElt.attributes;\n        const newAttributes = newElt.attributes;\n        for (const newAttribute of newAttributes) {\n          if (ignoreAttribute(newAttribute.name, oldElt, \"update\", ctx)) {\n            continue;\n          }\n          if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {\n            oldElt.setAttribute(newAttribute.name, newAttribute.value);\n          }\n        }\n        // iterate backwards to avoid skipping over items when a delete occurs\n        for (let i = oldAttributes.length - 1; 0 <= i; i--) {\n          const oldAttribute = oldAttributes[i];\n\n          // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n          // e.g. custom element attribute callbacks can remove other attributes\n          if (!oldAttribute) continue;\n\n          if (!newElt.hasAttribute(oldAttribute.name)) {\n            if (ignoreAttribute(oldAttribute.name, oldElt, \"remove\", ctx)) {\n              continue;\n            }\n            oldElt.removeAttribute(oldAttribute.name);\n          }\n        }\n\n        if (!ignoreValueOfActiveElement(oldElt, ctx)) {\n          syncInputValue(oldElt, newElt, ctx);\n        }\n      }\n\n      // sync text nodes\n      if (type === 8 /* comment */ || type === 3 /* text */) {\n        if (oldNode.nodeValue !== newNode.nodeValue) {\n          oldNode.nodeValue = newNode.nodeValue;\n        }\n      }\n    }\n\n    /**\n     * NB: many bothans died to bring us information:\n     *\n     *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n     *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n     *\n     * @param {Element} oldElement the element to sync the input value to\n     * @param {Element} newElement the element to sync the input value from\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncInputValue(oldElement, newElement, ctx) {\n      if (\n        oldElement instanceof HTMLInputElement &&\n        newElement instanceof HTMLInputElement &&\n        newElement.type !== \"file\"\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n\n        // sync boolean attributes\n        syncBooleanAttribute(oldElement, newElement, \"checked\", ctx);\n        syncBooleanAttribute(oldElement, newElement, \"disabled\", ctx);\n\n        if (!newElement.hasAttribute(\"value\")) {\n          if (!ignoreAttribute(\"value\", oldElement, \"remove\", ctx)) {\n            oldElement.value = \"\";\n            oldElement.removeAttribute(\"value\");\n          }\n        } else if (oldValue !== newValue) {\n          if (!ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n            oldElement.setAttribute(\"value\", newValue);\n            oldElement.value = newValue;\n          }\n        }\n        // TODO: QUESTION(1cg): this used to only check `newElement` unlike the other branches -- why?\n        // did I break something?\n      } else if (\n        oldElement instanceof HTMLOptionElement &&\n        newElement instanceof HTMLOptionElement\n      ) {\n        syncBooleanAttribute(oldElement, newElement, \"selected\", ctx);\n      } else if (\n        oldElement instanceof HTMLTextAreaElement &&\n        newElement instanceof HTMLTextAreaElement\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n        if (ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n          return;\n        }\n        if (newValue !== oldValue) {\n          oldElement.value = newValue;\n        }\n        if (\n          oldElement.firstChild &&\n          oldElement.firstChild.nodeValue !== newValue\n        ) {\n          oldElement.firstChild.nodeValue = newValue;\n        }\n      }\n    }\n\n    /**\n     * @param {Element} oldElement element to write the value to\n     * @param {Element} newElement element to read the value from\n     * @param {string} attributeName the attribute name\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {\n      // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n      const newLiveValue = newElement[attributeName],\n        // @ts-ignore ditto\n        oldLiveValue = oldElement[attributeName];\n      if (newLiveValue !== oldLiveValue) {\n        const ignoreUpdate = ignoreAttribute(\n          attributeName,\n          oldElement,\n          \"update\",\n          ctx,\n        );\n        if (!ignoreUpdate) {\n          // update attribute's associated DOM property\n          // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n          oldElement[attributeName] = newElement[attributeName];\n        }\n        if (newLiveValue) {\n          if (!ignoreUpdate) {\n            // https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML\n            // this is the correct way to set a boolean attribute to \"true\"\n            oldElement.setAttribute(attributeName, \"\");\n          }\n        } else {\n          if (!ignoreAttribute(attributeName, oldElement, \"remove\", ctx)) {\n            oldElement.removeAttribute(attributeName);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {string} attr the attribute to be mutated\n     * @param {Element} element the element that is going to be updated\n     * @param {\"update\" | \"remove\"} updateType\n     * @param {MorphContext} ctx the merge context\n     * @returns {boolean} true if the attribute should be ignored, false otherwise\n     */\n    function ignoreAttribute(attr, element, updateType, ctx) {\n      if (\n        attr === \"value\" &&\n        ctx.ignoreActiveValue &&\n        element === document.activeElement\n      ) {\n        return true;\n      }\n      return (\n        ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) ===\n        false\n      );\n    }\n\n    /**\n     * @param {Node} possibleActiveElement\n     * @param {MorphContext} ctx\n     * @returns {boolean}\n     */\n    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n      return (\n        !!ctx.ignoreActiveValue &&\n        possibleActiveElement === document.activeElement &&\n        possibleActiveElement !== document.body\n      );\n    }\n\n    return morphNode;\n  })();\n\n  //=============================================================================\n  // Head Management Functions\n  //=============================================================================\n  /**\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @param {function} callback\n   * @returns {Node[] | Promise<Node[]>}\n   */\n  function withHeadBlocking(ctx, oldNode, newNode, callback) {\n    if (ctx.head.block) {\n      const oldHead = oldNode.querySelector(\"head\");\n      const newHead = newNode.querySelector(\"head\");\n      if (oldHead && newHead) {\n        const promises = handleHeadElement(oldHead, newHead, ctx);\n        // when head promises resolve, proceed ignoring the head tag\n        return Promise.all(promises).then(() => {\n          const newCtx = Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          });\n          return callback(newCtx);\n        });\n      }\n    }\n    // just proceed if we not head blocking\n    return callback(ctx);\n  }\n\n  /**\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   *\n   * @param {Element} oldHead\n   * @param {Element} newHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(oldHead, newHead, ctx) {\n    let added = [];\n    let removed = [];\n    let preserved = [];\n    let nodesToAppend = [];\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHead.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of oldHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (ctx.head.style === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        oldHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        oldHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(oldHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Create Morph Context Functions\n  //=============================================================================\n  const createMorphContext = (function () {\n    /**\n     *\n     * @param {Element} oldNode\n     * @param {Element} newContent\n     * @param {Config} config\n     * @returns {MorphContext}\n     */\n    function createMorphContext(oldNode, newContent, config) {\n      const { persistentIds, idMap } = createIdMaps(oldNode, newContent);\n\n      const mergedConfig = mergeDefaults(config);\n      const morphStyle = mergedConfig.morphStyle || \"outerHTML\";\n      if (![\"innerHTML\", \"outerHTML\"].includes(morphStyle)) {\n        throw `Do not understand how to morph style ${morphStyle}`;\n      }\n\n      return {\n        target: oldNode,\n        newContent: newContent,\n        config: mergedConfig,\n        morphStyle: morphStyle,\n        ignoreActive: mergedConfig.ignoreActive,\n        ignoreActiveValue: mergedConfig.ignoreActiveValue,\n        restoreFocus: mergedConfig.restoreFocus,\n        idMap: idMap,\n        persistentIds: persistentIds,\n        pantry: createPantry(),\n        callbacks: mergedConfig.callbacks,\n        head: mergedConfig.head,\n      };\n    }\n\n    /**\n     * Deep merges the config object and the Idiomorph.defaults object to\n     * produce a final configuration object\n     * @param {Config} config\n     * @returns {ConfigInternal}\n     */\n    function mergeDefaults(config) {\n      let finalConfig = Object.assign({}, defaults);\n\n      // copy top level stuff into final config\n      Object.assign(finalConfig, config);\n\n      // copy callbacks into final config (do this to deep merge the callbacks)\n      finalConfig.callbacks = Object.assign(\n        {},\n        defaults.callbacks,\n        config.callbacks,\n      );\n\n      // copy head config into final config  (do this to deep merge the head)\n      finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n      return finalConfig;\n    }\n\n    /**\n     * @returns {HTMLDivElement}\n     */\n    function createPantry() {\n      const pantry = document.createElement(\"div\");\n      pantry.hidden = true;\n      document.body.insertAdjacentElement(\"afterend\", pantry);\n      return pantry;\n    }\n\n    /**\n     * Returns all elements with an ID contained within the root element and its descendants\n     *\n     * @param {Element} root\n     * @returns {Element[]}\n     */\n    function findIdElements(root) {\n      let elements = Array.from(root.querySelectorAll(\"[id]\"));\n      if (root.id) {\n        elements.push(root);\n      }\n      return elements;\n    }\n\n    /**\n     * A bottom-up algorithm that populates a map of Element -> IdSet.\n     * The idSet for a given element is the set of all IDs contained within its subtree.\n     * As an optimzation, we filter these IDs through the given list of persistent IDs,\n     * because we don't need to bother considering IDed elements that won't be in the new content.\n     *\n     * @param {Map<Node, Set<string>>} idMap\n     * @param {Set<string>} persistentIds\n     * @param {Element} root\n     * @param {Element[]} elements\n     */\n    function populateIdMapWithTree(idMap, persistentIds, root, elements) {\n      for (const elt of elements) {\n        if (persistentIds.has(elt.id)) {\n          /** @type {Element|null} */\n          let current = elt;\n          // walk up the parent hierarchy of that element, adding the id\n          // of element to the parent's id set\n          while (current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the map\n            if (idSet == null) {\n              idSet = new Set();\n              idMap.set(current, idSet);\n            }\n            idSet.add(elt.id);\n\n            if (current === root) break;\n            current = current.parentElement;\n          }\n        }\n      }\n    }\n\n    /**\n     * This function computes a map of nodes to all ids contained within that node (inclusive of the\n     * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n     * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n     * to contribute to a parent nodes matching.\n     *\n     * @param {Element} oldContent  the old content that will be morphed\n     * @param {Element} newContent  the new content to morph to\n     * @returns {IdSets}\n     */\n    function createIdMaps(oldContent, newContent) {\n      const oldIdElements = findIdElements(oldContent);\n      const newIdElements = findIdElements(newContent);\n\n      const persistentIds = createPersistentIds(oldIdElements, newIdElements);\n\n      /** @type {Map<Node, Set<string>>} */\n      let idMap = new Map();\n      populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);\n\n      /** @ts-ignore - if newContent is a duck-typed parent, pass its single child node as the root to halt upwards iteration */\n      const newRoot = newContent.__idiomorphRoot || newContent;\n      populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);\n\n      return { persistentIds, idMap };\n    }\n\n    /**\n     * This function computes the set of ids that persist between the two contents excluding duplicates\n     *\n     * @param {Element[]} oldIdElements\n     * @param {Element[]} newIdElements\n     * @returns {Set<string>}\n     */\n    function createPersistentIds(oldIdElements, newIdElements) {\n      let duplicateIds = new Set();\n\n      /** @type {Map<string, string>} */\n      let oldIdTagNameMap = new Map();\n      for (const { id, tagName } of oldIdElements) {\n        if (oldIdTagNameMap.has(id)) {\n          duplicateIds.add(id);\n        } else {\n          oldIdTagNameMap.set(id, tagName);\n        }\n      }\n\n      let persistentIds = new Set();\n      for (const { id, tagName } of newIdElements) {\n        if (persistentIds.has(id)) {\n          duplicateIds.add(id);\n        } else if (oldIdTagNameMap.get(id) === tagName) {\n          persistentIds.add(id);\n        }\n        // skip if tag types mismatch because its not possible to morph one tag into another\n      }\n\n      for (const id of duplicateIds) {\n        persistentIds.delete(id);\n      }\n      return persistentIds;\n    }\n\n    return createMorphContext;\n  })();\n\n  //=============================================================================\n  // HTML Normalization Functions\n  //=============================================================================\n  const { normalizeElement, normalizeParent } = (function () {\n    /** @type {WeakSet<Node>} */\n    const generatedByIdiomorph = new WeakSet();\n\n    /**\n     *\n     * @param {Element | Document} content\n     * @returns {Element}\n     */\n    function normalizeElement(content) {\n      if (content instanceof Document) {\n        return content.documentElement;\n      } else {\n        return content;\n      }\n    }\n\n    /**\n     *\n     * @param {null | string | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n     * @returns {Element}\n     */\n    function normalizeParent(newContent) {\n      if (newContent == null) {\n        return document.createElement(\"div\"); // dummy parent element\n      } else if (typeof newContent === \"string\") {\n        return normalizeParent(parseContent(newContent));\n      } else if (\n        generatedByIdiomorph.has(/** @type {Element} */ (newContent))\n      ) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return /** @type {Element} */ (newContent);\n      } else if (newContent instanceof Node) {\n        if (newContent.parentNode) {\n          // we can't use the parent directly because newContent may have siblings\n          // that we don't want in the morph, and reparenting might be expensive (TODO is it?),\n          // so instead we create a fake parent node that only sees a slice of its children.\n          /** @type {Element} */\n          return /** @type {any} */ (new SlicedParentNode(newContent));\n        } else {\n          // a single node is added as a child to a dummy parent\n          const dummyParent = document.createElement(\"div\");\n          dummyParent.append(newContent);\n          return dummyParent;\n        }\n      } else {\n        // all nodes in the array or HTMLElement collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n          dummyParent.append(elt);\n        }\n        return dummyParent;\n      }\n    }\n\n    /**\n     * A fake duck-typed parent element to wrap a single node, without actually reparenting it.\n     * This is useful because the node may have siblings that we don't want in the morph, and it may also be moved\n     * or replaced with one or more elements during the morph. This class effectively allows us a window into\n     * a slice of a node's children.\n     * \"If it walks like a duck, and quacks like a duck, then it must be a duck!\" -- James Whitcomb Riley (1849\u20131916)\n     */\n    class SlicedParentNode {\n      /** @param {Node} node */\n      constructor(node) {\n        this.originalNode = node;\n        this.realParentNode = /** @type {Element} */ (node.parentNode);\n        this.previousSibling = node.previousSibling;\n        this.nextSibling = node.nextSibling;\n      }\n\n      /** @returns {Node[]} */\n      get childNodes() {\n        // return slice of realParent's current childNodes, based on previousSibling and nextSibling\n        const nodes = [];\n        let cursor = this.previousSibling\n          ? this.previousSibling.nextSibling\n          : this.realParentNode.firstChild;\n        while (cursor && cursor != this.nextSibling) {\n          nodes.push(cursor);\n          cursor = cursor.nextSibling;\n        }\n        return nodes;\n      }\n\n      /**\n       * @param {string} selector\n       * @returns {Element[]}\n       */\n      querySelectorAll(selector) {\n        return this.childNodes.reduce((results, node) => {\n          if (node instanceof Element) {\n            if (node.matches(selector)) results.push(node);\n            const nodeList = node.querySelectorAll(selector);\n            for (let i = 0; i < nodeList.length; i++) {\n              results.push(nodeList[i]);\n            }\n          }\n          return results;\n        }, /** @type {Element[]} */ ([]));\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      insertBefore(node, referenceNode) {\n        return this.realParentNode.insertBefore(node, referenceNode);\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      moveBefore(node, referenceNode) {\n        // @ts-ignore - use new moveBefore feature\n        return this.realParentNode.moveBefore(node, referenceNode);\n      }\n\n      /**\n       * for later use with populateIdMapWithTree to halt upwards iteration\n       * @returns {Node}\n       */\n      get __idiomorphRoot() {\n        return this.originalNode;\n      }\n    }\n\n    /**\n     *\n     * @param {string} newContent\n     * @returns {Node | null | DocumentFragment}\n     */\n    function parseContent(newContent) {\n      let parser = new DOMParser();\n\n      // remove svgs to avoid false-positive matches on head, etc.\n      let contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n      );\n\n      // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n      if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n      ) {\n        let content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n          generatedByIdiomorph.add(content);\n          return content;\n        } else {\n          // otherwise return the html element as the parent container\n          let htmlElement = content.firstChild;\n          if (htmlElement) {\n            generatedByIdiomorph.add(htmlElement);\n          }\n          return htmlElement;\n        }\n      } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        let responseDoc = parser.parseFromString(\n          \"<body><template>\" + newContent + \"</template></body>\",\n          \"text/html\",\n        );\n        let content = /** @type {HTMLTemplateElement} */ (\n          responseDoc.body.querySelector(\"template\")\n        ).content;\n        generatedByIdiomorph.add(content);\n        return content;\n      }\n    }\n\n    return { normalizeElement, normalizeParent };\n  })();\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n\nexport {Idiomorph};\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:sim-card-download-outline\n// Slug: Merge fragments into the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultFragmentMergeMode,\n  DefaultFragmentsUseViewTransitions,\n  EventTypes,\n  FragmentMergeModes,\n} from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport {\n  type HTMLorSVGElement,\n  type InitContext,\n  PluginType,\n  type WatcherPlugin,\n} from '../../../../engine/types'\nimport { attrHash, elUniqId, walkDOM } from '../../../../utils/dom'\nimport { isBoolString } from '../../../../utils/text'\nimport {\n  docWithViewTransitionAPI,\n  supportsViewTransitions,\n} from '../../../../utils/view-transtions'\nimport { Idiomorph } from '../../../../vendored/idiomorph.esm'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const MergeFragments: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.MergeFragments,\n  onGlobalInit: async (ctx) => {\n    const fragmentContainer = document.createElement('template')\n    datastarSSEEventWatcher(\n      EventTypes.MergeFragments,\n      ({\n        fragments: fragmentsRaw = '<div></div>',\n        selector = '',\n        mergeMode = DefaultFragmentMergeMode,\n        useViewTransition:\n          useViewTransitionRaw = `${DefaultFragmentsUseViewTransitions}`,\n      }) => {\n        const useViewTransition = isBoolString(useViewTransitionRaw)\n\n        fragmentContainer.innerHTML = fragmentsRaw.trim()\n        const fragments = [...fragmentContainer.content.children]\n        for (const fragment of fragments) {\n          if (!(fragment instanceof Element)) {\n            throw initErr('NoFragmentsFound', ctx)\n          }\n\n          const selectorOrID = selector || `#${fragment.getAttribute('id')}`\n          const targets = [...(document.querySelectorAll(selectorOrID) || [])]\n          if (!targets.length) {\n            throw initErr('NoTargetsFound', ctx, { selectorOrID })\n          }\n\n          if (useViewTransition && supportsViewTransitions) {\n            docWithViewTransitionAPI.startViewTransition(() =>\n              applyToTargets(ctx, mergeMode, fragment, targets),\n            )\n          } else {\n            applyToTargets(ctx, mergeMode, fragment, targets)\n          }\n        }\n      },\n    )\n  },\n}\n\nfunction applyToTargets(\n  ctx: InitContext,\n  mergeMode: string,\n  fragment: Element,\n  capturedTargets: Element[],\n) {\n  for (const target of capturedTargets) {\n    // Mark the target as a fragment merge target to force plugins to clean up and reapply\n    (target as HTMLElement).dataset.fragmentMergeTarget = 'true'\n\n    // Clone the fragment to merge to avoid modifying the original and force browsers to merge the fragment into the DOM\n    const fragmentToMerge = fragment.cloneNode(true) as HTMLorSVGElement\n\n    switch (mergeMode) {\n      case FragmentMergeModes.Morph: {\n        walkDOM(fragmentToMerge, (el) => {\n          if (!el.id?.length && Object.keys(el.dataset).length) {\n            el.id = elUniqId(el)\n          }\n          // Rehash the cleanup functions for this element to ensure that plugins are cleaned up and reapplied after merging.\n          const elTracking = ctx.removals.get(el.id)\n          if (elTracking) {\n            const newElTracking = new Map()\n            for (const [key, cleanup] of elTracking) {\n              const newKey = attrHash(key, key)\n              newElTracking.set(newKey, cleanup)\n              elTracking.delete(key)\n            }\n            ctx.removals.set(el.id, newElTracking)\n          }\n        })\n\n        Idiomorph.morph(target, fragmentToMerge)\n        break\n      }\n      case FragmentMergeModes.Inner:\n        // Replace the contents of the target element with the outer HTML of the response\n        target.innerHTML = fragmentToMerge.outerHTML\n        break\n      case FragmentMergeModes.Outer:\n        // Replace the entire target element with the response\n        target.replaceWith(fragmentToMerge)\n        break\n      case FragmentMergeModes.Prepend:\n        // Insert the response before the first child of the target element\n        target.prepend(fragmentToMerge)\n        break\n      case FragmentMergeModes.Append:\n        // Insert the response after the last child of the target element\n        target.append(fragmentToMerge)\n        break\n      case FragmentMergeModes.Before:\n        // Insert the response before the target element\n        target.before(fragmentToMerge)\n        break\n      case FragmentMergeModes.After:\n        // Insert the response after the target element\n        target.after(fragmentToMerge)\n        break\n      case FragmentMergeModes.UpsertAttributes:\n        // Upsert the attributes of the target element\n        for (const attrName of fragmentToMerge.getAttributeNames()) {\n          const value = fragmentToMerge.getAttribute(attrName)!\n          target.setAttribute(attrName, value)\n        }\n        break\n      default:\n        throw initErr('InvalidMergeMode', ctx, { mergeMode })\n    }\n  }\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:download-for-offline-outline\n// Slug: Merge signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultMergeSignalsOnlyIfMissing,\n  EventTypes,\n} from '../../../../engine/consts'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString, jsStrToObject } from '../../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const MergeSignals: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.MergeSignals,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.MergeSignals,\n      ({\n        signals: raw = '{}',\n        onlyIfMissing: onlyIfMissingRaw = `${DefaultMergeSignalsOnlyIfMissing}`,\n      }) => {\n        const { signals } = ctx\n        const onlyIfMissing = isBoolString(onlyIfMissingRaw)\n        signals.merge(jsStrToObject(raw), onlyIfMissing)\n      },\n    )\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:scan-delete-outline\n// Slug: Remove fragments from the DOM using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport {\n  DefaultFragmentsUseViewTransitions,\n  EventTypes,\n} from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { isBoolString } from '../../../../utils/text'\nimport {\n  docWithViewTransitionAPI,\n  supportsViewTransitions,\n} from '../../../../utils/view-transtions'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const RemoveFragments: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.RemoveFragments,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.RemoveFragments,\n      ({\n        selector,\n        useViewTransition:\n          useViewTransitionRaw = `${DefaultFragmentsUseViewTransitions}`,\n      }) => {\n        if (!selector.length) {\n          throw initErr('NoSelectorProvided', ctx)\n        }\n\n        const useViewTransition = isBoolString(useViewTransitionRaw)\n        const removeTargets = document.querySelectorAll(selector)\n\n        const applyToTargets = () => {\n          for (const target of removeTargets) {\n            target.remove()\n          }\n        }\n\n        if (useViewTransition && supportsViewTransitions) {\n          docWithViewTransitionAPI.startViewTransition(() => applyToTargets())\n        } else {\n          applyToTargets()\n        }\n      },\n    )\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:variable-remove-outline\n// Slug: Remove signals using a Server-Sent Event\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { EventTypes } from '../../../../engine/consts'\nimport { initErr } from '../../../../engine/errors'\nimport { PluginType, type WatcherPlugin } from '../../../../engine/types'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const RemoveSignals: WatcherPlugin = {\n  type: PluginType.Watcher,\n  name: EventTypes.RemoveSignals,\n  onGlobalInit: async (ctx) => {\n    datastarSSEEventWatcher(\n      EventTypes.RemoveSignals,\n      ({ paths: pathsRaw = '' }) => {\n        const paths = pathsRaw.split('\\n').map((p) => p.trim())\n        if (!paths?.length) {\n          throw initErr('NoPathsProvided', ctx)\n        }\n        ctx.signals.remove(...paths)\n      },\n    )\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi:clipboard\n// Slug: Copy text to the clipboard\n// Description: This action copies text to the clipboard using the Clipboard API.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport { type ActionPlugin, PluginType } from '../../../../engine/types'\n\nexport const Clipboard: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'clipboard',\n  fn: (ctx, text) => {\n    if (!navigator.clipboard) {\n      throw runtimeErr('ClipboardNotAvailable', ctx)\n    }\n    navigator.clipboard.writeText(text)\n  },\n}\n", "// Authors: Ben Croker\n// Icon: mdi-message-alert\n// Slug: Add custom validity to an element using an expression\n// Description: This plugin allows you to add custom validity to an element using an expression. The expression should evaluate to a string that will be set as the custom validity message. This can be used to provide custom error messages for form validation.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const CustomValidity: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'customValidity',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: (ctx) => {\n    const { el, genRX, effect } = ctx\n    if (!(el instanceof HTMLInputElement || el instanceof HTMLSelectElement || el instanceof HTMLTextAreaElement)) {\n      throw runtimeErr('CustomValidityInvalidElement', ctx)\n    }\n    const rx = genRX()\n    return effect(() => {\n      const result = rx<string>()\n      if (typeof result !== 'string') {\n        throw runtimeErr('CustomValidityInvalidExpression', ctx, { result })\n      }\n      el.setCustomValidity(result)\n    })\n  },\n}\n", "export function tagToMs(args: Set<string>) {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return Number(arg.replace('ms', ''))\n    }\n    if (arg.endsWith('s')) {\n      return Number(arg.replace('s', '')) * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (e) {}\n  }\n  return 0\n}\n\nexport function tagHas(tags: Set<string>, tag: string, defaultValue = false) {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n", "import type { EventCallbackHandler, Modifiers } from '../engine/types'\nimport { tagHas, tagToMs } from './tags'\n\nexport function debounce(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): EventCallbackHandler {\n  let timer = -1\n\n  const resetTimer = () => timer && clearTimeout(timer)\n\n  return (...args: any[]) => {\n    resetTimer()\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      resetTimer()\n    }, wait)\n  }\n}\n\nexport function throttle(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): EventCallbackHandler {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      waiting = false\n      if (trailing) {\n        callback(...args)\n      }\n    }, wait)\n  }\n}\n\nexport function modifyTiming(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  const debounceArgs = mods.get('debounce')\n  if (debounceArgs) {\n    const wait = tagToMs(debounceArgs)\n    const leading = tagHas(debounceArgs, 'leading', false)\n    const trailing = !tagHas(debounceArgs, 'notrail', false)\n    callback = debounce(callback, wait, leading, trailing)\n  }\n\n  const throttleArgs = mods.get('throttle')\n  if (throttleArgs) {\n    const wait = tagToMs(throttleArgs)\n    const leading = !tagHas(throttleArgs, 'noleading', false)\n    const trailing = tagHas(throttleArgs, 'trail', false)\n    callback = throttle(callback, wait, leading, trailing)\n  }\n\n  return callback\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi-light:vector-intersection\n// Slug: Executes an expression when an element intersects with the viewport\n// Description: An attribute that executes an expression when an element intersects with the viewport.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyTiming } from '../../../../utils/timing'\nimport { modifyViewTransition } from '../../../../utils/view-transtions'\n\nexport const OnIntersect: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'onIntersect',\n  keyReq: Requirement.Denied,\n  onLoad: ({ el, rawKey, mods, genRX }) => {\n    let callback = modifyTiming(genRX(), mods)\n    callback = modifyViewTransition(callback, mods)\n\n    const options = { threshold: 0 }\n    if (mods.has('full')) {\n      options.threshold = 1\n    } else if (mods.has('half')) {\n      options.threshold = 0.5\n    }\n\n    const observer = new IntersectionObserver((entries) => {\n      for (const entry of entries) {\n        if (entry.isIntersecting) {\n          callback()\n\n          if (mods.has('once')) {\n            observer.disconnect()\n            delete el.dataset[rawKey]\n          }\n        }\n      }\n    }, options)\n    \n    observer.observe(el)\n\n    return () => observer.disconnect()\n  },\n}\n", "// Authors: Ben Croker\n// Icon: material-symbols:timer-outline\n// Slug: Runs an expression on an interval\n// Description: This attribute runs an expression on an interval. The interval can be set to a specific duration, and can be set to trigger immediately.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { tagHas, tagToMs } from '../../../../utils/tags'\nimport { modifyViewTransition } from '../../../../utils/view-transtions'\n\nexport const OnInterval: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'onInterval',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: ({ mods, genRX }) => {\n    const callback = modifyViewTransition(genRX(), mods)\n\n    let duration = 1000\n    const durationArgs = mods.get('duration')\n    if (durationArgs) {\n      duration = tagToMs(durationArgs)\n      const leading = tagHas(durationArgs, 'leading', false)\n      if (leading) {\n        callback()\n      }\n    }\n\n    const intervalId = setInterval(callback, duration)\n\n    return () => {\n      clearInterval(intervalId)\n    }\n  },\n}\n", "// Authors: Ben Croker\n// Icon: material-symbols:timer-play-outline\n// Slug: Runs an expression when the element is loaded\n// Description: This attribute runs an expression when the element is loaded.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { tagToMs } from '../../../../utils/tags'\nimport { modifyViewTransition } from '../../../../utils/view-transtions'\n\nexport const OnLoad: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'onLoad',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: ({ mods, genRX }) => {\n    const callback = modifyViewTransition(genRX(), mods)\n\n    let wait = 0\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      wait = tagToMs(delayArgs)\n    }\n\n    setTimeout(callback, wait)\n\n    return () => {}\n  },\n}\n", "// Authors: Ben Croker\n// Icon: material-symbols:animated-images-outline\n// Slug: Runs an expression on every animation frame\n// Description: This attribute runs an expression on every animation frame.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyTiming } from '../../../../utils/timing'\nimport { modifyViewTransition } from '../../../../utils/view-transtions'\n\nexport const OnRaf: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'onRaf',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: ({ mods, genRX }) => {\n    let callback = modifyTiming(genRX(), mods)\n    callback = modifyViewTransition(callback, mods)\n\n    let rafId: number | undefined\n    const raf = () => {\n      callback()\n      rafId = requestAnimationFrame(raf)\n    }\n    rafId = requestAnimationFrame(raf)\n\n    return () => {\n      if (rafId) {\n        cancelAnimationFrame(rafId)\n      }\n    }\n  },\n}\n", "import { DSS } from '../engine/consts'\nimport type { SignalsRoot } from '../engine/signals'\nimport { trimDollarSignPrefix } from './text'\n\nexport function pathMatchesPattern(path: string, pattern: string) {\n  // Do a little dance to correctly replace the double astersik\n  pattern = pattern\n    .replaceAll('.', '\\\\.')\n    .replaceAll('**', DSS)\n    .replaceAll('*', '[^\\\\.]*')\n    .replaceAll(DSS, '.*')\n  const regex = new RegExp(`^${pattern}$`)\n\n  return regex.test(path)\n}\n\nexport function getMatchingSignalPaths(signals: SignalsRoot, paths: string) {\n  const matches: string[] = []\n  let patterns = paths.split(/\\s+/).filter((p) => p !== '')\n  patterns = patterns.map((p) => trimDollarSignPrefix(p))\n\n  for (const pattern of patterns) {\n    signals.walk((signalPath) => {\n      if (pathMatchesPattern(signalPath, pattern)) {\n        matches.push(signalPath)\n      }\n    })\n  }\n\n  return matches\n}", "// Authors: Ben Croker\n// Icon: material-symbols:bigtop-updates\n// Slug: Runs an expression whenever a signal changes\n// Description: This attribute runs an expression whenever a signal changes. \n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_EVENT,\n  type DatastarSignalEvent,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { pathMatchesPattern } from '../../../../utils/paths'\nimport { modifyCasing } from '../../../../utils/text'\nimport { modifyTiming } from '../../../../utils/timing'\nimport { modifyViewTransition } from '../../../../utils/view-transtions'\nimport { effect, type Signal } from '../../../../vendored/preact-core'\n\nexport const OnSignalChange: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'onSignalChange',\n  valReq: Requirement.Must,\n  onLoad: ({ key, mods, signals, genRX }) => {\n    let callback = modifyTiming(genRX(), mods)\n    callback = modifyViewTransition(callback, mods)\n\n    if (key === '') {\n      const signalFn = (event: CustomEvent<DatastarSignalEvent>) =>\n        callback(event)\n      document.addEventListener(DATASTAR_SIGNAL_EVENT, signalFn)\n\n      return () => {\n        document.removeEventListener(DATASTAR_SIGNAL_EVENT, signalFn)\n      }\n    }\n\n    const pattern = modifyCasing(key, mods)\n    const signalValues = new Map<Signal, any>()\n    signals.walk((path, signal) => {\n      if (pathMatchesPattern(path, pattern)) {\n        signalValues.set(signal, signal.value)\n      }\n    })\n\n    return effect(() => {\n      for (const [signal, prev] of signalValues) {\n        if (prev !== signal.value) {\n          callback()\n          signalValues.set(signal, signal.value)\n        }\n      }\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi:floppy-variant\n// Slug: Persist data to local storage or session storage\n// Description: This plugin allows you to persist data to local storage or session storage.  Once you add this attribute the data will be persisted to local storage or session storage.\n\nimport { DATASTAR } from '../../../../engine/consts'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { getMatchingSignalPaths } from '../../../../utils/paths'\n\nexport const Persist: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'persist',\n  keyReq: Requirement.Denied,\n  onLoad: ({ effect, mods, signals, value }) => {\n    const key = DATASTAR\n    const storage = mods.has('session') ? sessionStorage : localStorage\n    \n    // If the value is empty, persist all signals\n    const paths = value !== '' ? value : '**'\n\n    const storageToSignals = () => {\n      const data = storage.getItem(key) || '{}'\n      const nestedValues = JSON.parse(data)\n      signals.merge(nestedValues)\n    }\n\n    const signalsToStorage = () => {\n      const signalPaths = getMatchingSignalPaths(signals, paths)\n      const nv = signals.subset(...signalPaths)\n      storage.setItem(key, JSON.stringify(nv))\n    }\n\n    storageToSignals()\n    return effect(() => {\n      signalsToStorage()\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: carbon:url\n// Slug: Replace the current URL with a new URL\n// Description: This plugin allows you to replace the current URL with a new URL.  Once you add this attribute the current URL will be replaced with the new URL.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const ReplaceUrl: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'replaceUrl',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: ({ effect, genRX }) => {\n    const rx = genRX()\n    return effect(() => {\n      const url = rx<string>()\n      const baseUrl = window.location.href\n      const fullUrl = new URL(url, baseUrl).toString()\n      window.history.replaceState({}, '', fullUrl)\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: hugeicons:mouse-scroll-01\n// Slug: Scroll an element into view\n// Description: This attribute scrolls the element into view.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nconst SMOOTH = 'smooth'\nconst INSTANT = 'instant'\nconst AUTO = 'auto'\nconst HSTART = 'hstart'\nconst HCENTER = 'hcenter'\nconst HEND = 'hend'\nconst HNEAREST = 'hnearest'\nconst VSTART = 'vstart'\nconst VCENTER = 'vcenter'\nconst VEND = 'vend'\nconst VNEAREST = 'vnearest'\nconst CENTER = 'center'\nconst START = 'start'\nconst END = 'end'\nconst NEAREST = 'nearest'\nconst FOCUS = 'focus'\n\n// Scrolls the element into view\nexport const ScrollIntoView: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'scrollIntoView',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Denied,\n  onLoad: (ctx) => {\n    const { el, mods, rawKey } = ctx\n    if (!el.tabIndex) el.setAttribute('tabindex', '0')\n    const opts: ScrollIntoViewOptions = {\n      behavior: SMOOTH,\n      block: CENTER,\n      inline: CENTER,\n    }\n    if (mods.has(SMOOTH)) opts.behavior = SMOOTH\n    if (mods.has(INSTANT)) opts.behavior = INSTANT\n    if (mods.has(AUTO)) opts.behavior = AUTO\n    if (mods.has(HSTART)) opts.inline = START\n    if (mods.has(HCENTER)) opts.inline = CENTER\n    if (mods.has(HEND)) opts.inline = END\n    if (mods.has(HNEAREST)) opts.inline = NEAREST\n    if (mods.has(VSTART)) opts.block = START\n    if (mods.has(VCENTER)) opts.block = CENTER\n    if (mods.has(VEND)) opts.block = END\n    if (mods.has(VNEAREST)) opts.block = NEAREST\n\n    if (!(el instanceof HTMLElement || el instanceof SVGElement)) {\n      throw runtimeErr('ScrollIntoViewInvalidElement', ctx)\n    }\n    if (!el.tabIndex) {\n      el.setAttribute('tabindex', '0')\n    }\n\n    el.scrollIntoView(opts)\n    if (mods.has(FOCUS)) {\n      el.focus()\n    }\n\n    delete el.dataset[rawKey]\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:masked-transitions\n// Slug: Setup view transitions\n// Description: This attribute plugin sets up view transitions for the current view. This plugin requires the view transition API to be enabled in the browser. If the browser does not support view transitions, an error will be logged to the console.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { supportsViewTransitions } from '../../../../utils/view-transtions'\n\nconst VIEW_TRANSITION = 'view-transition'\n\nexport const ViewTransition: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'viewTransition',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onGlobalInit() {\n    let hasViewTransitionMeta = false\n    for (const node of document.head.childNodes) {\n      if (node instanceof HTMLMetaElement && node.name === VIEW_TRANSITION) {\n        hasViewTransitionMeta = true\n      }\n    }\n\n    if (!hasViewTransitionMeta) {\n      const meta = document.createElement('meta')\n      meta.name = VIEW_TRANSITION\n      meta.content = 'same-origin'\n      document.head.appendChild(meta)\n    }\n  },\n  onLoad: ({ effect, el, genRX }) => {\n    if (!supportsViewTransitions) {\n      console.error('Browser does not support view transitions')\n      return\n    }\n    const rx = genRX()\n    return effect(() => {\n      const name = rx<string>()\n      if (!name?.length) return\n      const elVTASTyle = el.style as unknown as CSSStyleDeclaration\n      elVTASTyle.viewTransitionName = name\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:edit-attributes-outline\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport {\n  type AttributePlugin,\n  type NestedValues,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { kebab } from '../../../../utils/text'\n\nexport const Attr: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'attr',\n  valReq: Requirement.Must,\n  onLoad: ({ el, key, effect, genRX }) => {\n    const rx = genRX()\n    if (key === '') {\n      return effect(async () => {\n        const binds = rx<NestedValues>()\n        for (const [key, val] of Object.entries(binds)) {\n          if (val === false) {\n            el.removeAttribute(key)\n          } else {\n            el.setAttribute(key, val)\n          }\n        }\n      })\n    }\n\n    // Attributes are always kebab-case\n    key = kebab(key)\n\n    return effect(async () => {\n      let value = false\n      try {\n        value = rx()\n      } catch (e) {} //\n      let v: string\n      if (typeof value === 'string') {\n        v = value\n      } else {\n        v = JSON.stringify(value)\n      }\n      if (!v || v === 'false' || v === 'null' || v === 'undefined') {\n        el.removeAttribute(key)\n      } else {\n        el.setAttribute(key, v)\n      }\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing, trimDollarSignPrefix } from '../../../../utils/text'\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst updateEvents = ['change', 'input', 'keydown']\n\nexport const Bind: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'bind',\n  keyReq: Requirement.Exclusive,\n  valReq: Requirement.Exclusive,\n  onLoad: (ctx) => {\n    const { el, key, mods, signals, value, effect } = ctx\n    const input = el as HTMLInputElement\n    const signalName = key\n      ? modifyCasing(key, mods)\n      : trimDollarSignPrefix(value)\n      \n    const tnl = el.tagName.toLowerCase()\n    const isInput = tnl.includes('input')\n    const isSelect = tnl.includes('select')\n    const type = el.getAttribute('type')\n    const hasValueAttribute = el.hasAttribute('value')\n\n    let signalDefault: string | boolean | number | File = ''\n    const isCheckbox = isInput && type === 'checkbox'\n    if (isCheckbox) {\n      signalDefault = hasValueAttribute ? '' : false\n    }\n    const isNumber = isInput && type === 'number'\n    if (isNumber) {\n      signalDefault = 0\n    }\n    const isRadio = isInput && type === 'radio'\n    if (isRadio) {\n      const name = el.getAttribute('name')\n      if (!name?.length) {\n        el.setAttribute('name', signalName)\n      }\n    }\n    // Can't set a default value for a file input, yet\n    const isFile = isInput && type === 'file'\n\n    const { signal, inserted } = signals.upsertIfMissing(\n      signalName,\n      signalDefault,\n    )\n\n    let arrayIndex = -1\n    if (Array.isArray(signal.value)) {\n      if (el.getAttribute('name') === null) {\n        el.setAttribute('name', signalName)\n      }\n      arrayIndex = [\n        ...document.querySelectorAll(`[name=\"${signalName}\"]`),\n      ].findIndex((el) => el === ctx.el)\n    }\n    const isArray = arrayIndex >= 0\n\n    const signalArray = () => [...(signals.value(signalName) as any[])]\n\n    const setElementFromSignal = () => {\n      let value = signals.value(signalName)\n      if (isArray && !isSelect) {\n        // May be undefined if the array is shorter than the index\n        value = (value as any)[arrayIndex] || signalDefault\n      }\n      const stringValue = `${value}`\n      if (isCheckbox || isRadio) {\n        if (typeof value === 'boolean') {\n          input.checked = value\n        } else {\n          input.checked = stringValue === input.value\n        }\n      } else if (isSelect) {\n        const select = el as HTMLSelectElement\n        if (select.multiple) {\n          if (!isArray) {\n            throw runtimeErr('BindSelectMultiple', ctx)\n          }\n          for (const opt of select.options) {\n            if (opt?.disabled) return\n            const incoming = isNumber ? Number(opt.value) : opt.value\n            opt.selected = (value as any[]).includes(incoming)\n          }\n        } else {\n          select.value = stringValue\n        }\n      } else if (isFile) {\n        // File input reading from a signal is not supported\n      } else if ('value' in el) {\n        el.value = stringValue\n      } else {\n        el.setAttribute('value', stringValue)\n      }\n    }\n\n    const setSignalFromElement = async () => {\n      let currentValue = signals.value(signalName)\n      if (isArray) {\n        // Push as many default signal values onto the array as necessary to reach the index\n        const currentArray = currentValue as any[]\n        while (arrayIndex >= currentArray.length) {\n          currentArray.push(signalDefault)\n        }\n        currentValue = currentArray[arrayIndex] || signalDefault\n      }\n\n      const update = (signalName: string, value: any) => {\n        let newValue = value\n        if (isArray && !isSelect) {\n          newValue = signalArray()\n          newValue[arrayIndex] = value\n        }\n        signals.setValue(signalName, newValue)\n      }\n\n      // Files are a special flower\n      if (isFile) {\n        const files = [...(input?.files || [])]\n        const allContents: string[] = []\n        const allMimes: string[] = []\n        const allNames: string[] = []\n\n        await Promise.all(\n          files.map((f) => {\n            return new Promise<void>((resolve) => {\n              const reader = new FileReader()\n              reader.onload = () => {\n                if (typeof reader.result !== 'string') {\n                  throw runtimeErr('InvalidFileResultType', ctx, {\n                    resultType: typeof reader.result,\n                  })\n                }\n                const match = reader.result.match(dataURIRegex)\n                if (!match?.groups) {\n                  throw runtimeErr('InvalidDataUri', ctx, {\n                    result: reader.result,\n                  })\n                }\n                allContents.push(match.groups.contents)\n                allMimes.push(match.groups.mime)\n                allNames.push(f.name)\n              }\n              reader.onloadend = () => resolve(void 0)\n              reader.readAsDataURL(f)\n            })\n          }),\n        )\n        update(signalName, allContents)\n        update(`${signalName}Mimes`, allMimes)\n        update(`${signalName}Names`, allNames)\n        return\n      }\n\n      const value = input.value || ''\n      let newValue: any\n\n      if (isCheckbox) {\n        const checked =\n          input.checked || input.getAttribute('checked') === 'true'\n\n        // We must check for an attribute value because a checked value defaults to `on`.\n        if (hasValueAttribute) {\n          newValue = checked ? value : ''\n        } else {\n          newValue = checked\n        }\n      } else if (isSelect) {\n        const select = el as HTMLSelectElement\n        const selectedOptions = [...select.selectedOptions]\n        if (isArray) {\n          newValue = selectedOptions\n            .filter((opt) => opt.selected)\n            .map((opt) => opt.value)\n        } else {\n          newValue = selectedOptions[0]?.value || signalDefault\n        }\n      } else if (typeof currentValue === 'boolean') {\n        newValue = Boolean(value)\n      } else if (typeof currentValue === 'number') {\n        newValue = Number(value)\n      } else {\n        newValue = value || ''\n      }\n\n      update(signalName, newValue)\n    }\n\n    // If the signal was inserted, attempt to set the the signal value from the element.\n    if (inserted) {\n      setSignalFromElement()\n    }\n\n    for (const event of updateEvents) {\n      el.addEventListener(event, setSignalFromElement)\n    }\n\n    /*\n     * The signal value needs to be updated after the \"pageshow\" event.\n     * Sometimes, the browser might populate inputs with previous values\n     * when navigating between pages using the back/forward navigation.\n     *\n     * For more information, read about bfcache:\n     * https://web.dev/articles/bfcache\n     */\n    const onPageshow = (ev: PageTransitionEvent) => {\n      if (!ev.persisted) return\n      setSignalFromElement()\n    }\n    window.addEventListener('pageshow', onPageshow)\n\n    const reset = effect(() => setElementFromSignal())\n\n    return () => {\n      reset()\n\n      for (const event of updateEvents) {\n        el.removeEventListener(event, setSignalFromElement)\n      }\n      \n      window.removeEventListener('pageshow', onPageshow)\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: ic:baseline-format-paint\n// Slug: Add or remove classes from an element reactively\n// Description: This action adds or removes classes from an element reactively based on the expression provided. The expression should be an object where the keys are the class names and the values are booleans. If the value is true, the class is added. If the value is false, the class is removed.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { kebab, modifyCasing } from '../../../../utils/text'\n\nexport const Class: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'class',\n  valReq: Requirement.Must,\n  onLoad: ({ el, key, mods, effect, genRX }) => {\n    const cl = el.classList\n    const rx = genRX()\n    return effect(() => {\n      if (key === '') {\n        const classes = rx<Record<string, boolean>>()\n        for (const [k, v] of Object.entries(classes)) {\n          const classNames = k.split(/\\s+/)\n          if (v) {\n            cl.add(...classNames)\n          } else {\n            cl.remove(...classNames)\n          }\n        }\n      } else {\n        // Default to kebab-case and allow modifying\n        let className = kebab(key)\n        className = modifyCasing(className, mods)\n        \n        const shouldInclude = rx<boolean>()\n        if (shouldInclude) {\n          cl.add(className)\n        } else {\n          cl.remove(className)\n        }\n      }\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:mail\n// Slug: Add an event listener to an element\n// Description: This plugin adds an event listener to an element. The event listener can be triggered by a variety of events, such as clicks, keypresses, and more. The event listener can also be set to trigger only once, or to be passive or capture. The event listener can also be debounced or throttled. The event listener can also be set to trigger only when the event target is outside the element.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { kebab, modifyCasing } from '../../../../utils/text'\nimport { modifyTiming } from '../../../../utils/timing'\nimport { modifyViewTransition } from '../../../../utils/view-transtions'\nimport { DATASTAR_SSE_EVENT } from '../../backend/shared'\n\nexport const On: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'on',\n  keyReq: Requirement.Must,\n  valReq: Requirement.Must,\n  argNames: ['evt'],\n  onLoad: ({ el, key, mods, genRX }) => {\n    const rx = genRX()\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n\n    let callback = (evt?: Event) => {\n      if (evt) {\n        // Always prevent default on submit events (because forms)\n        if (mods.has('prevent') || key === 'submit') evt.preventDefault()\n        if (mods.has('stop')) evt.stopPropagation()\n      }\n      rx(evt)\n    }\n\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n\n    const evtListOpts: AddEventListenerOptions = {\n      capture: false,\n      passive: false,\n      once: false,\n    }\n    if (mods.has('capture')) evtListOpts.capture = true\n    if (mods.has('passive')) evtListOpts.passive = true\n    if (mods.has('once')) evtListOpts.once = true\n\n    const testOutside = mods.has('outside')\n    if (testOutside) {\n      target = document\n      const cb = callback\n      const targetOutsideCallback = (e?: Event) => {\n        const targetHTML = e?.target as HTMLElement\n        if (!el.contains(targetHTML)) {\n          cb(e)\n        }\n      }\n      callback = targetOutsideCallback\n    }\n\n    // Default to kebab-case and allow modifying\n    let eventName = kebab(key)\n    eventName = modifyCasing(eventName, mods)\n\n    // Listen for Datastar SSE events on the document\n    if (eventName === DATASTAR_SSE_EVENT) {\n      target = document\n    }\n\n    target.addEventListener(eventName, callback, evtListOpts)\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: mdi:cursor-pointer\n// Slug: Create a reference to an element\n// Description: This attribute creates a reference to an element that can be used in other expressions.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\nimport { modifyCasing, trimDollarSignPrefix } from '../../../../utils/text'\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'ref',\n  keyReq: Requirement.Exclusive,\n  valReq: Requirement.Exclusive,\n  onLoad: ({ el, key, mods, signals, value }) => {\n    const signalName = key ? modifyCasing(key, mods) : trimDollarSignPrefix(value)\n    signals.setValue(signalName, el)\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Show or hide an element\n// Description: This attribute shows or hides an element based on the value of the expression. If the expression is true, the element is shown. If the expression is false, the element is hidden. The element is hidden by setting the display property to none.\n\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nexport const Show: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'show',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: ({ el: { style: s }, genRX, effect }) => {\n    const rx = genRX()\n    return effect(async () => {\n      const shouldShow = rx<boolean>()\n      if (shouldShow) {\n        if (s.display === NONE) {\n          s.removeProperty(DISPLAY)\n        }\n      } else {\n        s.setProperty(DISPLAY, NONE)\n      }\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: tabler:typography\n// Slug: Set the text content of an element\n// Description: This attribute sets the text content of an element to the result of the expression.\n\nimport { runtimeErr } from '../../../../engine/errors'\nimport {\n  type AttributePlugin,\n  PluginType,\n  Requirement,\n} from '../../../../engine/types'\n\nexport const Text: AttributePlugin = {\n  type: PluginType.Attribute,\n  name: 'text',\n  keyReq: Requirement.Denied,\n  valReq: Requirement.Must,\n  onLoad: (ctx) => {\n    const { el, effect, genRX } = ctx\n    const rx = genRX()\n    if (!(el instanceof HTMLElement)) {\n      runtimeErr('TextInvalidElement', ctx)\n    }\n    return effect(() => {\n      const res = rx(ctx)\n      el.textContent = `${res}`\n    })\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-screen-outline\n// Slug: Clamp a value to a new range\n// Description: This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range.\n\nimport {\n  type ActionPlugin,\n  PluginType,\n  type RuntimeContext,\n} from '../../../../engine/types'\n\nconst { round, max, min } = Math\nexport const Fit: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'fit',\n  fn: (\n    _: RuntimeContext,\n    v: number,\n    oldMin: number,\n    oldMax: number,\n    newMin: number,\n    newMax: number,\n    shouldClamp = false,\n    shouldRound = false,\n  ) => {\n    let fitted = ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin\n    if (shouldRound) {\n      fitted = round(fitted)\n    }\n    if (shouldClamp) {\n      fitted = max(newMin, min(newMax, fitted))\n    }\n    return fitted\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: ion:checkmark-round\n// Slug: Set all signals that match the signal path\n// Description: Set all signals that match one or more space-separated paths in which `*` can be used as a wildcard\n\nimport { type ActionPlugin, PluginType } from '../../../../engine/types'\nimport { getMatchingSignalPaths } from '../../../../utils/paths'\n\nexport const SetAll: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'setAll',\n  fn: ({ signals }, paths: string, newValue) => {\n    const signalPaths = getMatchingSignalPaths(signals, paths)\n    for (const path of signalPaths) {\n      signals.setValue(path, newValue)\n    }\n  },\n}\n", "// Authors: Delaney Gillilan\n// Icon: material-symbols:toggle-off\n// Slug: Toggle all signals that match the signal path\n// Description: Toggle all signals that match one or more space-separated paths in which `*` can be used as a wildcard\n\nimport { type ActionPlugin, PluginType } from '../../../../engine/types'\nimport { getMatchingSignalPaths } from '../../../../utils/paths'\n\nexport const ToggleAll: ActionPlugin = {\n  type: PluginType.Action,\n  name: 'toggleAll',\n  fn: ({ signals }, paths: string) => {\n    const signalPaths = getMatchingSignalPaths(signals, paths)\n    for (const path of signalPaths) {\n      signals.setValue(path, !signals.value(path))\n    }\n  },\n}\n", "import { apply, load, setAlias } from '../engine'\nimport { DELETE } from '../plugins/official/backend/actions/delete'\nimport { GET } from '../plugins/official/backend/actions/get'\nimport { PATCH } from '../plugins/official/backend/actions/patch'\nimport { POST } from '../plugins/official/backend/actions/post'\nimport { PUT } from '../plugins/official/backend/actions/put'\nimport { Indicator } from '../plugins/official/backend/attributes/indicator'\nimport { ExecuteScript } from '../plugins/official/backend/watchers/executeScript'\nimport { MergeFragments } from '../plugins/official/backend/watchers/mergeFragments'\nimport { MergeSignals } from '../plugins/official/backend/watchers/mergeSignals'\nimport { RemoveFragments } from '../plugins/official/backend/watchers/removeFragments'\nimport { RemoveSignals } from '../plugins/official/backend/watchers/removeSignals'\nimport { Clipboard } from '../plugins/official/browser/actions/clipboard'\nimport { CustomValidity } from '../plugins/official/browser/attributes/customValidity'\nimport { OnIntersect } from '../plugins/official/browser/attributes/onIntersect'\nimport { OnInterval } from '../plugins/official/browser/attributes/onInterval'\nimport { OnLoad } from '../plugins/official/browser/attributes/onLoad'\nimport { OnRaf } from '../plugins/official/browser/attributes/onRaf'\nimport { OnSignalChange } from '../plugins/official/browser/attributes/onSignalChange'\nimport { Persist } from '../plugins/official/browser/attributes/persist'\nimport { ReplaceUrl } from '../plugins/official/browser/attributes/replaceUrl'\nimport { ScrollIntoView } from '../plugins/official/browser/attributes/scrollIntoView'\nimport { ViewTransition } from '../plugins/official/browser/attributes/viewTransition'\nimport { Attr } from '../plugins/official/dom/attributes/attr'\nimport { Bind } from '../plugins/official/dom/attributes/bind'\nimport { Class } from '../plugins/official/dom/attributes/class'\nimport { On } from '../plugins/official/dom/attributes/on'\nimport { Ref } from '../plugins/official/dom/attributes/ref'\nimport { Show } from '../plugins/official/dom/attributes/show'\nimport { Text } from '../plugins/official/dom/attributes/text'\nimport { Fit } from '../plugins/official/logic/actions/fit'\nimport { SetAll } from '../plugins/official/logic/actions/setAll'\nimport { ToggleAll } from '../plugins/official/logic/actions/toggleAll'\n\nload(\n  // DOM\n  Attr,\n  Bind,\n  Class,\n  On,\n  Ref,\n  Show,\n  Text,\n  // Backend\n  Indicator,\n  GET,\n  POST,\n  PUT,\n  PATCH,\n  DELETE,\n  MergeFragments,\n  MergeSignals,\n  RemoveFragments,\n  RemoveSignals,\n  ExecuteScript,\n  // Browser\n  Clipboard,\n  CustomValidity,\n  OnIntersect,\n  OnInterval,\n  OnLoad,\n  OnRaf,\n  OnSignalChange,\n  Persist,\n  ReplaceUrl,\n  ScrollIntoView,\n  ViewTransition,\n  // Logic\n  Fit,\n  SetAll,\n  ToggleAll,\n)\n\napply()\n\nexport { apply, load, setAlias }\n"],
  "mappings": "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",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "DATASTAR_REQUEST", "DefaultSseRetryDurationMs", "DefaultExecuteScriptAttributes", "DefaultFragmentsUseViewTransitions", "DefaultMergeSignalsOnlyIfMissing", "DefaultExecuteScriptAutoRemove", "FragmentMergeModes", "DefaultFragmentMergeMode", "EventTypes", "PluginType", "DATASTAR_SIGNAL_EVENT", "DATASTAR", "isBoolString", "str", "kebab", "$", "ofs", "camel", "x", "snake", "pascal", "jsStrToObject", "raw", "trimDollarSignPrefix", "caseFns", "modifyCasing", "mods", "c", "fn", "name", "Computed", "key", "mods", "signals", "genRX", "modifyCasing", "rx", "Signals", "ctx", "key", "mods", "signals", "value", "genRX", "ifMissing", "k", "modifyCasing", "v", "obj", "jsStrToObject", "nv", "Star", "Hash", "#value", "#prefix", "prefix", "DATASTAR", "x", "c", "elUniqId", "el", "hash", "currentEl", "p", "attrHash", "key", "val", "walkDOM", "element", "callback", "dataset", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "r", "snake", "q", "c", "internalErr", "from", "args", "initErr", "ctx", "errCtx", "PluginType", "runtimeErr", "from", "BRAND_SYMBOL", "RUNNING", "NOTIFIED", "OUTDATED", "DISPOSED", "HAS_ERROR", "TRACKING", "startBatch", "batchDepth", "endBatch", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "needsToRecompute", "err", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "TRACKING", "Signal", "value", "BRAND_SYMBOL", "prev", "next", "fn", "effect", "prevContext", "internalErr", "from", "old", "revised", "startBatch", "endBatch", "needsToRecompute", "target", "node", "prepareSources", "rollbackNode", "cleanupSources", "head", "prev", "Computed", "fn", "Signal", "globalVersion", "OUTDATED", "NOTIFIED", "RUNNING", "TRACKING", "prevContext", "evalContext", "value", "HAS_ERROR", "err", "internalErr", "from", "addDependency", "computed", "cleanupEffect", "effect", "cleanup", "startBatch", "error", "DISPOSED", "disposeEffect", "endBatch", "endEffect", "Effect", "finish", "batchedEffect", "from", "dispatchSignalEvent", "evt", "DATASTAR_SIGNAL_EVENT", "nestedValues", "signal", "onlyPublic", "kv", "key", "value", "Signal", "mergeNested", "target", "values", "onlyIfMissing", "internalErr", "subEvt", "k", "t", "oldValue", "s", "walkNestedSignal", "cb", "path", "nestedSubset", "original", "keys", "subset", "parts", "subOriginal", "subSubset", "i", "part", "last", "SignalsRoot", "#signals", "dotDelimitedPath", "parts", "subSignals", "i", "part", "last", "signal", "internalErr", "from", "fn", "computed", "value", "oldValue", "dispatchSignalEvent", "defaultValue", "current", "Signal", "dotDelimitedPaths", "removed", "path", "other", "onlyIfMissing", "evt", "mergeNested", "keys", "nestedSubset", "cb", "walkNestedSignal", "signalNames", "onlyPublic", "nestedValues", "shouldIndent", "values", "signals", "SignalsRoot", "actions", "plugins", "removals", "mutationObserver", "alias", "setAlias", "value", "load", "pluginsToLoad", "plugin", "ctx", "cb", "effect", "applyToElement", "globalInitializer", "ap", "initErr", "a", "b", "lenDiff", "apply", "observe", "rootElement", "walkDOM", "el", "toApply", "elCleanups", "toCleanup", "hashes", "datasetKey", "datasetValue", "currentHash", "attrHash", "_", "cleanup", "key", "h", "applyAttributePlugin", "mutations", "toRemove", "target", "type", "addedNodes", "removedNodes", "node", "elTracking", "hash", "camelCasedKey", "rawKey", "camel", "p", "elUniqId", "rawModifiers", "hasKey", "hasValue", "genRX", "keyReq", "runtimeErr", "valReq", "rawMod", "label", "mod", "t", "argNames", "userExpression", "statementRe", "statements", "lastIdx", "last", "escaped", "escapeRe", "DSP", "DSS", "match", "k", "v", "Hash", "fnCall", "matches", "methodsCalled", "actionsRe", "signalNames", "signalsRe", "fnContent", "fn", "args", "error", "load", "Star", "Signals", "Computed", "DATASTAR_SSE_EVENT", "DATASTAR", "STARTED", "FINISHED", "ERROR", "RETRYING", "RETRIES_FAILED", "datastarSSEEventWatcher", "eventType", "fn", "event", "argsRaw", "dispatchSSE", "type", "elId", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "line", "field", "valueOffset", "value", "retry", "a", "b", "res", "EventStreamContentType", "LastEventId", "fetchEventSource", "input", "elId", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "openWhenHidden", "inputFetch", "retryInterval", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "rest", "resolve", "reject", "retries", "headers", "curRequestController", "onVisibilityChange", "create", "retryTimer", "dispose", "fetch", "onopen", "response", "getBytes", "id", "err", "interval", "dispatchSSE", "RETRIES_FAILED", "innerErr", "isWrongContent", "err", "sse", "ctx", "method", "url", "args", "el", "signals", "elId", "userHeaders", "contentType", "includeLocal", "selector", "openWhenHidden", "retryInterval", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "abort", "DefaultSseRetryDurationMs", "action", "cleanupFn", "dispatchSSE", "STARTED", "runtimeErr", "initialHeaders", "DATASTAR_REQUEST", "headers", "req", "response", "status", "ERROR", "evt", "DATASTAR", "type", "argsRawLines", "lines", "line", "colonIndex", "key", "argLines", "value", "argsRaw", "error", "RETRYING", "urlInstance", "queryParams", "json", "formEl", "preventDefault", "formData", "formParams", "fetchEventSource", "FINISHED", "DELETE", "ctx", "url", "args", "sse", "GET", "ctx", "url", "args", "sse", "PATCH", "ctx", "url", "args", "sse", "POST", "ctx", "url", "args", "sse", "PUT", "ctx", "url", "args", "sse", "Indicator", "el", "key", "mods", "signals", "value", "signalName", "modifyCasing", "trimDollarSignPrefix", "signal", "watcher", "event", "type", "elId", "STARTED", "FINISHED", "DATASTAR_SSE_EVENT", "ExecuteScript", "EventTypes", "ctx", "datastarSSEEventWatcher", "autoRemoveRaw", "DefaultExecuteScriptAutoRemove", "attributesRaw", "DefaultExecuteScriptAttributes", "script", "autoRemove", "isBoolString", "initErr", "scriptEl", "attr", "pivot", "key", "value", "docWithViewTransitionAPI", "supportsViewTransitions", "modifyViewTransition", "callback", "mods", "cb", "args", "Idiomorph", "noOp", "defaults", "elt", "morph", "oldNode", "newContent", "config", "normalizeElement", "newNode", "normalizeParent", "ctx", "createMorphContext", "morphedNodes", "saveAndRestoreFocus", "withHeadBlocking", "morphChildren", "morphOuterHTML", "oldParent", "fn", "activeElement", "activeElementId", "selectionStart", "selectionEnd", "results", "newParent", "insertionPoint", "endPoint", "newChild", "bestMatch", "findBestMatch", "removeNodesBetween", "morphNode", "movedChild", "moveBeforeById", "insertedNode", "createNode", "tempNode", "removeNode", "newEmptyChild", "newClonedChild", "node", "startPoint", "softMatch", "nextSibling", "siblingSoftMatchCount", "cursor", "isSoftMatch", "isIdSetMatch", "oldSet", "newSet", "id", "oldElt", "newElt", "moveBefore", "startInclusive", "endExclusive", "parentNode", "after", "target", "removeElementFromAncestorsIdMaps", "element", "idSet", "handleHeadElement", "morphAttributes", "ignoreValueOfActiveElement", "type", "oldAttributes", "newAttributes", "newAttribute", "ignoreAttribute", "i", "oldAttribute", "syncInputValue", "oldElement", "newElement", "newValue", "oldValue", "syncBooleanAttribute", "attributeName", "newLiveValue", "oldLiveValue", "ignoreUpdate", "attr", "updateType", "possibleActiveElement", "callback", "oldHead", "newHead", "promises", "newCtx", "added", "removed", "preserved", "nodesToAppend", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "resolve", "promise", "_resolve", "removedElement", "persistentIds", "idMap", "createIdMaps", "mergedConfig", "mergeDefaults", "morphStyle", "createPantry", "finalConfig", "pantry", "findIdElements", "root", "elements", "populateIdMapWithTree", "current", "oldContent", "oldIdElements", "newIdElements", "createPersistentIds", "newRoot", "duplicateIds", "oldIdTagNameMap", "tagName", "generatedByIdiomorph", "content", "parseContent", "SlicedParentNode", "dummyParent", "nodes", "selector", "nodeList", "referenceNode", "parser", "contentWithSvgsRemoved", "htmlElement", "MergeFragments", "EventTypes", "ctx", "fragmentContainer", "datastarSSEEventWatcher", "fragmentsRaw", "selector", "mergeMode", "DefaultFragmentMergeMode", "useViewTransitionRaw", "DefaultFragmentsUseViewTransitions", "useViewTransition", "isBoolString", "fragments", "fragment", "initErr", "selectorOrID", "targets", "supportsViewTransitions", "docWithViewTransitionAPI", "applyToTargets", "capturedTargets", "target", "fragmentToMerge", "FragmentMergeModes", "walkDOM", "el", "elUniqId", "elTracking", "newElTracking", "key", "cleanup", "newKey", "attrHash", "Idiomorph", "attrName", "value", "MergeSignals", "EventTypes", "ctx", "datastarSSEEventWatcher", "raw", "onlyIfMissingRaw", "DefaultMergeSignalsOnlyIfMissing", "signals", "onlyIfMissing", "isBoolString", "jsStrToObject", "RemoveFragments", "EventTypes", "ctx", "datastarSSEEventWatcher", "selector", "useViewTransitionRaw", "DefaultFragmentsUseViewTransitions", "initErr", "useViewTransition", "isBoolString", "removeTargets", "applyToTargets", "target", "supportsViewTransitions", "docWithViewTransitionAPI", "RemoveSignals", "EventTypes", "ctx", "datastarSSEEventWatcher", "pathsRaw", "paths", "p", "initErr", "Clipboard", "ctx", "text", "runtimeErr", "CustomValidity", "ctx", "el", "genRX", "effect", "runtimeErr", "rx", "result", "tagToMs", "args", "arg", "tagHas", "tags", "tag", "defaultValue", "debounce", "callback", "wait", "leading", "trailing", "timer", "resetTimer", "args", "throttle", "waiting", "modifyTiming", "mods", "debounceArgs", "tagToMs", "tagHas", "throttleArgs", "OnIntersect", "el", "rawKey", "mods", "genRX", "callback", "modifyTiming", "modifyViewTransition", "options", "observer", "entries", "entry", "OnInterval", "mods", "genRX", "callback", "modifyViewTransition", "duration", "durationArgs", "tagToMs", "tagHas", "intervalId", "OnLoad", "mods", "genRX", "callback", "modifyViewTransition", "wait", "delayArgs", "tagToMs", "OnRaf", "mods", "genRX", "callback", "modifyTiming", "modifyViewTransition", "rafId", "raf", "pathMatchesPattern", "path", "pattern", "DSS", "getMatchingSignalPaths", "signals", "paths", "matches", "patterns", "p", "trimDollarSignPrefix", "signalPath", "OnSignalChange", "key", "mods", "signals", "genRX", "callback", "modifyTiming", "modifyViewTransition", "signalFn", "event", "DATASTAR_SIGNAL_EVENT", "pattern", "modifyCasing", "signalValues", "path", "signal", "pathMatchesPattern", "effect", "prev", "Persist", "effect", "mods", "signals", "value", "key", "DATASTAR", "storage", "paths", "storageToSignals", "data", "nestedValues", "signalsToStorage", "signalPaths", "getMatchingSignalPaths", "nv", "ReplaceUrl", "effect", "genRX", "rx", "url", "baseUrl", "fullUrl", "SMOOTH", "INSTANT", "AUTO", "HSTART", "HCENTER", "HEND", "HNEAREST", "VSTART", "VCENTER", "VEND", "VNEAREST", "CENTER", "START", "END", "NEAREST", "FOCUS", "ScrollIntoView", "ctx", "el", "mods", "rawKey", "opts", "runtimeErr", "VIEW_TRANSITION", "ViewTransition", "hasViewTransitionMeta", "node", "meta", "effect", "el", "genRX", "supportsViewTransitions", "rx", "name", "elVTASTyle", "Attr", "el", "key", "effect", "genRX", "rx", "binds", "val", "kebab", "value", "v", "dataURIRegex", "updateEvents", "Bind", "ctx", "el", "key", "mods", "signals", "value", "effect", "input", "signalName", "modifyCasing", "trimDollarSignPrefix", "tnl", "isInput", "isSelect", "type", "hasValueAttribute", "signalDefault", "isCheckbox", "isNumber", "isRadio", "isFile", "signal", "inserted", "arrayIndex", "isArray", "signalArray", "setElementFromSignal", "stringValue", "select", "runtimeErr", "opt", "incoming", "setSignalFromElement", "currentValue", "currentArray", "update", "newValue", "files", "allContents", "allMimes", "allNames", "f", "resolve", "reader", "match", "checked", "selectedOptions", "event", "onPageshow", "ev", "reset", "Class", "el", "key", "mods", "effect", "genRX", "cl", "rx", "classes", "k", "v", "classNames", "className", "kebab", "modifyCasing", "On", "el", "key", "mods", "genRX", "rx", "target", "callback", "evt", "modifyTiming", "modifyViewTransition", "evtListOpts", "cb", "e", "targetHTML", "eventName", "kebab", "modifyCasing", "DATASTAR_SSE_EVENT", "Ref", "el", "key", "mods", "signals", "value", "signalName", "modifyCasing", "trimDollarSignPrefix", "NONE", "DISPLAY", "Show", "s", "genRX", "effect", "rx", "Text", "ctx", "el", "effect", "genRX", "rx", "runtimeErr", "res", "round", "max", "min", "Fit", "_", "v", "oldMin", "oldMax", "newMin", "newMax", "shouldClamp", "shouldRound", "fitted", "SetAll", "signals", "paths", "newValue", "signalPaths", "getMatchingSignalPaths", "path", "ToggleAll", "signals", "paths", "signalPaths", "getMatchingSignalPaths", "path", "load", "Attr", "Bind", "Class", "On", "Ref", "Show", "Text", "Indicator", "GET", "POST", "PUT", "PATCH", "DELETE", "MergeFragments", "MergeSignals", "RemoveFragments", "RemoveSignals", "ExecuteScript", "Clipboard", "CustomValidity", "OnIntersect", "OnInterval", "OnLoad", "OnRaf", "OnSignalChange", "Persist", "ReplaceUrl", "ScrollIntoView", "ViewTransition", "Fit", "SetAll", "ToggleAll", "apply"]
}