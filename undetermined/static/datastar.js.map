{
  "version": 3,
  "sources": ["../library/src/engine/consts.ts", "../library/src/utils/dom.ts", "../library/src/utils/paths.ts", "../library/src/utils/text.ts", "../library/src/engine/errors.ts", "../library/src/engine/types.ts", "../library/src/engine/engine.ts", "../library/src/plugins/actions/peek.ts", "../library/src/plugins/actions/setAll.ts", "../library/src/plugins/actions/toggleAll.ts", "../library/src/plugins/attributes/attr.ts", "../library/src/plugins/attributes/bind.ts", "../library/src/plugins/attributes/class.ts", "../library/src/plugins/attributes/computed.ts", "../library/src/plugins/attributes/effect.ts", "../library/src/plugins/backend/shared.ts", "../library/src/plugins/attributes/indicator.ts", "../library/src/plugins/attributes/jsonSignals.ts", "../library/src/utils/tags.ts", "../library/src/utils/timing.ts", "../library/src/utils/view-transitions.ts", "../library/src/plugins/attributes/on.ts", "../library/src/plugins/attributes/onIntersect.ts", "../library/src/plugins/attributes/onInterval.ts", "../library/src/plugins/attributes/onLoad.ts", "../library/src/plugins/attributes/onSignalPatch.ts", "../library/src/plugins/attributes/ref.ts", "../library/src/plugins/attributes/show.ts", "../library/src/plugins/attributes/signals.ts", "../library/src/plugins/attributes/text.ts", "../library/src/plugins/backend/actions/fetch.ts", "../library/src/plugins/backend/actions/delete.ts", "../library/src/plugins/backend/actions/get.ts", "../library/src/plugins/backend/actions/patch.ts", "../library/src/plugins/backend/actions/post.ts", "../library/src/plugins/backend/actions/put.ts", "../library/src/plugins/backend/watchers/patchElements.ts", "../library/src/plugins/backend/watchers/patchSignals.ts", "../library/src/bundles/datastar.ts"],
  "sourcesContent": ["// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /\uD83D\uDD95JS_DS\uD83D\uDE80/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should elements be patched using the ViewTransition API?\nexport const DefaultElementsUseViewTransitions = false;\n\n// Should a given set of signals patch if they are missing?\nexport const DefaultPatchSignalsOnlyIfMissing = false;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a element is patched into the DOM.\n// Morphs the element into the existing element.\nexport const ElementPatchModeOuter = \"outer\"\n// Replaces the inner HTML of the existing element.\nexport const ElementPatchModeInner = \"inner\"\n// Removes the existing element.\nexport const ElementPatchModeRemove = \"remove\"\n// Replaces the existing element with the new element.\nexport const ElementPatchModeReplace = \"replace\"\n// Prepends the element inside to the existing element.\nexport const ElementPatchModePrepend = \"prepend\"\n// Appends the element inside the existing element.\nexport const ElementPatchModeAppend = \"append\"\n// Inserts the element before the existing element.\nexport const ElementPatchModeBefore = \"before\"\n// Inserts the element after the existing element.\nexport const ElementPatchModeAfter = \"after\"\n\n// Default value for ElementPatchMode\nexport const DefaultElementPatchMode = ElementPatchModeOuter;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\n// An event for patching HTML elements into the DOM.\nexport const EventTypePatchElements = \"datastar-patch-elements\"\n// An event for patching signals.\nexport const EventTypePatchSignals = \"datastar-patch-signals\"\n// #endregion\n\n// #endregion", "import type { HTMLOrSVG } from '../engine/types'\n\nexport function isHTMLOrSVG(el: Node): el is HTMLOrSVG {\n  return el instanceof HTMLElement || el instanceof SVGElement\n}\n", "export const isPojo = (obj: any): obj is Record<string, any> =>\n  obj !== null &&\n  typeof obj === 'object' &&\n  (Object.getPrototypeOf(obj) === Object.prototype ||\n    Object.getPrototypeOf(obj) === null)\n\nexport function isEmpty(obj: Record<string, any>): boolean {\n  for (const prop in obj) {\n    if (Object.hasOwn(obj, prop)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function updateLeaves(\n  obj: Record<string, any>,\n  fn: (oldValue: any) => any,\n) {\n  for (const key in obj) {\n    const val = obj[key]\n    if (isPojo(val) || Array.isArray(val)) {\n      updateLeaves(val, fn)\n    } else {\n      obj[key] = fn(val)\n    }\n  }\n}\n\nexport const pathToObj = (\n  target: Record<string, any>,\n  paths: Record<string, any>,\n): Record<string, any> => {\n  for (const path in paths) {\n    const keys = path.split('.')\n    const lastKey = keys.pop()!\n    const obj = keys.reduce((acc, key) => (acc[key] ??= {}), target)\n    obj[lastKey] = paths[path]\n  }\n  return target\n}\n", "import type { Modifiers } from '../engine/types'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase()\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) => {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    // If JSON parsing fails, try to evaluate as a JavaScript object\n    // This is less safe and should be used with caution\n    return Function(`return (${raw})`)()\n  }\n}\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n", "import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport type { InitContext, RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(reason: string, ctx: InitContext, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(ctx: RuntimeContext, reason: string, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      // validSignals:\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n", "import { DATASTAR } from './consts'\nexport type PluginType = 'attribute' | 'watcher' | 'action'\nexport type Requirement = 'allowed' | 'must' | 'denied' | 'exclusive'\n\n// export type ReactiveNode = Signal | Computed | Effect\n// export type Subscriber = Computed | Effect\nexport type OnRemovalFn = () => void\n\nexport type DatastarPlugin = AttributePlugin | WatcherPlugin | ActionPlugin\n\nexport const DATASTAR_SIGNAL_PATCH_EVENT = `${DATASTAR}-signal-patch`\nexport type JSONPatch = Record<string, any>\n\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_PATCH_EVENT]: CustomEvent<JSONPatch>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accessible via a `data-${name}` attribute on an element\nexport type AttributePlugin = {\n  type: 'attribute'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  returnsValue?: boolean // If the expression returns a value\n  shouldEvaluate?: boolean // If the value should be evaluated\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the Datastar instance\nexport type WatcherPlugin = {\n  type: 'watcher'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport type ActionPlugin = {\n  type: 'action'\n  name: string // The name of the plugin\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type InitContext = {\n  plugin: DatastarPlugin // The plugin instance\n  actions: Readonly<ActionPlugins> // All registered actions\n  root: Record<string, any> // global signals and computed signals\n  filtered: (opts?: SignalFilterOptions, obj?: JSONPatch) => Record<string, any>\n  signal<T>(initialValue?: T | undefined): Signal<T> // creates a signal\n  computed<T>(getter: (previousValue?: T) => T): Computed<T> // creates a computed signal\n  effect(fn: (...args: any[]) => void): OnRemovalFn // creates an effect\n  mergePatch: (patch: any, args?: { ifMissing?: boolean }) => any\n  peek: <T>(fn: () => T) => T // returns the current state of the signal without subscribing\n  getPath: <T = any>(path: string) => T // get a value from the root\n  hasPath: (path: string) => boolean // check if a path exists from the root\n  startBatch: () => void // starts a signal batch\n  endBatch: () => void // ends a signal batch\n}\n\nexport type HTMLOrSVG = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\nexport type ReactiveExpressionFn = <T>(...argsThenDeps: any[]) => T // a reactive expression\n\nexport type RuntimeContext = InitContext & {\n  el: HTMLOrSVG // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the modifiers and their tags\n  rx: ReactiveExpressionFn // function to generate a reactive expression\n  fnContent?: string // the content of the function\n  evt?: Event // the event that triggered the plugin\n  runtimeErr: (reason: string, metadata?: object) => Error\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n\nexport type EventCallbackHandler = (...args: any[]) => void\n\nexport type SignalFilter = RegExp\nexport type SignalFilterOptions = {\n  include?: RegExp\n  exclude?: RegExp\n}\n\nexport type Signal<T = any> = {\n  (): T\n  (value: T): boolean\n}\n\nexport type Computed<T = any> = () => T\n\nexport type Effect = () => void\n", "import { isHTMLOrSVG } from '../utils/dom'\nimport { isEmpty, isPojo, pathToObj } from '../utils/paths'\nimport { camel, snake } from '../utils/text'\nimport { DATASTAR, DSP, DSS } from './consts'\nimport { initErr, runtimeErr } from './errors'\nimport type {\n  ActionPlugins,\n  AttributePlugin,\n  Computed,\n  DatastarPlugin,\n  Effect,\n  HTMLOrSVG,\n  InitContext,\n  JSONPatch,\n  OnRemovalFn,\n  RuntimeContext,\n  RuntimeExpressionFunction,\n  Signal,\n  SignalFilterOptions,\n} from './types'\nimport { DATASTAR_SIGNAL_PATCH_EVENT } from './types'\n\n/**\n * Custom signals implementation based on Alien Signals\n */\n\ninterface ReactiveNode {\n  deps_?: Link\n  depsTail_?: Link\n  subs_?: Link\n  subsTail_?: Link\n  flags_: ReactiveFlags\n}\n\ninterface Link {\n  dep_: ReactiveNode\n  sub_: ReactiveNode\n  prevSub_?: Link\n  nextSub_?: Link\n  prevDep_?: Link\n  nextDep_?: Link\n}\n\ninterface Stack<T> {\n  value_: T\n  prev_?: Stack<T>\n}\n\nenum ReactiveFlags {\n  None = 0,\n  Mutable = 1 << 0,\n  Watching = 1 << 1,\n  RecursedCheck = 1 << 2,\n  Recursed = 1 << 3,\n  Dirty = 1 << 4,\n  Pending = 1 << 5,\n}\n\nenum EffectFlags {\n  Queued = 1 << 6,\n}\n\ninterface AlienEffect extends ReactiveNode {\n  fn_(): void\n}\n\ninterface AlienComputed<T = any> extends ReactiveNode {\n  value_?: T\n  getter(previousValue?: T): T\n}\n\ninterface AlienSignal<T = any> extends ReactiveNode {\n  previousValue: T\n  value_: T\n}\n\nlet currentPatch: Record<string, any> = {}\nconst queuedEffects: (AlienEffect | undefined)[] = []\nlet batchDepth = 0\nlet notifyIndex = 0\nlet queuedEffectsLength = 0\nlet activeSub: ReactiveNode | undefined\n\nconst startBatch = (): void => {\n  batchDepth++\n}\nconst endBatch = (): void => {\n  if (!--batchDepth) {\n    flush()\n    dispatch()\n  }\n}\n\nconst signal = <T>(initialValue?: T): Signal<T> => {\n  return signalOper.bind(0, {\n    previousValue: initialValue,\n    value_: initialValue,\n    flags_: 1 satisfies ReactiveFlags.Mutable,\n  }) as Signal<T>\n}\n\nconst computedSymbol = Symbol('computed')\nconst computed = <T>(getter: (previousValue?: T) => T): Computed<T> => {\n  const c = computedOper.bind(0, {\n    flags_: 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty,\n    getter,\n  }) as Computed<T>\n  // @ts-ignore\n  c[computedSymbol] = 1\n  return c\n}\n\nconst effect = (fn: () => void): Effect => {\n  const e: AlienEffect = {\n    fn_: fn,\n    flags_: 2 satisfies ReactiveFlags.Watching,\n  }\n  if (activeSub) {\n    link(e, activeSub)\n  }\n  const prev = setCurrentSub(e)\n  startBatch()\n  try {\n    e.fn_()\n  } finally {\n    endBatch()\n    setCurrentSub(prev)\n  }\n  return effectOper.bind(0, e)\n}\n\nconst peek = <T>(fn: () => T): T => {\n  const prev = setCurrentSub(undefined)\n  try {\n    return fn()\n  } finally {\n    setCurrentSub(prev)\n  }\n}\n\nconst flush = () => {\n  while (notifyIndex < queuedEffectsLength) {\n    const effect = queuedEffects[notifyIndex]!\n    queuedEffects[notifyIndex++] = undefined\n    run(effect, (effect.flags_ &= ~EffectFlags.Queued))\n  }\n  notifyIndex = 0\n  queuedEffectsLength = 0\n}\n\nconst update = (signal: AlienSignal | AlienComputed): boolean => {\n  if ('getter' in signal) {\n    return updateComputed(signal)\n  }\n  return updateSignal(signal, signal.value_)\n}\n\nconst setCurrentSub = (sub?: ReactiveNode): ReactiveNode | undefined => {\n  const prevSub = activeSub\n  activeSub = sub\n  return prevSub\n}\n\nconst updateComputed = (c: AlienComputed): boolean => {\n  const prevSub = setCurrentSub(c)\n  startTracking(c)\n  try {\n    const oldValue = c.value_\n    return oldValue !== (c.value_ = c.getter(oldValue))\n  } finally {\n    setCurrentSub(prevSub)\n    endTracking(c)\n  }\n}\n\nconst updateSignal = (s: AlienSignal, value: any): boolean => {\n  s.flags_ = 1 satisfies ReactiveFlags.Mutable\n  return s.previousValue !== (s.previousValue = value)\n}\n\nconst notify = (e: AlienEffect): void => {\n  const flags = e.flags_\n  if (!(flags & EffectFlags.Queued)) {\n    e.flags_ = flags | EffectFlags.Queued\n    const subs = e.subs_\n    if (subs) {\n      notify(subs.sub_ as AlienEffect)\n    } else {\n      queuedEffects[queuedEffectsLength++] = e\n    }\n  }\n}\n\nconst run = (e: AlienEffect, flags: ReactiveFlags): void => {\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(e.deps_!, e))\n  ) {\n    const prev = setCurrentSub(e)\n    startTracking(e)\n    startBatch()\n    try {\n      e.fn_()\n    } finally {\n      endBatch()\n      setCurrentSub(prev)\n      endTracking(e)\n    }\n    return\n  }\n  if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    e.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  let link = e.deps_\n  while (link) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n    if (depFlags & EffectFlags.Queued) {\n      run(dep as AlienEffect, (dep.flags_ = depFlags & ~EffectFlags.Queued))\n    }\n    link = link.nextDep_\n  }\n}\n\nconst computedOper = <T>(c: AlienComputed<T>): T => {\n  const flags = c.flags_\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(c.deps_!, c))\n  ) {\n    if (updateComputed(c)) {\n      const subs = c.subs_\n      if (subs) {\n        shallowPropagate(subs)\n      }\n    }\n  } else if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    c.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  if (activeSub) {\n    link(c, activeSub)\n  }\n  return c.value_!\n}\n\nconst signalOper = <T>(s: AlienSignal<T>, ...value: [T]): T | boolean => {\n  if (value.length) {\n    const newValue = value[0]\n    if (s.value_ !== (s.value_ = newValue)) {\n      s.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n      const subs = s.subs_\n      if (subs) {\n        propagate(subs)\n        if (!batchDepth) {\n          flush()\n        }\n      }\n      return true\n    }\n    return false\n  }\n  const currentValue = s.value_\n  if (s.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n    if (updateSignal(s, currentValue)) {\n      const subs_ = s.subs_\n      if (subs_) {\n        shallowPropagate(subs_)\n      }\n    }\n  }\n  if (activeSub) {\n    link(s, activeSub)\n  }\n  return currentValue\n}\n\nconst effectOper = (e: AlienEffect): void => {\n  let dep = e.deps_\n  while (dep) {\n    dep = unlink(dep, e)\n  }\n  const sub = e.subs_\n  if (sub) {\n    unlink(sub)\n  }\n  e.flags_ = 0 satisfies ReactiveFlags.None\n}\n\nconst link = (dep: ReactiveNode, sub: ReactiveNode): void => {\n  const prevDep = sub.depsTail_\n  if (prevDep && prevDep.dep_ === dep) {\n    return\n  }\n  let nextDep: Link | undefined\n  const recursedCheck = sub.flags_ & (4 satisfies ReactiveFlags.RecursedCheck)\n  if (recursedCheck) {\n    nextDep = prevDep ? prevDep.nextDep_ : sub.deps_\n    if (nextDep && nextDep.dep_ === dep) {\n      sub.depsTail_ = nextDep\n      return\n    }\n  }\n  const prevSub = dep.subsTail_\n  if (\n    prevSub &&\n    prevSub.sub_ === sub &&\n    (!recursedCheck || isValidLink(prevSub, sub))\n  ) {\n    return\n  }\n  const newLink =\n    (sub.depsTail_ =\n    dep.subsTail_ =\n      {\n        dep_: dep,\n        sub_: sub,\n        prevDep_: prevDep,\n        nextDep_: nextDep,\n        prevSub_: prevSub,\n      })\n  if (nextDep) {\n    nextDep.prevDep_ = newLink\n  }\n  if (prevDep) {\n    prevDep.nextDep_ = newLink\n  } else {\n    sub.deps_ = newLink\n  }\n  if (prevSub) {\n    prevSub.nextSub_ = newLink\n  } else {\n    dep.subs_ = newLink\n  }\n}\n\nconst unlink = (link: Link, sub_ = link.sub_): Link | undefined => {\n  const dep_ = link.dep_\n  const prevDep_ = link.prevDep_\n  const nextDep_ = link.nextDep_\n  const nextSub_ = link.nextSub_\n  const prevSub_ = link.prevSub_\n  if (nextDep_) {\n    nextDep_.prevDep_ = prevDep_\n  } else {\n    sub_.depsTail_ = prevDep_\n  }\n  if (prevDep_) {\n    prevDep_.nextDep_ = nextDep_\n  } else {\n    sub_.deps_ = nextDep_\n  }\n  if (nextSub_) {\n    nextSub_.prevSub_ = prevSub_\n  } else {\n    dep_.subsTail_ = prevSub_\n  }\n  if (prevSub_) {\n    prevSub_.nextSub_ = nextSub_\n  } else if (!(dep_.subs_ = nextSub_)) {\n    if ('getter' in dep_) {\n      let toRemove = dep_.deps_\n      if (toRemove) {\n        dep_.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n        do {\n          toRemove = unlink(toRemove, dep_)\n        } while (toRemove)\n      }\n    } else if (!('previousValue' in dep_)) {\n      effectOper(dep_ as AlienEffect)\n    }\n  }\n  return nextDep_\n}\n\nconst propagate = (link: Link): void => {\n  let next = link.nextSub_\n  let stack: Stack<Link | undefined> | undefined\n\n  top: while (true) {\n    const sub = link.sub_\n\n    let flags = sub.flags_\n\n    if (flags & (3 as ReactiveFlags.Mutable | ReactiveFlags.Watching)) {\n      if (\n        !(\n          flags &\n          (60 as\n            | ReactiveFlags.RecursedCheck\n            | ReactiveFlags.Recursed\n            | ReactiveFlags.Dirty\n            | ReactiveFlags.Pending)\n        )\n      ) {\n        sub.flags_ = flags | (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (12 as ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed))\n      ) {\n        flags = 0 satisfies ReactiveFlags.None\n      } else if (!(flags & (4 satisfies ReactiveFlags.RecursedCheck))) {\n        sub.flags_ =\n          (flags & ~(8 satisfies ReactiveFlags.Recursed)) |\n          (32 satisfies ReactiveFlags.Pending)\n      } else if (\n        !(flags & (48 as ReactiveFlags.Dirty | ReactiveFlags.Pending)) &&\n        isValidLink(link, sub)\n      ) {\n        sub.flags_ =\n          flags | (40 as ReactiveFlags.Recursed | ReactiveFlags.Pending)\n        flags &= 1 satisfies ReactiveFlags.Mutable\n      } else {\n        flags = 0 satisfies ReactiveFlags.None\n      }\n\n      if (flags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n\n      if (flags & (1 satisfies ReactiveFlags.Mutable)) {\n        const subSubs = sub.subs_\n        if (subSubs) {\n          link = subSubs\n          if (subSubs.nextSub_) {\n            stack = { value_: next, prev_: stack }\n            next = link.nextSub_\n          }\n          continue\n        }\n      }\n    }\n\n    if ((link = next!)) {\n      next = link.nextSub_\n      continue\n    }\n\n    while (stack) {\n      link = stack.value_!\n      stack = stack.prev_\n      if (link) {\n        next = link.nextSub_\n        continue top\n      }\n    }\n\n    break\n  }\n}\n\nconst startTracking = (sub: ReactiveNode): void => {\n  sub.depsTail_ = undefined\n  sub.flags_ =\n    (sub.flags_ &\n      ~(56 as\n        | ReactiveFlags.Recursed\n        | ReactiveFlags.Dirty\n        | ReactiveFlags.Pending)) |\n    (4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst endTracking = (sub: ReactiveNode): void => {\n  const depsTail_ = sub.depsTail_\n  let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_\n  while (toRemove) {\n    toRemove = unlink(toRemove, sub)\n  }\n  sub.flags_ &= ~(4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst checkDirty = (link: Link, sub: ReactiveNode): boolean => {\n  let stack: Stack<Link> | undefined\n  let checkDepth = 0\n\n  top: while (true) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n\n    let dirty = false\n\n    if (sub.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n      dirty = true\n    } else if (\n      (depFlags & (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n      (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n    ) {\n      if (update(dep as AlienSignal | AlienComputed)) {\n        const subs = dep.subs_!\n        if (subs.nextSub_) {\n          shallowPropagate(subs)\n        }\n        dirty = true\n      }\n    } else if (\n      (depFlags & (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n      (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)\n    ) {\n      if (link.nextSub_ || link.prevSub_) {\n        stack = { value_: link, prev_: stack }\n      }\n      link = dep.deps_!\n      sub = dep\n      ++checkDepth\n      continue\n    }\n\n    if (!dirty && link.nextDep_) {\n      link = link.nextDep_\n      continue\n    }\n\n    while (checkDepth) {\n      --checkDepth\n      const firstSub = sub.subs_!\n      const hasMultipleSubs = firstSub.nextSub_\n      if (hasMultipleSubs) {\n        link = stack!.value_\n        stack = stack!.prev_\n      } else {\n        link = firstSub\n      }\n      if (dirty) {\n        if (update(sub as AlienSignal | AlienComputed)) {\n          if (hasMultipleSubs) {\n            shallowPropagate(firstSub)\n          }\n          sub = link.sub_\n          continue\n        }\n      } else {\n        sub.flags_ &= ~(32 satisfies ReactiveFlags.Pending)\n      }\n      sub = link.sub_\n      if (link.nextDep_) {\n        link = link.nextDep_\n        continue top\n      }\n      dirty = false\n    }\n\n    return dirty\n  }\n}\n\nconst shallowPropagate = (link: Link): void => {\n  do {\n    const sub = link.sub_\n    const nextSub = link.nextSub_\n    const subFlags = sub.flags_\n    if (\n      (subFlags & (48 as ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n      (32 satisfies ReactiveFlags.Pending)\n    ) {\n      sub.flags_ = subFlags | (16 satisfies ReactiveFlags.Dirty)\n      if (subFlags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n    }\n    link = nextSub!\n  } while (link)\n}\n\nconst isValidLink = (checkLink: Link, sub: ReactiveNode): boolean => {\n  const depsTail = sub.depsTail_\n  if (depsTail) {\n    let link = sub.deps_!\n    do {\n      if (link === checkLink) {\n        return true\n      }\n      if (link === depsTail) {\n        break\n      }\n      link = link.nextDep_!\n    } while (link)\n  }\n  return false\n}\n\nconst getPath = <T = any>(path: string): T =>\n  path.split('.').reduce((acc, key) => acc[key], root) as T\n\nconst hasPath = (path: string): boolean =>\n  peek(\n    () =>\n      path\n        .split('.')\n        .reduce(\n          (obj, key) => (obj && Object.hasOwn(obj, key) ? obj[key] : undefined),\n          root,\n        ) !== undefined,\n  )\n\nexport const DELETE = Symbol('delete')\nconst deep = (value: any, prefix = ''): any => {\n  const isArr = Array.isArray(value)\n  if (isArr || isPojo(value)) {\n    const deepObj = (isArr ? [] : {}) as Record<string, Signal>\n    for (const key in value) {\n      deepObj[key] = signal(\n        deep((value as Record<string, Signal>)[key], `${prefix + key}.`),\n      )\n    }\n    const keys = signal(0)\n    return new Proxy(deepObj, {\n      get: (_, prop: string) => {\n        if (!(prop === 'toJSON' && !Object.hasOwn(deepObj, prop))) {\n          if (isArr && prop in Array.prototype) {\n            keys()\n            return deepObj[prop]\n          } else {\n            if (!Object.hasOwn(deepObj, prop) || deepObj[prop]() == null) {\n              deepObj[prop] = signal('')\n              dispatch({ [prefix + prop]: '' })\n              keys(keys() + 1)\n            }\n            return deepObj[prop]()\n          }\n        }\n      },\n      set: (_, prop: string, newValue) => {\n        if (newValue === DELETE) {\n          if (Object.hasOwn(deepObj, prop)) {\n            delete deepObj[prop]\n            dispatch({ [prefix + prop]: DELETE })\n            keys(keys() + 1)\n          }\n        } else {\n          if (isArr && prop === 'length') {\n            deepObj[prop] = newValue\n            dispatch({ [prefix.slice(0, -1)]: deepObj })\n            keys(keys() + 1)\n          } else {\n            if (Object.hasOwn(deepObj, prop)) {\n              if (newValue == null) {\n                if (deepObj[prop](null)) {\n                  dispatch({ [prefix + prop]: null })\n                }\n              } else {\n                if (deepObj[prop](deep(newValue, `${prefix + prop}.`))) {\n                  dispatch({ [prefix + prop]: newValue })\n                }\n              }\n            } else {\n              if (newValue != null) {\n                if (Object.hasOwn(newValue, computedSymbol)) {\n                  deepObj[prop] = newValue\n                  dispatch({ [prefix + prop]: '' })\n                } else {\n                  deepObj[prop] = signal(deep(newValue, `${prefix + prop}.`))\n                  dispatch({ [prefix + prop]: newValue })\n                }\n                keys(keys() + 1)\n              }\n            }\n          }\n        }\n\n        return true\n      },\n      deleteProperty: (_, prop: string) => {\n        if (Object.hasOwn(deepObj, prop)) {\n          if (deepObj[prop](null)) {\n            dispatch({ [prefix + prop]: null })\n          }\n        }\n\n        return true\n      },\n      ownKeys: () => {\n        keys()\n        return Reflect.ownKeys(deepObj)\n      },\n      has(_, prop) {\n        keys()\n        return prop in deepObj\n      },\n    })\n  }\n  return value\n}\n\nconst dispatch = (obj?: Record<string, any>) => {\n  if (obj) {\n    pathToObj(currentPatch, obj)\n  }\n  if (!batchDepth && !isEmpty(currentPatch)) {\n    const oldPatch = currentPatch\n    currentPatch = {}\n    document.dispatchEvent(\n      new CustomEvent<JSONPatch>(DATASTAR_SIGNAL_PATCH_EVENT, {\n        detail: oldPatch,\n      }),\n    )\n  }\n}\n\nconst mergePatch = (\n  patch: Record<string, any>,\n  { ifMissing }: { ifMissing?: boolean } = {},\n): void => {\n  startBatch()\n  for (const key in patch) {\n    if (patch[key] == null) {\n      if (!ifMissing) {\n        delete root[key]\n      }\n    } else {\n      mergeInner(patch[key], key, root, '', ifMissing)\n    }\n  }\n  endBatch()\n}\n\nconst mergeInner = (\n  patch: any,\n  target: string,\n  targetParent: Record<string, any>,\n  prefix: string,\n  ifMissing: boolean | undefined,\n): void => {\n  if (isPojo(patch)) {\n    if (\n      !(\n        Object.hasOwn(targetParent, target) &&\n        (isPojo(targetParent[target]) || Array.isArray(targetParent[target]))\n      )\n    ) {\n      targetParent[target] = {}\n    }\n\n    for (const key in patch) {\n      if (patch[key] == null) {\n        if (!ifMissing) {\n          delete targetParent[target][key]\n        }\n      } else {\n        mergeInner(\n          patch[key],\n          key,\n          targetParent[target],\n          `${prefix + target}.`,\n          ifMissing,\n        )\n      }\n    }\n  } else if (!(ifMissing && Object.hasOwn(targetParent, target))) {\n    targetParent[target] = patch\n  }\n}\n\nfunction filtered(\n  { include = /.*/, exclude = /(?!)/ }: SignalFilterOptions = {},\n  obj: JSONPatch = root,\n) {\n  // We need to find all valid signal paths in the object\n  const pathObj: Record<string, any> = {}\n  const stack: Array<[any, string]> = [[obj, '']]\n\n  while (stack.length) {\n    const [node, prefix] = stack.pop()!\n\n    for (const key in node) {\n      if (isPojo(node[key])) {\n        stack.push([node[key], `${prefix + key}.`])\n      } else if (include.test(prefix + key) && !exclude.test(prefix + key)) {\n        pathObj[prefix + key] = getPath(prefix + key)\n      }\n    }\n  }\n\n  return pathToObj({}, pathObj)\n}\n\nconst root: Record<string, any> = deep({})\n\n/**\n * Turn data-* attributes into reactive expressions\n * This is the core of the Datastar\n */\n\nconst actions: ActionPlugins = {}\nconst plugins: AttributePlugin[] = []\nlet pluginRegexs: RegExp[] = []\n\n// Map of cleanup functions by element, keyed by a dataset key-value hash\nconst removals = new Map<HTMLOrSVG, Map<string, OnRemovalFn>>()\n\nlet mutationObserver: MutationObserver | null = null\n\nlet alias = ''\nexport function setAlias(value: string) {\n  alias = value\n}\nexport function aliasify(name: string) {\n  return alias ? `data-${alias}-${name}` : `data-${name}`\n}\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n  for (const plugin of pluginsToLoad) {\n    const ctx: InitContext = {\n      plugin,\n      actions,\n      root,\n      filtered,\n      signal,\n      computed,\n      effect,\n      mergePatch,\n      peek,\n      getPath,\n      hasPath,\n      startBatch,\n      endBatch,\n    }\n    if (plugin.type === 'action') {\n      actions[plugin.name] = plugin\n    } else if (plugin.type === 'attribute') {\n      plugins.push(plugin)\n      plugin.onGlobalInit?.(ctx)\n    } else if (plugin.type === 'watcher') {\n      plugin.onGlobalInit?.(ctx)\n    } else {\n      throw initErr('InvalidPluginType', ctx)\n    }\n  }\n\n  // Sort attribute plugins by descending length then alphabetically\n  plugins.sort((a, b) => {\n    const lenDiff = b.name.length - a.name.length\n    if (lenDiff !== 0) return lenDiff\n    return a.name.localeCompare(b.name)\n  })\n\n  pluginRegexs = plugins.map((plugin) => RegExp(`^${plugin.name}([A-Z]|_|$)`))\n}\n\nfunction applyEls(els: Iterable<HTMLOrSVG>): void {\n  const ignore = `[${aliasify('ignore')}]`\n  for (const el of els) {\n    if (!el.closest(ignore)) {\n      for (const key in el.dataset) {\n        applyAttributePlugin(el, key, el.dataset[key]!)\n      }\n    }\n  }\n}\n\n// Apply all plugins to the entire DOM or a provided element\nexport function apply(root: HTMLOrSVG = document.body) {\n  // Delay applying plugins to give custom plugins a chance to load\n  queueMicrotask(() => {\n    applyEls([root])\n    applyEls(root.querySelectorAll<HTMLOrSVG>('*'))\n\n    // Monitor the entire document body or a provided element for changes\n    // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n    if (!mutationObserver) {\n      mutationObserver = new MutationObserver(observe)\n      mutationObserver.observe(root, {\n        subtree: true,\n        childList: true,\n        attributes: true,\n      })\n    }\n  })\n}\n\nfunction applyAttributePlugin(\n  el: HTMLOrSVG,\n  attrKey: string,\n  value: string,\n): void {\n  const rawKey = camel(alias ? attrKey.slice(alias.length) : attrKey)\n  const plugin = plugins.find((_, i) => pluginRegexs[i].test(rawKey))\n  if (plugin) {\n    // Extract the key and modifiers\n    let [key, ...rawModifiers] = rawKey.slice(plugin.name.length).split(/__+/)\n\n    const hasKey = !!key\n    if (hasKey) {\n      key = camel(key)\n    }\n    const hasValue = !!value\n\n    // Create the runtime context\n    const ctx: RuntimeContext = {\n      plugin,\n      actions,\n      root,\n      filtered,\n      signal,\n      computed,\n      effect,\n      mergePatch,\n      peek,\n      getPath,\n      hasPath,\n      startBatch,\n      endBatch,\n      el,\n      rawKey,\n      key,\n      value,\n      mods: new Map(),\n      runtimeErr: 0 as any,\n      rx: 0 as any,\n    }\n    ctx.runtimeErr = runtimeErr.bind(0, ctx)\n    if (plugin.shouldEvaluate === undefined || plugin.shouldEvaluate === true) {\n      ctx.rx = generateReactiveExpression(ctx)\n    }\n\n    // Check the requirements\n    const keyReq = plugin.keyReq || 'allowed'\n    if (hasKey) {\n      if (keyReq === 'denied') {\n        throw ctx.runtimeErr(`${plugin.name}KeyNotAllowed`)\n      }\n    } else if (keyReq === 'must') {\n      throw ctx.runtimeErr(`${plugin.name}KeyRequired`)\n    }\n\n    const valReq = plugin.valReq || 'allowed'\n    if (hasValue) {\n      if (valReq === 'denied') {\n        throw ctx.runtimeErr(`${plugin.name}ValueNotAllowed`)\n      }\n    } else if (valReq === 'must') {\n      throw ctx.runtimeErr(`${plugin.name}ValueRequired`)\n    }\n\n    // Check for exclusive requirements\n    if (keyReq === 'exclusive' || valReq === 'exclusive') {\n      if (hasKey && hasValue) {\n        throw ctx.runtimeErr(`${plugin.name}KeyAndValueProvided`)\n      }\n      if (!hasKey && !hasValue) {\n        throw ctx.runtimeErr(`${plugin.name}KeyOrValueRequired`)\n      }\n    }\n\n    for (const rawMod of rawModifiers) {\n      const [label, ...mod] = rawMod.split('.')\n      ctx.mods.set(camel(label), new Set(mod.map((t) => t.toLowerCase())))\n    }\n\n    const cleanup = plugin.onLoad(ctx)\n    if (cleanup) {\n      let cleanups = removals.get(el)\n      if (cleanups) {\n        cleanups.get(rawKey)?.()\n      } else {\n        cleanups = new Map()\n        removals.set(el, cleanups)\n      }\n      cleanups.set(rawKey, cleanup)\n    }\n  }\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe(mutations: MutationRecord[]) {\n  const ignore = `[${aliasify('ignore')}]`\n\n  for (const {\n    target,\n    type,\n    attributeName,\n    addedNodes,\n    removedNodes,\n  } of mutations) {\n    if (type === 'childList') {\n      for (const node of removedNodes) {\n        if (isHTMLOrSVG(node)) {\n          const cleanups = removals.get(node)\n          // If removals has el, delete it and run all cleanup functions\n          if (removals.delete(node)) {\n            for (const cleanup of cleanups!.values()) {\n              cleanup()\n            }\n            cleanups!.clear()\n          }\n        }\n      }\n\n      for (const node of addedNodes) {\n        if (isHTMLOrSVG(node)) {\n          applyEls([node])\n          applyEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n    } else if (type === 'attributes') {\n      // If el has a parent with data-ignore, skip it\n      if (isHTMLOrSVG(target) && !target.closest(ignore)) {\n        const key = camel(attributeName!.slice(5))\n        const value = target.getAttribute(attributeName!)\n        if (value === null) {\n          const cleanups = removals.get(target)\n          if (cleanups) {\n            cleanups.get(key)?.()\n            cleanups.delete(key)\n          }\n        } else {\n          applyAttributePlugin(target, key, value)\n        }\n      }\n    }\n  }\n}\n\nfunction generateReactiveExpression(\n  ctx: RuntimeContext,\n): RuntimeExpressionFunction {\n  let expr = ''\n\n  const attrPlugin = (ctx.plugin as AttributePlugin) || undefined\n\n  // plugin is guaranteed to be an attribute plugin\n  if (attrPlugin?.returnsValue) {\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n    //\n    // The iife support is (intentionally) limited. It only supports\n    // function and arrow syntax with no arguments, and no nested IIFEs.\n    //\n    // We also want to match the non delimiter part of statements\n    // note we only support ; statement delimiters:\n    //\n    // [^;]\n    //\n    const statementRe =\n      /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm\n    const statements = ctx.value.trim().match(statementRe)\n    if (statements) {\n      const lastIdx = statements.length - 1\n      const last = statements[lastIdx].trim()\n      if (!last.startsWith('return')) {\n        statements[lastIdx] = `return (${last});`\n      }\n      expr = statements.join(';\\n')\n    }\n  } else {\n    expr = ctx.value.trim()\n  }\n\n  expr = expr.replace(\n    /\\$([\\w.-]+(?:\\.[\\w.-]+)*?)(?=\\s|$|[^\\w.-])/g,\n    (match, signalName) => {\n      // If the signal name ends with a hyphen followed by a $, it's likely two separate signals\n      // So we should not include the trailing hyphen in this signal name\n      if (\n        signalName.endsWith('-') &&\n        match.length < expr.length &&\n        expr[expr.indexOf(match) + match.length] === '$'\n      ) {\n        signalName = signalName.slice(0, -1)\n        const parts = signalName.split('.')\n        return `${parts.reduce((acc: string, part: string) => `${acc}['${part}']`, '$')}-`\n      }\n\n      const parts = signalName.split('.')\n      return parts.reduce(\n        (acc: string, part: string) => `${acc}['${part}']`,\n        '$',\n      )\n    },\n  )\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  for (const match of expr.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = `dsEscaped${djb2(k)}`\n    escaped.set(v, k)\n    expr = expr.replace(DSP + k + DSS, v)\n  }\n\n  const nameGen = (prefix: string, name: string) => {\n    return `${prefix}${snake(name).replaceAll(/\\./g, '_')}`\n  }\n\n  // Replace any action calls\n  const actionsCalled = new Set<string>()\n  const actionsRe = RegExp(`@(${Object.keys(actions).join('|')})\\\\(`, 'gm')\n  const actionMatches = [...expr.matchAll(actionsRe)]\n  const actionNames = new Set<string>()\n  const actionFns = new Set<(...args: any[]) => any>()\n  if (actionMatches.length) {\n    const actionPrefix = `${DATASTAR}Act_`\n    for (const match of actionMatches) {\n      const actionName = match[1]\n      const action = actions[actionName]\n      if (!action) {\n        continue\n      }\n      actionsCalled.add(actionName)\n\n      const name = nameGen(actionPrefix, actionName)\n\n      // Add ctx to action calls\n      expr = expr.replace(`@${actionName}(`, `${name}(`)\n      actionNames.add(name)\n      actionFns.add((...args: any[]) => action.fn(ctx, ...args))\n    }\n  }\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    expr = expr.replace(k, v)\n  }\n\n  ctx.fnContent = expr\n\n  try {\n    const fn = Function(\n      'el',\n      '$',\n      ...(attrPlugin?.argNames || []),\n      ...actionNames,\n      expr,\n    )\n    return (...args: any[]) => {\n      try {\n        return fn(ctx.el, root, ...args, ...actionFns)\n      } catch (e: any) {\n        throw ctx.runtimeErr('ExecuteExpression', {\n          error: e.message,\n        })\n      }\n    }\n  } catch (error: any) {\n    throw ctx.runtimeErr('GenerateExpression', {\n      error: error.message,\n    })\n  }\n}\n\nfunction djb2(str: string) {\n  let hash = 5831\n  let i = str.length\n  while (i--) {\n    hash += (hash << 5) + str.charCodeAt(i)\n  }\n  return (hash >>> 0).toString(36)\n}\n", "// Icon: ion:eye\n// Slug: Access signals without subscribing to changes.\n// Description: Allows accessing signals without subscribing to their changes in expressions.\n\nimport type { ActionPlugin } from '../../engine/types'\n\nexport const Peek: ActionPlugin = {\n  type: 'action',\n  name: 'peek',\n  fn: ({ peek }, fn: () => any) => {\n    return peek(fn)\n  },\n}\n", "// Icon: ion:checkmark-round\n// Slug: Sets the value of all matching signals.\n// Description: Sets the value of all matching signals (or all signals if no filter is used) to the expression provided in the first argument.\n\nimport type {\n  ActionPlugin,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../engine/types'\nimport { updateLeaves } from '../../utils/paths'\n\nexport const SetAll: ActionPlugin = {\n  type: 'action',\n  name: 'setAll',\n  fn: (\n    { filtered, mergePatch, peek }: RuntimeContext,\n    value: any,\n    filter: SignalFilterOptions,\n  ) => {\n    peek(() => {\n      const masked = filtered(filter)\n      updateLeaves(masked, () => value)\n      mergePatch(masked)\n    })\n  },\n}\n", "// Icon: material-symbols:toggle-off\n// Slug: Toggles the value of all matching signals.\n// Description: Toggles the boolean value of all matching signals (or all signals if no filter is used).\n\nimport type {\n  ActionPlugin,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../engine/types'\nimport { updateLeaves } from '../../utils/paths'\n\nexport const ToggleAll: ActionPlugin = {\n  type: 'action',\n  name: 'toggleAll',\n  fn: (\n    { filtered, mergePatch, peek }: RuntimeContext,\n    filter: SignalFilterOptions,\n  ) => {\n    peek(() => {\n      const masked = filtered(filter)\n      updateLeaves(masked, (oldValue: any) => !oldValue)\n      mergePatch(masked)\n    })\n  },\n}\n", "// Icon: material-symbols:edit-attributes-outline\n// Slug: Syncs the value of an attribute with an expression.\n// Description: Sets the value of any HTML attribute to an expression, and keeps it in sync.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { kebab } from '../../utils/text'\n\nexport const Attr: AttributePlugin = {\n  type: 'attribute',\n  name: 'attr',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ el, effect, key, rx }) => {\n    const syncAttr = (key: string, val: any) => {\n      if (val === '' || val === true) {\n        el.setAttribute(key, '')\n      } else if (val === false || val === null || val === undefined) {\n        el.removeAttribute(key)\n      } else {\n        el.setAttribute(key, val)\n      }\n    }\n    if (key === '') {\n      const observer = new MutationObserver(() => {\n        observer.disconnect()\n        const obj = rx() as Record<string, any>\n        for (const [key, val] of Object.entries(obj)) {\n          syncAttr(key, val)\n        }\n        observer.observe(el, {\n          attributeFilter: Object.keys(obj),\n        })\n      })\n      const cleanup = effect(() => {\n        observer.disconnect()\n        const obj = rx() as Record<string, any>\n        for (const key in obj) {\n          syncAttr(key, obj[key])\n        }\n        observer.observe(el, {\n          attributeFilter: Object.keys(obj),\n        })\n      })\n\n      return () => {\n        observer.disconnect()\n        cleanup()\n      }\n    }\n    // Attributes are always kebab-case\n    const k = kebab(key)\n    const observer = new MutationObserver(() => {\n      observer.disconnect()\n      const value = rx<string>()\n      syncAttr(k, value)\n      observer.observe(el, {\n        attributeFilter: [value],\n      })\n    })\n    const cleanup = effect(() => {\n      observer.disconnect()\n      const value = rx<string>()\n      syncAttr(k, value)\n      observer.observe(el, {\n        attributeFilter: [value],\n      })\n    })\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Icon: akar-icons:link-chain\n// Slug: Creates a signal with two-way data binding.\n// Description: Creates a signal (if one doesn\u2019t already exist) and sets up two-way data binding between it and an element\u2019s value.\n\nimport { aliasify } from '../../engine/engine'\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst textType = /email|password|search|tel|text|url/\nconst numberType = /number|range/\n\nexport const Bind: AttributePlugin = {\n  type: 'attribute',\n  name: 'bind',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  shouldEvaluate: false,\n  onLoad: ({\n    el,\n    key,\n    mods,\n    value,\n    effect,\n    mergePatch,\n    runtimeErr,\n    getPath,\n    hasPath,\n  }) => {\n    const signalName = key ? modifyCasing(key, mods) : value\n\n    if (\n      (el instanceof HTMLInputElement && textType.test(el.type)) ||\n      el instanceof HTMLTextAreaElement\n    ) {\n      if (Array.isArray(hasPath(signalName) && getPath(signalName))) {\n        // For array signals, determine this input's index based on DOM order\n        const allBoundInputs = document.querySelectorAll(\n          `[${aliasify('bind')}-${key}],[${aliasify('bind')}=\"${value}\"]`,\n        )\n\n        let inputIndex = 0\n        const pathObj: Record<string, string> = {}\n        for (const input of allBoundInputs) {\n          if (!hasPath(`${signalName}.${inputIndex}`)) {\n            pathObj[`${signalName}.${inputIndex}`] = (\n              input as HTMLInputElement\n            ).value\n          }\n\n          if (el === input) {\n            break\n          }\n          inputIndex++\n        }\n        mergePatch(pathToObj({}, pathObj))\n\n        const syncSignal = () => {\n          mergePatch(\n            pathToObj({}, { [`${signalName}.${inputIndex}`]: el.value }),\n          )\n        }\n\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(\n          () => (el.value = getPath(signalName)[inputIndex]),\n        )\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      // Non-array signal handling\n      mergePatch(pathToObj({}, { [signalName]: el.value }), { ifMissing: true })\n\n      const syncSignal = () =>\n        mergePatch(pathToObj({}, { [signalName]: el.value }))\n      el.addEventListener('change', syncSignal)\n      el.addEventListener('input', syncSignal)\n\n      const cleanup = effect(() => (el.value = getPath(signalName)))\n\n      return () => {\n        cleanup()\n        el.removeEventListener('change', syncSignal)\n        el.removeEventListener('input', syncSignal)\n      }\n    }\n\n    if (el instanceof HTMLInputElement) {\n      if (el.type === 'checkbox') {\n        if (Array.isArray(hasPath(signalName) && getPath(signalName))) {\n          // For array signals, determine this input's index based on DOM order\n          const allBoundInputs = document.querySelectorAll(\n            `[${aliasify('bind')}-${key}],[${aliasify('bind')}=\"${value}\"]`,\n          )\n\n          let inputIndex = 0\n          const pathObj: Record<string, string | boolean> = {}\n          for (const input of allBoundInputs) {\n            if (!hasPath(`${signalName}.${inputIndex}`)) {\n              const val = input.getAttribute('value')\n              pathObj[`${signalName}.${inputIndex}`] = val\n                ? (input as HTMLInputElement).checked\n                  ? val\n                  : ''\n                : (input as HTMLInputElement).checked\n            }\n\n            if (el === input) {\n              break\n            }\n            inputIndex++\n          }\n          mergePatch(pathToObj({}, pathObj))\n\n          const syncSignal = () => {\n            const val = el.getAttribute('value')\n            mergePatch(\n              pathToObj(\n                {},\n                {\n                  [`${signalName}.${inputIndex}`]: val\n                    ? el.checked\n                      ? val\n                      : ''\n                    : el.checked,\n                },\n              ),\n            )\n          }\n\n          el.addEventListener('change', syncSignal)\n          el.addEventListener('input', syncSignal)\n\n          const cleanup = effect(() => {\n            const val = el.getAttribute('value')\n            el.checked = val\n              ? val === getPath(signalName)[inputIndex]\n              : getPath(signalName)[inputIndex]\n          })\n\n          return () => {\n            cleanup()\n            el.removeEventListener('change', syncSignal)\n            el.removeEventListener('input', syncSignal)\n          }\n        }\n\n        const val = el.getAttribute('value')\n        mergePatch(\n          pathToObj(\n            {},\n            { [signalName]: val ? (el.checked ? val : '') : el.checked },\n          ),\n        )\n\n        const syncSignal = () => {\n          const val = el.getAttribute('value')\n          mergePatch(\n            pathToObj(\n              {},\n              { [signalName]: val ? (el.checked ? val : '') : el.checked },\n            ),\n          )\n        }\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(() => {\n          const val = el.getAttribute('value')\n          el.checked = val ? val === getPath(signalName) : getPath(signalName)\n        })\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      if (el.type === 'radio') {\n        // Set up radio button name attribute if not present\n        if (!el.getAttribute('name')?.length) {\n          el.setAttribute('name', signalName)\n        }\n\n        mergePatch(pathToObj({}, { [signalName]: el.value }), {\n          ifMissing: true,\n        })\n\n        const syncSignal = () =>\n          el.checked && mergePatch(pathToObj({}, { [signalName]: el.value }))\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(\n          () => (el.checked = el.value === getPath(signalName)),\n        )\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      if (numberType.test(el.type)) {\n        mergePatch(pathToObj({}, { [signalName]: +el.value }), {\n          ifMissing: true,\n        })\n\n        const syncSignal = () =>\n          mergePatch(pathToObj({}, { [signalName]: +el.value }))\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(() => (el.value = getPath(signalName)))\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      if (el.type === 'file') {\n        const syncSignal = () => {\n          const files = [...(el.files || [])]\n          const allContents: string[] = []\n          const allMimes: string[] = []\n          const allNames: string[] = []\n          Promise.all(\n            files.map(\n              (f) =>\n                new Promise<void>((resolve) => {\n                  const reader = new FileReader()\n                  reader.onload = () => {\n                    if (typeof reader.result !== 'string') {\n                      throw runtimeErr('InvalidFileResultType', {\n                        resultType: typeof reader.result,\n                      })\n                    }\n                    const match = reader.result.match(dataURIRegex)\n                    if (!match?.groups) {\n                      throw runtimeErr('InvalidDataUri', {\n                        result: reader.result,\n                      })\n                    }\n                    allContents.push(match.groups.contents)\n                    allMimes.push(match.groups.mime)\n                    allNames.push(f.name)\n                  }\n                  reader.onloadend = () => resolve()\n                  reader.readAsDataURL(f)\n                }),\n            ),\n          ).then(() => {\n            mergePatch(\n              pathToObj(\n                {},\n                {\n                  [signalName]: allContents,\n                  [`${signalName}Mimes`]: allMimes,\n                  [`${signalName}Names`]: allNames,\n                },\n              ),\n            )\n          })\n        }\n\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        return () => {\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n      // else unsupported type\n    }\n\n    if (el instanceof HTMLSelectElement) {\n      if (el.multiple) {\n        // Multi-select handling\n        mergePatch(\n          pathToObj(\n            {},\n            {\n              [signalName]: [...el.selectedOptions].map(\n                (option) => option.value,\n              ),\n            },\n          ),\n          {\n            ifMissing: true,\n          },\n        )\n\n        const syncSignal = () =>\n          mergePatch(\n            pathToObj(\n              {},\n              {\n                [signalName]: [...el.selectedOptions].map(\n                  (option) => option.value,\n                ),\n              },\n            ),\n          )\n        el.addEventListener('change', syncSignal)\n        el.addEventListener('input', syncSignal)\n\n        const cleanup = effect(() => {\n          const signalValue: string[] = getPath(signalName)\n          for (const option of el.options) {\n            option.selected = signalValue.includes(option.value)\n          }\n        })\n\n        return () => {\n          cleanup()\n          el.removeEventListener('change', syncSignal)\n          el.removeEventListener('input', syncSignal)\n        }\n      }\n\n      // Single-select handling\n      mergePatch(\n        pathToObj(\n          {},\n          {\n            [signalName]: el.value,\n          },\n        ),\n        {\n          ifMissing: true,\n        },\n      )\n\n      const syncSignal = () =>\n        mergePatch(\n          pathToObj(\n            {},\n            {\n              [signalName]: el.value,\n            },\n          ),\n        )\n      el.addEventListener('change', syncSignal)\n      el.addEventListener('input', syncSignal)\n\n      const syncElement = () => (el.value = getPath(signalName))\n      const cleanup = effect(syncElement)\n\n      return () => {\n        cleanup()\n        el.removeEventListener('change', syncSignal)\n        el.removeEventListener('input', syncSignal)\n      }\n    }\n\n    mergePatch(pathToObj({}, { [signalName]: el.getAttribute('value') }), {\n      ifMissing: true,\n    })\n\n    const cleanup = effect(() => {\n      const newValue = getPath(signalName)\n      if (el.getAttribute('value') !== newValue) {\n        el.setAttribute('value', newValue)\n      }\n    })\n    const syncSignal = (evt: InputEvent | Event) =>\n      mergePatch(\n        pathToObj(\n          {},\n          { [signalName]: (evt.target as HTMLInputElement | null)?.value },\n        ),\n      )\n    el.addEventListener('change', syncSignal)\n    el.addEventListener('input', syncSignal)\n\n    return () => {\n      cleanup()\n      el.removeEventListener('change', syncSignal)\n      el.removeEventListener('input', syncSignal)\n    }\n  },\n}\n", "// Icon: ic:baseline-format-paint\n// Slug: Adds or removes a class based on an expression.\n// Description: Adds or removes a class to or from an element based on an expression.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { kebab, modifyCasing } from '../../utils/text'\n\nexport const Class: AttributePlugin = {\n  type: 'attribute',\n  name: 'class',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ key, el, effect, mods, rx }) => {\n    if (key) {\n      key = modifyCasing(kebab(key), mods)\n    }\n\n    const callback = () => {\n      observer.disconnect()\n\n      const classes = key\n        ? { [key]: rx<boolean>() }\n        : rx<Record<string, boolean>>()\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        if (classes[k]) {\n          for (const name of classNames) {\n            el.classList.add(name)\n          }\n        } else {\n          for (const name of classNames) {\n            el.classList.remove(name)\n          }\n        }\n      }\n\n      observer.observe(el, { attributeFilter: ['class'] })\n    }\n\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n\n      const classes = key\n        ? { [key]: rx<boolean>() }\n        : rx<Record<string, boolean>>()\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        for (const name of classNames) {\n          el.classList.remove(name)\n        }\n      }\n    }\n  },\n}\n", "// Icon: streamline-ultimate:wifi-signal-2\n// Slug: Creates a computed signal.\n// Description: Creates a signal that is computed based on an expression.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\n\nexport const Computed: AttributePlugin = {\n  type: 'attribute',\n  name: 'computed',\n  keyReq: 'must',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ key, mods, rx, computed, mergePatch }) => {\n    mergePatch(pathToObj({}, { [modifyCasing(key, mods)]: computed(rx) }))\n  },\n}\n", "// Icon: oui:security-signal\n// Slug: Executes an expression when signals change.\n// Description: Executes an expression on page load and whenever any signals in the expression change.\n\nimport type { AttributePlugin } from '../../engine/types'\n\nexport const Effect: AttributePlugin = {\n  type: 'attribute',\n  name: 'effect',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ effect, rx }) => effect(rx),\n}\n", "import { DATASTAR } from '../../engine/consts'\nimport type { HTMLOrSVG } from '../../engine/types'\n\nexport const DATASTAR_SSE_EVENT = `${DATASTAR}-sse`\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\nexport const RETRIES_FAILED = 'retrying'\n\nexport interface DatastarSSEEvent {\n  type: string\n  el: HTMLOrSVG\n  argsRaw: Record<string, string>\n}\n\nexport interface CustomEventMap {\n  [DATASTAR_SSE_EVENT]: CustomEvent<DatastarSSEEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\n\ndeclare global {\n  interface Document {\n    //adds definition to Document, but you can do the same with HTMLElement\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n  }\n}\n\nexport function datastarSSEEventWatcher(\n  eventType: string,\n  fn: (argsRaw: Record<string, string>) => void,\n) {\n  document.addEventListener(\n    DATASTAR_SSE_EVENT,\n    (event: CustomEvent<DatastarSSEEvent>) => {\n      if (event.detail.type === eventType) {\n        const { argsRaw } = event.detail\n        fn(argsRaw)\n      }\n    },\n  )\n}\n", "// Icon: streamline:signal-loading-remix\n// Slug: Creates an indicator for whether an SSE request is in flight.\n// Description: Creates a signal and sets its value to `true` while an SSE request request is in flight, otherwise `false`.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  FINISHED,\n  STARTED,\n} from '../backend/shared'\n\nexport const Indicator: AttributePlugin = {\n  type: 'attribute',\n  name: 'indicator',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  shouldEvaluate: false,\n  onLoad: ({ el, key, mods, mergePatch, value }) => {\n    const signalName = key ? modifyCasing(key, mods) : value\n\n    mergePatch(pathToObj({}, { [signalName]: false }), { ifMissing: true })\n\n    const watcher = ((event: CustomEvent<DatastarSSEEvent>) => {\n      const { type, el: elt } = event.detail\n      if (elt !== el) {\n        return\n      }\n      switch (type) {\n        case STARTED:\n          mergePatch(pathToObj({}, { [signalName]: true }))\n          break\n        case FINISHED:\n          mergePatch(pathToObj({}, { [signalName]: false }))\n          break\n      }\n    }) as EventListener\n    document.addEventListener(DATASTAR_SSE_EVENT, watcher)\n    return () => {\n      mergePatch(pathToObj({}, { [signalName]: false }))\n      document.removeEventListener(DATASTAR_SSE_EVENT, watcher)\n    }\n  },\n}\n", "// Icon: si:json-fill\n// Slug: Outputs a JSON stringified version of signals.\n// Description: Sets the text content of an element to a reactive JSON stringified version of signals.\n\nimport type { AttributePlugin, SignalFilterOptions } from '../../engine/types'\nimport { jsStrToObject } from '../../utils/text'\n\nexport const JsonSignals: AttributePlugin = {\n  type: 'attribute',\n  name: 'jsonSignals',\n  keyReq: 'denied',\n  onLoad: ({ el, effect, value, filtered, mods }) => {\n    const spaces = mods.has('terse') ? 0 : 2\n    let filters: SignalFilterOptions = {}\n    if (value) {\n      filters = jsStrToObject(value)\n    }\n\n    const callback = () => {\n      observer.disconnect()\n      el.textContent = JSON.stringify(filtered(filters), null, spaces)\n      observer.observe(el, {\n        childList: true,\n      })\n    }\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "export function tagToMs(args: Set<string>) {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return +arg.replace('ms', '')\n    }\n    if (arg.endsWith('s')) {\n      return +arg.replace('s', '') * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (_) {}\n  }\n  return 0\n}\n\nexport function tagHas(tags: Set<string>, tag: string, defaultValue = false) {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n\nexport function tagFirst(tags?: Set<string>, defaultValue = ''): string {\n  if (tags && tags.size > 0) {\n    for (const tag of tags) {\n      return tag\n    }\n  }\n  return defaultValue\n}\n", "import type { EventCallbackHandler, Modifiers } from '../engine/types'\nimport { tagHas, tagToMs } from './tags'\n\nexport function delay(\n  callback: EventCallbackHandler,\n  wait: number,\n): EventCallbackHandler {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport function debounce(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): EventCallbackHandler {\n  let timer = 0\n  return (...args: any[]) => {\n    timer && clearTimeout(timer)\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      timer && clearTimeout(timer)\n    }, wait)\n  }\n}\n\nexport function throttle(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): EventCallbackHandler {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      waiting = false\n      if (trailing) {\n        callback(...args)\n      }\n    }, wait)\n  }\n}\n\nexport function modifyTiming(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  const delayArgs = mods.get('delay')\n  if (delayArgs) {\n    const wait = tagToMs(delayArgs)\n    callback = delay(callback, wait)\n  }\n\n  const debounceArgs = mods.get('debounce')\n  if (debounceArgs) {\n    const wait = tagToMs(debounceArgs)\n    const leading = tagHas(debounceArgs, 'leading', false)\n    const trailing = !tagHas(debounceArgs, 'notrail', false)\n    callback = debounce(callback, wait, leading, trailing)\n  }\n\n  const throttleArgs = mods.get('throttle')\n  if (throttleArgs) {\n    const wait = tagToMs(throttleArgs)\n    const leading = !tagHas(throttleArgs, 'noleading', false)\n    const trailing = tagHas(throttleArgs, 'trail', false)\n    callback = throttle(callback, wait, leading, trailing)\n  }\n\n  return callback\n}\n", "import type { EventCallbackHandler, Modifiers } from '../engine/types'\n\nexport interface DocumentSupportingViewTransitionAPI {\n  startViewTransition(\n    updateCallback: () => Promise<void> | void,\n  ): IViewTransition\n}\n\nexport interface IViewTransition {\n  finished: Promise<void>\n  ready: Promise<void>\n  updateCallbackDone: Promise<void>\n  skipTransition(): void\n}\n\nexport const supportsViewTransitions = !!document.startViewTransition\n\nexport function modifyViewTransition(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  if (mods.has('viewtransition') && supportsViewTransitions) {\n    const cb = callback // I hate javascript\n    callback = (...args: any[]) =>\n      document.startViewTransition(() => cb(...args))\n  }\n\n  return callback\n}\n", "// Icon: material-symbols:mail\n// Slug: Attaches an event listener to an element.\n// Description: Attaches an event listener to an element, executing an expression whenever the event is triggered.\n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_PATCH_EVENT,\n} from '../../engine/types'\nimport { kebab, modifyCasing } from '../../utils/text'\nimport { modifyTiming } from '../../utils/timing'\nimport { modifyViewTransition } from '../../utils/view-transitions'\nimport { DATASTAR_SSE_EVENT } from '../backend/shared'\n\nexport const On: AttributePlugin = {\n  type: 'attribute',\n  name: 'on',\n  keyReq: 'must',\n  valReq: 'must',\n  argNames: ['evt'],\n  onLoad: (ctx) => {\n    const { el, key, mods, rx, startBatch, endBatch } = ctx\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n    let callback = (evt?: Event) => {\n      if (evt) {\n        if (mods.has('prevent')) {\n          evt.preventDefault()\n        }\n        if (mods.has('stop')) {\n          evt.stopPropagation()\n        }\n        // Return if not a trusted event, not a custom event and no `trusted` modifier exists\n        if (\n          !(evt.isTrusted || evt instanceof CustomEvent || mods.has('trusted'))\n        ) {\n          return\n        }\n        ctx.evt = evt\n      }\n      startBatch()\n      rx(evt)\n      endBatch()\n    }\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const evtListOpts: AddEventListenerOptions = {\n      capture: mods.has('capture'),\n      passive: mods.has('passive'),\n      once: mods.has('once'),\n    }\n    if (mods.has('outside')) {\n      target = document\n      const cb = callback\n      callback = (evt?: Event) => {\n        if (!el.contains(evt?.target as HTMLElement)) {\n          cb(evt)\n        }\n      }\n    }\n    // Default to kebab-case and allow modifying\n    let eventName = kebab(key)\n    eventName = modifyCasing(eventName, mods)\n    // Listen for Datastar events on the document\n    if (\n      eventName === DATASTAR_SSE_EVENT ||\n      eventName === DATASTAR_SIGNAL_PATCH_EVENT\n    ) {\n      target = document\n    }\n    // Prevent default on form submit events\n    if (el instanceof HTMLFormElement && eventName === 'submit') {\n      const cb = callback\n      callback = (evt?: Event) => {\n        evt?.preventDefault()\n        cb(evt)\n      }\n    }\n    target.addEventListener(eventName, callback, evtListOpts)\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n}\n", "// Icon: mdi-light:vector-intersection\n// Slug: Runs an expression on intersection.\n// Description: Runs an expression when the element intersects with the viewport.\n\nimport type { AttributePlugin, HTMLOrSVG } from '../../engine/types'\nimport { modifyTiming } from '../../utils/timing'\nimport { modifyViewTransition } from '../../utils/view-transitions'\n\nconst once = new WeakSet<HTMLOrSVG>()\n\nexport const OnIntersect: AttributePlugin = {\n  type: 'attribute',\n  name: 'onIntersect',\n  keyReq: 'denied',\n  onLoad: ({ el, mods, rx, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const options = { threshold: 0 }\n    if (mods.has('full')) {\n      options.threshold = 1\n    } else if (mods.has('half')) {\n      options.threshold = 0.5\n    }\n    let observer: IntersectionObserver | null = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting) {\n            callback()\n            if (observer && once.has(el)) {\n              observer.disconnect()\n            }\n          }\n        }\n      },\n      options,\n    )\n    observer.observe(el)\n    if (mods.has('once')) {\n      once.add(el)\n    }\n    return () => {\n      if (!mods.has('once')) {\n        once.delete(el)\n      }\n      if (observer) {\n        observer.disconnect()\n        observer = null\n      }\n    }\n  },\n}\n", "// Icon: material-symbols:timer-outline\n// Slug: Runs an expression at a regular interval.\n// Description: Runs an expression at a regular interval.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { tagHas, tagToMs } from '../../utils/tags'\nimport { modifyViewTransition } from '../../utils/view-transitions'\n\nexport const OnInterval: AttributePlugin = {\n  type: 'attribute',\n  name: 'onInterval',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ mods, rx, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let duration = 1000\n    const durationArgs = mods.get('duration')\n    if (durationArgs) {\n      duration = tagToMs(durationArgs)\n      const leading = tagHas(durationArgs, 'leading', false)\n      if (leading) {\n        callback()\n      }\n    }\n    const intervalId = setInterval(callback, duration)\n    return () => {\n      clearInterval(intervalId)\n    }\n  },\n}\n", "// Icon: material-symbols:timer-play-outline\n// Slug: Runs an expression when loaded into the DOM.\n// Description: Runs an expression when the element is loaded into the DOM.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { tagToMs } from '../../utils/tags'\nimport { delay } from '../../utils/timing'\nimport { modifyViewTransition } from '../../utils/view-transitions'\n\nexport const OnLoad: AttributePlugin = {\n  type: 'attribute',\n  name: 'onLoad',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ rx, mods, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let wait = 0\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      wait = tagToMs(delayArgs)\n    }\n    // Delay the callback regardless of whether the modifier is set so that other plugins are processed first.\n    callback = delay(callback, wait)\n    callback()\n  },\n}\n", "// Icon: material-symbols:change-circle-outline\n// Slug: Runs an expression when signals are patched.\n// Description: Runs an expression whenever one or more signals are patched.\n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_PATCH_EVENT,\n  type JSONPatch,\n  type SignalFilterOptions,\n} from '../../engine/types'\nimport { isEmpty } from '../../utils/paths'\nimport { jsStrToObject } from '../../utils/text'\nimport { modifyTiming } from '../../utils/timing'\n\nexport const OnSignalPatch: AttributePlugin = {\n  type: 'attribute',\n  name: 'onSignalPatch',\n  valReq: 'must',\n  argNames: ['patch'],\n  returnsValue: true,\n  onLoad: ({\n    el,\n    key,\n    mods,\n    plugin,\n    rx,\n    filtered,\n    runtimeErr,\n    startBatch,\n    endBatch,\n  }) => {\n    // Throw an error if the key exists and is not `filter`\n    if (!!key && key !== 'filter') {\n      throw runtimeErr(`${plugin.name}KeyNotAllowed`)\n    }\n\n    // Look for data-on-signal-patch-filter data attribute\n    const filtersRaw = el.getAttribute('data-on-signal-patch-filter')\n    let filters: SignalFilterOptions = {}\n    if (filtersRaw) {\n      filters = jsStrToObject(filtersRaw)\n    }\n\n    const callback: EventListener = modifyTiming(\n      (evt: CustomEvent<JSONPatch>) => {\n        const watched = filtered(filters, evt.detail)\n        if (!isEmpty(watched)) {\n          startBatch()\n          rx(watched)\n          endBatch()\n        }\n      },\n      mods,\n    )\n\n    document.addEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    return () => {\n      document.removeEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    }\n  },\n}\n", "// Icon: mdi:cursor-pointer\n// Slug: Creates a reference to an element.\n// Description: Creates a new signal that is a reference to the element on which the data attribute is placed.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n  type: 'attribute',\n  name: 'ref',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  shouldEvaluate: false,\n  onLoad: ({ el, key, mods, value, mergePatch }) => {\n    const signalName = key ? modifyCasing(key, mods) : value\n\n    mergePatch(pathToObj({}, { [signalName]: el }))\n  },\n}\n", "// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Shows or hides an element.\n// Description: Shows or hides an element based on whether an expression evaluates to `true` or `false`.\n\nimport type { AttributePlugin } from '../../engine/types'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nexport const Show: AttributePlugin = {\n  type: 'attribute',\n  name: 'show',\n  keyReq: 'denied',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      const shouldShow = rx()\n      if (shouldShow) {\n        if (el.style.display === NONE) el.style.removeProperty(DISPLAY)\n      } else {\n        el.style.setProperty(DISPLAY, NONE)\n      }\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "// Icon: streamline:wifi-signal-full-remix\n// Slug: Patches signals into the existing signals.\n// Description: Patches (adds, updates or removes) one or more signals into the existing signals.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: 'attribute',\n  name: 'signals',\n  returnsValue: true,\n  onLoad: ({ key, mods, rx, mergePatch }) => {\n    const ifMissing = mods.has('ifmissing')\n\n    if (key) {\n      key = modifyCasing(key, mods)\n      mergePatch(pathToObj({}, { [key]: rx() }), { ifMissing })\n    } else {\n      const patch = rx<Record<string, any>>()\n      const pathObj: Record<string, any> = {}\n      for (const key in patch) {\n        pathObj[key] = patch[key]\n      }\n      mergePatch(pathToObj({}, pathObj), { ifMissing })\n    }\n  },\n}\n", "// Icon: icon-park-outline:text\n// Slug: Binds the text content of an element.\n// Description: Binds the text content of an element to an expression.\n\nimport type { AttributePlugin } from '../../engine/types'\n\nexport const Text: AttributePlugin = {\n  type: 'attribute',\n  name: 'text',\n  keyReq: 'denied',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      el.textContent = `${rx()}`\n      observer.observe(el, { childList: true })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n", "import {\n  DATASTAR,\n  DATASTAR_REQUEST,\n  DefaultSseRetryDurationMs,\n  EventTypePatchElements,\n  EventTypePatchSignals,\n} from '../../../engine/consts'\n// Factory for creating HTTP method action plugins\nimport type {\n  ActionPlugin,\n  HTMLOrSVG,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../../engine/types'\nimport { kebab } from '../../../utils/text'\nimport {\n  DATASTAR_SSE_EVENT,\n  type DatastarSSEEvent,\n  ERROR,\n  FINISHED,\n  RETRIES_FAILED,\n  RETRYING,\n  STARTED,\n} from '../shared'\n\n// Global store for active SSE controllers per element\nconst activeSSEControllers = new WeakMap<HTMLOrSVG, AbortController>()\n\n// Helper to create HTTP method plugins with consistent structure\nexport const createHttpMethod = (\n  name: string,\n  method: string,\n): ActionPlugin => ({\n  type: 'action',\n  name,\n  fn: async (ctx, url: string, args: FetchArgs) => {\n    const { el } = ctx\n\n    // Abort any existing controller for this element\n    activeSSEControllers.get(el)?.abort()\n\n    // Create new controller\n    const controller = new AbortController()\n    activeSSEControllers.set(el, controller)\n\n    try {\n      // Pass the abort signal to sse\n      await sse(ctx, method, url, args, controller.signal)\n    } finally {\n      // Clean up: remove this controller if it's still the active one\n      if (activeSSEControllers.get(el) === controller) {\n        activeSSEControllers.delete(el)\n      }\n    }\n  },\n})\n\nconst dispatchSSE = (\n  type: string,\n  el: HTMLOrSVG,\n  argsRaw: Record<string, string>,\n) =>\n  document.dispatchEvent(\n    new CustomEvent<DatastarSSEEvent>(DATASTAR_SSE_EVENT, {\n      detail: { type, el, argsRaw },\n    }),\n  )\n\nconst isWrongContent = (err: any) => `${err}`.includes('text/event-stream')\n\ntype ResponseOverrides =\n  | {\n      selector?: string\n      mode?: string\n      useViewTransition?: boolean\n    }\n  | {\n      onlyIfMissing?: boolean\n    }\n\nexport type FetchArgs = {\n  headers?: Record<string, string>\n  openWhenHidden?: boolean\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  responseOverrides?: ResponseOverrides\n  contentType?: 'json' | 'form'\n  filterSignals?: SignalFilterOptions\n  selector?: string\n}\n\nexport const sse = async (\n  { el, evt, filtered, runtimeErr }: RuntimeContext,\n  method: string,\n  url: string,\n  {\n    selector,\n    headers: userHeaders,\n    contentType = 'json',\n    filterSignals = { include: /.*/, exclude: /(^|\\.)_/ },\n    openWhenHidden = false,\n    retryInterval = DefaultSseRetryDurationMs,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n  }: FetchArgs = {},\n  abort?: AbortSignal,\n) => {\n  const action = method.toLowerCase()\n  let cleanupFn = () => {}\n  try {\n    if (!url?.length) {\n      throw runtimeErr('SseNoUrlProvided', { action })\n    }\n\n    const initialHeaders: Record<string, any> = {\n      Accept: 'text/event-stream, text/html, application/json',\n      [DATASTAR_REQUEST]: true,\n    }\n    if (contentType === 'json') {\n      initialHeaders['Content-Type'] = 'application/json'\n    }\n    const headers = Object.assign({}, initialHeaders, userHeaders)\n\n    // We ignore the content-type header if using form data\n    // if missing the boundary will be set automatically\n\n    const req: FetchEventSourceInit = {\n      method,\n      headers,\n      openWhenHidden,\n      retryInterval,\n      retryScaler,\n      retryMaxWaitMs,\n      retryMaxCount,\n      signal: abort,\n      onopen: async (response: Response) => {\n        if (response.status >= 400)\n          dispatchSSE(ERROR, el, { status: response.status.toString() })\n      },\n      onmessage: (evt) => {\n        if (!evt.event.startsWith(DATASTAR)) return\n        const type = evt.event\n        const argsRawLines: Record<string, string[]> = {}\n\n        for (const line of evt.data.split('\\n')) {\n          const i = line.indexOf(' ')\n          const k = line.slice(0, i)\n          const v = line.slice(i + 1)\n          ;(argsRawLines[k] ||= []).push(v)\n        }\n\n        const argsRaw = Object.fromEntries(\n          Object.entries(argsRawLines).map(([k, v]) => [k, v.join('\\n')]),\n        )\n\n        dispatchSSE(type, el, argsRaw)\n      },\n      onerror: (error) => {\n        if (isWrongContent(error)) {\n          // don't retry if the content-type is wrong\n          throw runtimeErr('InvalidContentType', { url })\n        }\n        // do nothing and it will retry\n        if (error) {\n          console.error(error.message)\n          dispatchSSE(RETRYING, el, { message: error.message })\n        }\n      },\n    }\n\n    const urlInstance = new URL(url, window.location.href)\n    const queryParams = new URLSearchParams(urlInstance.search)\n\n    if (contentType === 'json') {\n      const res = JSON.stringify(filtered(filterSignals))\n      if (method === 'GET') {\n        queryParams.set(DATASTAR, res)\n      } else {\n        req.body = res\n      }\n    } else if (contentType === 'form') {\n      const formEl = (\n        selector ? document.querySelector(selector) : el.closest('form')\n      ) as HTMLFormElement\n      if (!formEl) {\n        throw runtimeErr(\n          selector ? 'SseFormNotFound' : 'SseClosestFormNotFound',\n          { action, selector },\n        )\n      }\n\n      // Validate the form\n      if (!formEl.checkValidity()) {\n        formEl.reportValidity()\n        cleanupFn()\n        return\n      }\n\n      // Collect the form data\n\n      const formData = new FormData(formEl)\n      let submitter = el as HTMLElement | null\n\n      if (el === formEl && evt instanceof SubmitEvent) {\n        // Get the submitter from the event\n        submitter = evt.submitter\n      } else {\n        // Prevent the form being submitted\n        const preventDefault = (evt: Event) => evt.preventDefault()\n        formEl.addEventListener('submit', preventDefault)\n        cleanupFn = () => formEl.removeEventListener('submit', preventDefault)\n      }\n\n      // Append the value of the form submitter if it is a button with a name\n      if (submitter instanceof HTMLButtonElement) {\n        const name = submitter.getAttribute('name')\n        if (name) formData.append(name, submitter.value)\n      }\n\n      const multipart = formEl.getAttribute('enctype') === 'multipart/form-data'\n      // Leave the `Content-Type` header empty for multipart encoding so the browser can set it automatically with the correct boundary\n      if (!multipart) {\n        headers['Content-Type'] = 'application/x-www-form-urlencoded'\n      }\n\n      const formParams = new URLSearchParams(formData as any)\n      if (method === 'GET') {\n        for (const [key, value] of formParams) {\n          queryParams.append(key, value)\n        }\n      } else if (multipart) {\n        // Upload progress events are only available for: HTTPS connections (required for streaming uploads) with Multipart form data uploads\n        if (__USE_UPLOAD_PROGRESS__ && urlInstance.protocol === 'https:') {\n          const boundary = `----FormDataBoundary${Math.random().toString(36).substring(2, 11)}`\n          const encoder = new TextEncoder()\n\n          // Calculate total size\n          let total = 0\n          const parts: Array<{ field: string; value: string | File }> = []\n\n          for (const [name, value] of formData) {\n            parts.push({ field: name, value })\n            total += encoder.encode(`--${boundary}\\r\\n`).byteLength\n\n            if (value instanceof File) {\n              total += encoder.encode(\n                `Content-Disposition: form-data; name=\"${name}\"; filename=\"${value.name}\"\\r\\n` +\n                  `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`,\n              ).byteLength\n              total += value.size + 2\n            } else {\n              total += encoder.encode(\n                `Content-Disposition: form-data; name=\"${name}\"\\r\\n\\r\\n${value}\\r\\n`,\n              ).byteLength\n            }\n          }\n          total += encoder.encode(`--${boundary}--\\r\\n`).byteLength\n\n          let loaded = 0\n\n          req.body = new ReadableStream({\n            async start(controller) {\n              const write = (data: Uint8Array) => {\n                controller.enqueue(data)\n                loaded += data.byteLength\n\n                const progress = Math.round((loaded / total) * 100)\n                dispatchSSE('upload-progress', el, {\n                  progress: progress.toString(),\n                  loaded: loaded.toString(),\n                  total: total.toString(),\n                })\n              }\n\n              dispatchSSE('upload-progress', el, {\n                progress: '0',\n                loaded: '0',\n                total: total.toString(),\n              })\n\n              try {\n                for (const { field, value } of parts) {\n                  write(encoder.encode(`--${boundary}\\r\\n`))\n\n                  if (value instanceof File) {\n                    write(\n                      encoder.encode(\n                        `Content-Disposition: form-data; name=\"${field}\"; filename=\"${value.name}\"\\r\\n` +\n                          `Content-Type: ${value.type || 'application/octet-stream'}\\r\\n\\r\\n`,\n                      ),\n                    )\n\n                    const reader = value.stream().getReader()\n                    try {\n                      while (true) {\n                        const { done, value: chunk } = await reader.read()\n                        if (done) break\n                        write(chunk)\n                      }\n                    } finally {\n                      reader.releaseLock()\n                    }\n                    write(encoder.encode('\\r\\n'))\n                  } else {\n                    write(\n                      encoder.encode(\n                        `Content-Disposition: form-data; name=\"${field}\"\\r\\n\\r\\n${value}\\r\\n`,\n                      ),\n                    )\n                  }\n                }\n\n                write(encoder.encode(`--${boundary}--\\r\\n`))\n\n                if (loaded < total) {\n                  dispatchSSE('upload-progress', el, {\n                    progress: '100',\n                    loaded: total.toString(),\n                    total: total.toString(),\n                  })\n                }\n\n                controller.close()\n              } catch (error) {\n                controller.error(error)\n              }\n            },\n          })\n\n          // Override content-type header with the boundary\n          headers['Content-Type'] = `multipart/form-data; boundary=${boundary}`\n          // Set duplex mode for streaming uploads\n          ;(req as any).duplex = 'half'\n        } else {\n          req.body = formData\n        }\n      } else {\n        req.body = formParams\n      }\n    } else {\n      throw runtimeErr('SseInvalidContentType', { action, contentType })\n    }\n\n    dispatchSSE(STARTED, el, {})\n    urlInstance.search = queryParams.toString()\n\n    try {\n      await fetchEventSource(urlInstance.toString(), el, req)\n    } catch (error) {\n      if (!isWrongContent(error)) {\n        throw runtimeErr('SseFetchFailed', { method, url, error })\n      }\n      // exit gracefully and do nothing if the content-type is wrong\n      // this can happen if the client is sending a request\n      // where no response is expected, and they haven\u2019t\n      // set the content-type to text/event-stream\n    }\n  } finally {\n    dispatchSSE(FINISHED, el, {})\n    cleanupFn()\n  }\n}\n\n// Below originally from https://github.com/Azure/fetch-event-source/blob/main/LICENSE\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\n\ninterface EventSourceMessage {\n  id: string\n  event: string\n  data: string\n  retry?: number\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(\n  stream: ReadableStream<Uint8Array>,\n  onChunk: (arr: Uint8Array) => void,\n): Promise<void> {\n  const reader = stream.getReader()\n  let result = await reader.read()\n  while (!result.done) {\n    onChunk(result.value)\n    result = await reader.read()\n  }\n}\n\nfunction getLines(onLine: (line: Uint8Array, fieldLength: number) => void) {\n  let buffer: Uint8Array | undefined\n  let position: number // current read position\n  let fieldLength: number // length of the `field` portion of the line\n  let discardTrailingNewline = false\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array) {\n    if (!buffer) {\n      buffer = arr\n      position = 0\n      fieldLength = -1\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr)\n    }\n\n    const bufLength = buffer.length\n    let lineStart = 0 // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10) lineStart = ++position // skip to next char\n        discardTrailingNewline = false\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1 // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58: // :\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart\n            }\n            break\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          // biome-ignore lint/suspicious/noFallthroughSwitchClause: intentional fallthrough for CR to LF\n          case 13: // \\r\n            discardTrailingNewline = true\n          case 10: // \\n\n            lineEnd = position\n            break\n        }\n      }\n\n      if (lineEnd === -1) break // Wait for the next arr and then continue parsing\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)\n      lineStart = position // we're now on the next line\n      fieldLength = -1\n    }\n\n    if (lineStart === bufLength)\n      buffer = undefined // we've finished reading it\n    else if (lineStart) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart)\n      position -= lineStart\n    }\n  }\n}\n\nfunction getMessages(\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void,\n) {\n  let message = newMessage()\n  const decoder = new TextDecoder()\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(line: Uint8Array, fieldLength: number) {\n    if (!line.length) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message)\n      message = newMessage()\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength))\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1)\n      const value = decoder.decode(line.subarray(valueOffset))\n\n      switch (field) {\n        case 'data':\n          message.data = message.data ? `${message.data}\\n${value}` : value\n          break\n        case 'event':\n          message.event = value\n          break\n        case 'id':\n          onId((message.id = value))\n          break\n        case 'retry': {\n          const retry = +value\n          if (!Number.isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry))\n          }\n          break\n        }\n      }\n    }\n  }\n}\n\nconst concat = (a: Uint8Array, b: Uint8Array) => {\n  const res = new Uint8Array(a.length + b.length)\n  res.set(a)\n  res.set(b, a.length)\n  return res\n}\n\nconst newMessage = (): EventSourceMessage => ({\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  data: '',\n  event: '',\n  id: '',\n  retry: undefined,\n})\n\ninterface FetchEventSourceInit extends RequestInit {\n  headers?: Record<string, string>\n  onopen?: (response: Response) => Promise<void>\n  onmessage?: (ev: EventSourceMessage) => void\n  onclose?: () => void\n  onerror?: (err: any) => number | null | undefined | void\n  openWhenHidden?: boolean\n  fetch?: typeof fetch\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  overrides?: ResponseOverrides\n}\n\nfunction fetchEventSource(\n  input: RequestInfo,\n  el: HTMLOrSVG,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retryInterval = 1_000,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    overrides,\n    ...rest\n  }: FetchEventSourceInit,\n) {\n  return new Promise<void>((resolve, reject) => {\n    // make a copy of the input headers since we may modify it below:\n    const headers: Record<string, string> = {\n      accept: 'text/event-stream',\n      ...inputHeaders,\n    }\n\n    let curRequestController: AbortController\n    function onVisibilityChange() {\n      curRequestController.abort() // close existing request on every visibility change\n      if (!document.hidden) create() // page is now visible again, recreate request.\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange)\n    }\n\n    let retryTimer = 0\n    function dispose() {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      window.clearTimeout(retryTimer)\n      curRequestController.abort()\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose()\n      resolve() // don't waste time constructing/logging errors\n    })\n\n    const fetch = inputFetch || window.fetch\n    const onopen = inputOnOpen || (() => {})\n\n    let retries = 0\n    let baseRetryInterval = retryInterval\n    async function create() {\n      curRequestController = new AbortController()\n      try {\n        const response = await fetch(input, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal,\n        })\n\n        // on successful connection, reset the retry logic\n        retries = 0\n        retryInterval = baseRetryInterval\n\n        await onopen(response)\n\n        const dispatchNonSSE = async (\n          dispatchType: string,\n          response: Response,\n          name: string,\n          overrides?: ResponseOverrides,\n          ...argNames: string[]\n        ) => {\n          const argsRaw: Record<string, string> = {\n            [name]: await response.text(),\n          }\n          for (const n of argNames) {\n            let v = response.headers.get(`datastar-${kebab(n)}`)\n            if (overrides) {\n              const o = (overrides as any)[n]\n              if (o) v = typeof o === 'string' ? o : JSON.stringify(o)\n            }\n            if (v) argsRaw[n] = v\n          }\n\n          dispatchSSE(dispatchType, el, argsRaw)\n          dispose()\n        }\n\n        const ct = response.headers.get('Content-Type')\n        if (ct?.includes('text/html')) {\n          return await dispatchNonSSE(\n            EventTypePatchElements,\n            response,\n            'elements',\n            overrides,\n            'selector',\n            'mode',\n            'useViewTransition',\n          )\n        }\n\n        if (ct?.includes('application/json')) {\n          return await dispatchNonSSE(\n            EventTypePatchSignals,\n            response,\n            'signals',\n            overrides,\n            'onlyIfMissing',\n          )\n        }\n\n        if (ct?.includes('text/javascript')) {\n          const script = document.createElement('script')\n          const scriptAttributesHeader = response.headers.get(\n            'datastar-script-attributes',\n          )\n\n          if (scriptAttributesHeader) {\n            for (const [name, value] of Object.entries(\n              JSON.parse(scriptAttributesHeader),\n            )) {\n              script.setAttribute(name, value as string)\n            }\n          }\n          script.textContent = await response.text()\n          document.head.appendChild(script)\n          dispose()\n          return\n        }\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // signals the id and send it back on the next retry:\n                  headers['last-event-id'] = id\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers['last-event-id']\n                }\n              },\n              (retry) => {\n                baseRetryInterval = retryInterval = retry\n              },\n              onmessage,\n            ),\n          ),\n        )\n\n        onclose?.()\n        dispose()\n        resolve()\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          // if we haven\u2019t aborted the request ourselves:\n          try {\n            // check if we need to retry:\n            const interval: any = onerror?.(err) || retryInterval\n            window.clearTimeout(retryTimer)\n            retryTimer = window.setTimeout(create, interval)\n            retryInterval = Math.min(\n              retryInterval * retryScaler,\n              retryMaxWaitMs,\n            ) // exponential backoff\n            if (++retries >= retryMaxCount) {\n              dispatchSSE(RETRIES_FAILED, el, {})\n              // we should not retry anymore:\n              dispose()\n              reject('Max retries reached.') // Max retries reached, check your server or network connection\n            } else {\n              console.error(\n                `Datastar failed to reach ${input.toString()} retrying in ${interval}ms.`,\n              )\n            }\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose()\n            reject(innerErr)\n          }\n        }\n      }\n    }\n\n    create()\n  })\n}\n", "// Icon: material-symbols:delete-outline\n// Slug: Sends a `DELETE` request.\n// Description: Sends a `DELETE` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const DELETE = createHttpMethod('delete', 'DELETE')\n", "// Icon: ic:baseline-get-app\n// Slug: Sends a `GET` request.\n// Description: Sends a `GET` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const GET = createHttpMethod('get', 'GET')\n", "// Icon: fluent:patch-24-filled\n// Slug: Sends a `PATCH` request.\n// Description: Sends a `PATCH` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const PATCH = createHttpMethod('patch', 'PATCH')\n", "// Icon: ri:signpost-fill\n// Slug: Sends a `POST` request.\n// Description: Sends a `POST` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const POST = createHttpMethod('post', 'POST')\n", "// Icon: material-symbols:arrows-input\n// Slug: Sends a `PUT` request.\n// Description: Sends a `PUT` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const PUT = createHttpMethod('put', 'PUT')\n", "// Icon: material-symbols:cloud-download\n// Slug: Patches elements into the DOM.\n// Description: Patches elements into the DOM.\n\nimport {\n  DefaultElementPatchMode,\n  ElementPatchModeAfter,\n  ElementPatchModeAppend,\n  ElementPatchModeBefore,\n  ElementPatchModeInner,\n  ElementPatchModeOuter,\n  ElementPatchModePrepend,\n  ElementPatchModeRemove,\n  ElementPatchModeReplace,\n  EventTypePatchElements,\n} from '../../../engine/consts'\nimport { aliasify } from '../../../engine/engine'\nimport { initErr } from '../../../engine/errors'\nimport type {\n  HTMLOrSVG,\n  InitContext,\n  WatcherPlugin,\n} from '../../../engine/types'\nimport { kebab } from '../../../utils/text'\nimport { supportsViewTransitions } from '../../../utils/view-transitions'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const PatchElements: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchElements,\n  async onGlobalInit(ctx) {\n    datastarSSEEventWatcher(EventTypePatchElements, (args) =>\n      onPatchElements(ctx, args),\n    )\n  },\n}\n\nfunction onPatchElements(\n  ctx: InitContext,\n  {\n    elements,\n    selector,\n    mode = DefaultElementPatchMode,\n    useViewTransition,\n  }: Record<string, string>,\n) {\n  if (mode === ElementPatchModeRemove && selector) {\n    const targets = document.querySelectorAll(selector)\n    if (!targets.length) {\n      throw initErr('NoTargetsFound', ctx, {\n        selectorOrId: selector,\n      })\n    }\n\n    if (useViewTransition && supportsViewTransitions) {\n      document.startViewTransition(() => {\n        for (const target of targets) {\n          target.remove()\n        }\n      })\n    } else {\n      for (const target of targets) {\n        target.remove()\n      }\n    }\n  } else {\n    const template = document.createElement('template')\n    template.innerHTML = elements\n\n    for (const node of [...template.content.childNodes]) {\n      const type = node.nodeType\n      if (type !== 1) {\n        if (type === 3 && !node.nodeValue!.trim()) {\n          continue\n        }\n        throw initErr('NoElementsFound', ctx)\n      }\n\n      const selectorOrId = selector || `#${(node as Element).id}`\n      const targets = document.querySelectorAll(selectorOrId)\n      if (!targets.length) {\n        throw initErr('NoTargetsFound', ctx, {\n          selectorOrId,\n        })\n      }\n\n      if (useViewTransition && supportsViewTransitions) {\n        document.startViewTransition(() =>\n          applyToTargets(ctx, mode, node as HTMLOrSVG, targets),\n        )\n      } else {\n        applyToTargets(ctx, mode, node as HTMLOrSVG, targets)\n      }\n    }\n  }\n}\n\nconst scripts = new WeakSet<HTMLScriptElement>()\nfunction execute(target: Element): void {\n  const elScripts =\n    target instanceof HTMLScriptElement\n      ? [target]\n      : target.querySelectorAll('script')\n  for (const old of elScripts) {\n    if (!scripts.has(old)) {\n      const script = document.createElement('script')\n      for (const { name, value } of old.attributes) {\n        script.setAttribute(name, value)\n      }\n      script.text = old.text\n      old.replaceWith(script)\n      scripts.add(script)\n    }\n  }\n}\n\nfunction applyToTargets(\n  ctx: InitContext,\n  mode: string,\n  element: HTMLOrSVG,\n  capturedTargets: NodeListOf<Element>,\n) {\n  for (const target of capturedTargets) {\n    if (mode === ElementPatchModeRemove) {\n      target.remove()\n    } else if (\n      mode === ElementPatchModeOuter ||\n      mode === ElementPatchModeInner\n    ) {\n      morph(target, element, mode)\n      execute(target)\n    } else {\n      const cloned = element.cloneNode(true) as Element\n      if (mode === ElementPatchModeReplace) {\n        target.replaceWith(cloned)\n      } else if (mode === ElementPatchModePrepend) {\n        target.prepend(cloned)\n      } else if (mode === ElementPatchModeAppend) {\n        target.append(cloned)\n      } else if (mode === ElementPatchModeBefore) {\n        target.before(cloned)\n      } else if (mode === ElementPatchModeAfter) {\n        target.after(cloned)\n      } else {\n        throw initErr('InvalidPatchMode', ctx, { mode })\n      }\n      execute(cloned)\n    }\n  }\n}\n\nconst oldIdTagNameMap = new Map<string, string>()\nconst ctxIdMap = new Map<Node, Set<string>>()\nconst ctxPersistentIds = new Set<string>()\nconst duplicateIds = new Set<string>()\nconst ctxPantry = document.createElement('div')\nctxPantry.hidden = true\n\nfunction morph(\n  oldElt: Element,\n  newElt: Element,\n  mode: typeof ElementPatchModeInner | typeof ElementPatchModeOuter,\n): void {\n  const ignore = aliasify('ignore-morph')\n  if (\n    (oldElt.hasAttribute(ignore) && newElt.hasAttribute(ignore)) ||\n    oldElt.parentElement?.closest(`[${ignore}]`)\n  ) {\n    return\n  }\n\n  const normalizedElt = document.createElement('div')\n  normalizedElt.append(newElt as Element)\n  document.body.insertAdjacentElement('afterend', ctxPantry)\n\n  // Computes the set of IDs that persist between the two contents excluding duplicates\n  const oldIdElements = oldElt.querySelectorAll('[id]')\n  for (const { id, tagName } of oldIdElements) {\n    if (oldIdTagNameMap.has(id)) {\n      duplicateIds.add(id)\n    } else {\n      oldIdTagNameMap.set(id, tagName)\n    }\n  }\n  if (oldElt.id) {\n    if (oldIdTagNameMap.has(oldElt.id)) {\n      duplicateIds.add(oldElt.id)\n    } else {\n      oldIdTagNameMap.set(oldElt.id, oldElt.tagName)\n    }\n  }\n\n  ctxPersistentIds.clear()\n  const newIdElements = normalizedElt.querySelectorAll('[id]')\n  for (const { id, tagName } of newIdElements) {\n    if (ctxPersistentIds.has(id)) {\n      duplicateIds.add(id)\n    } else if (oldIdTagNameMap.get(id) === tagName) {\n      ctxPersistentIds.add(id)\n    }\n  }\n\n  oldIdTagNameMap.clear()\n\n  for (const id of duplicateIds) {\n    ctxPersistentIds.delete(id)\n  }\n\n  duplicateIds.clear()\n\n  // Computes a map of nodes to all IDs contained within that node (inclusive of the node).\n  // This map can be used to ask if two nodes have intersecting sets of IDs,\n  // which allows for a looser definition of \"matching\" than traditional ID matching,\n  // and allows child nodes to contribute to a parent nodes matching.\n  // const idMap = new Map<Node, Set<string>>()\n  ctxIdMap.clear()\n\n  populateIdMapWithTree(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    oldIdElements,\n  )\n  populateIdMapWithTree(normalizedElt, newIdElements)\n\n  morphChildren(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    normalizedElt,\n    mode === 'outer' ? (oldElt as Node) : null,\n    oldElt.nextSibling,\n  )\n\n  ctxPantry.remove()\n}\n\n// This is the core algorithm for matching up children.\n// The idea is to use ID sets to try to match up nodes as faithfully as possible.\n// We greedily match, which allows us to keep the algorithm fast,\n// but by using ID sets, we are able to better match up with content deeper in the DOM.\nfunction morphChildren(\n  oldParent: Element, // the old content that we are merging the new content into\n  newParent: Element, // the parent element of the new content\n  insertionPoint: Node | null = null, // // the point in the DOM we start morphing at (defaults to first child)\n  endPoint: Node | null = null, // the point in the DOM we stop morphing at (defaults to after last child)\n): void {\n  // normalize\n  if (\n    oldParent instanceof HTMLTemplateElement &&\n    newParent instanceof HTMLTemplateElement\n  ) {\n    // we can pretend the DocumentElement is an Element\n    oldParent = oldParent.content as unknown as Element\n    newParent = newParent.content as unknown as Element\n  }\n  insertionPoint ??= oldParent.firstChild\n\n  // run through all the new content\n  for (const newChild of newParent.childNodes) {\n    // once we reach the end of the old parent content skip to the end and insert the rest\n    if (insertionPoint && insertionPoint !== endPoint) {\n      const bestMatch = findBestMatch(newChild, insertionPoint, endPoint)\n      if (bestMatch) {\n        // if the node to morph is not at the insertion point then remove/move up to it\n        if (bestMatch !== insertionPoint) {\n          let cursor: Node | null = insertionPoint\n          // Remove nodes between the start and end nodes\n          while (cursor && cursor !== bestMatch) {\n            const tempNode = cursor\n            cursor = cursor.nextSibling\n            removeNode(tempNode)\n          }\n        }\n        morphNode(bestMatch, newChild)\n        insertionPoint = bestMatch.nextSibling\n        continue\n      }\n    }\n\n    // @ts-ignore\n    const ncId = newChild.id\n    // if the matching node is elsewhere in the original content\n    if (newChild instanceof Element && ctxPersistentIds.has(ncId)) {\n      // move it and all its children here and morph, will always be found\n      // Search for an element by ID within the document and pantry, and move it using moveBefore.\n\n      const movedChild = window[ncId] as unknown as Element\n\n      // Removes an element from its ancestors' ID maps.\n      // This is needed when an element is moved from the \"future\" via `moveBeforeId`.\n      // Otherwise, its erstwhile ancestors could be mistakenly moved to the pantry rather than being deleted,\n      // preventing their removal hooks from being called.\n      let current = movedChild\n      while ((current = current.parentNode as Element)) {\n        const idSet = ctxIdMap.get(current)\n        if (idSet) {\n          idSet.delete(ncId)\n          if (!idSet.size) {\n            ctxIdMap.delete(current)\n          }\n        }\n      }\n\n      moveBefore(oldParent, movedChild, insertionPoint)\n      morphNode(movedChild, newChild)\n      insertionPoint = movedChild.nextSibling\n      continue\n    }\n\n    // This performs the action of inserting a new node while handling situations where the node contains\n    // elements with persistent IDs and possible state info we can still preserve by moving in and then morphing\n    if (ctxIdMap.has(newChild)) {\n      // node has children with IDs with possible state so create a dummy elt of same type and apply full morph algorithm\n      const newEmptyChild = document.createElement(\n        (newChild as Element).tagName,\n      )\n      oldParent.insertBefore(newEmptyChild, insertionPoint)\n      morphNode(newEmptyChild, newChild)\n      insertionPoint = newEmptyChild.nextSibling\n    } else {\n      // optimization: no id state to preserve so we can just insert a clone of the newChild and its descendants\n      const newClonedChild = document.importNode(newChild, true) // importNode to not mutate newParent\n      oldParent.insertBefore(newClonedChild, insertionPoint)\n      insertionPoint = newClonedChild.nextSibling\n    }\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint && insertionPoint !== endPoint) {\n    const tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling\n    removeNode(tempNode)\n  }\n}\n\n// Scans forward from the startPoint to the endPoint looking for a match for the node.\n// It looks for an id set match first, then a soft match.\n// We abort soft matching if we find two future soft matches, to reduce churn.\nfunction findBestMatch(\n  node: Node,\n  startPoint: Node | null,\n  endPoint: Node | null,\n): Node | null {\n  let bestMatch = null\n  let nextSibling = node.nextSibling\n  let siblingSoftMatchCount = 0\n  let displaceMatchCount = 0\n\n  // Max ID matches we are willing to displace in our search\n  const nodeMatchCount = ctxIdMap.get(node)?.size || 0\n\n  let cursor = startPoint\n  while (cursor && cursor !== endPoint) {\n    // soft matching is a prerequisite for id set matching\n    if (isSoftMatch(cursor, node)) {\n      let isIdSetMatch = false\n      const oldSet = ctxIdMap.get(cursor)\n      const newSet = ctxIdMap.get(node)\n\n      if (newSet && oldSet) {\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            isIdSetMatch = true\n            break\n          }\n        }\n      }\n\n      if (isIdSetMatch) {\n        return cursor // found an id set match, we're done!\n      }\n\n      // we haven\u2019t yet saved a soft match fallback\n      // the current soft match will hard match something else in the future, leave it\n      if (!bestMatch && !ctxIdMap.has(cursor)) {\n        // optimization: if node can't id set match, we can just return the soft match immediately\n        if (!nodeMatchCount) {\n          return cursor\n        }\n        // save this as the fallback if we get through the loop without finding a hard match\n        bestMatch = cursor\n      }\n    }\n    // check for IDs we may be displaced when matching\n    displaceMatchCount += ctxIdMap.get(cursor)?.size || 0\n    if (displaceMatchCount > nodeMatchCount) {\n      // if we are going to displace more IDs than the node contains then\n      // we do not have a good candidate for an ID match, so return\n      break\n    }\n\n    if (bestMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {\n      // The next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling\n\n      // If there are two future soft matches, block soft matching for this node to allow\n      // future siblings to soft match. This is to reduce churn in the DOM when an element\n      // is prepended.\n      if (siblingSoftMatchCount >= 2) {\n        bestMatch = undefined\n      }\n    }\n\n    // if the current node contains active element, stop looking for better future matches,\n    // because if one is found, this node will be moved to the pantry, re-parenting it and thus losing focus\n    if (cursor.contains(document.activeElement)) break\n\n    cursor = cursor.nextSibling\n  }\n\n  return bestMatch || null\n}\n\nfunction isSoftMatch(oldNode: Node, newNode: Node): boolean {\n  // ok to cast: if one is not element, `id` and `tagName` will be null and we'll just compare that.\n  const oldId = (oldNode as Element).id\n  return (\n    oldNode.nodeType === newNode.nodeType &&\n    (oldNode as Element).tagName === (newNode as Element).tagName &&\n    // If oldElt has an `id` with possible state and it doesn\u2019t match newElt.id then avoid morphing.\n    // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n    // its not persistent, and new nodes can't have any hidden state.\n    (!oldId || oldId === (newNode as Element).id)\n  )\n}\n\n// Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n// - Persistent nodes will be moved to the pantry for later reuse\n// - Other nodes will have their hooks called, and then are removed\nfunction removeNode(node: Node) {\n  // are we going to id set match this later?\n  if (ctxIdMap.has(node)) {\n    // skip callbacks and move to pantry\n    moveBefore(ctxPantry, node, null)\n  } else {\n    // remove for realsies\n    node.parentNode?.removeChild(node)\n  }\n}\n\n// Moves an element before another element within the same parent.\n// Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n// This is essentially a forward-compat wrapper.\nconst moveBefore: (parentNode: Node, node: Node, after: Node | null) => void =\n  // @ts-ignore\n  removeNode.call.bind(ctxPantry.moveBefore ?? ctxPantry.insertBefore)\n\nfunction morphNode(\n  oldNode: Node, // root node to merge content into\n  newNode: Node, // new content to merge\n): Node {\n  // syncs the oldNode to the newNode, copying over all attributes and\n  // inner element state from the newNode to the oldNode\n  const type = newNode.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const ignore = aliasify('ignore-morph')\n    if (\n      (oldNode as Element).hasAttribute(ignore) &&\n      (newNode as Element).hasAttribute(ignore)\n    ) {\n      return oldNode\n    }\n\n    const preserveAttrs = (\n      (newNode as HTMLElement).getAttribute(aliasify('preserve-attr')) ?? ''\n    ).split(' ')\n\n    for (const { name, value } of (newNode as Element).attributes) {\n      if (\n        (oldNode as Element).getAttribute(name) !== value &&\n        !preserveAttrs.includes(kebab(name))\n      ) {\n        ;(oldNode as Element).setAttribute(name, value)\n      }\n    }\n\n    const oldAttrs = (oldNode as Element).attributes\n    for (let i = oldAttrs.length - 1; i >= 0; i--) {\n      const { name } = oldAttrs[i]\n      if (\n        !(newNode as Element).hasAttribute(name) &&\n        !preserveAttrs.includes(kebab(name))\n      ) {\n        ;(oldNode as Element).removeAttribute(name)\n      }\n    }\n\n    //  many bothans died to bring us information:\n    //  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    //  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n    if (\n      oldNode instanceof HTMLInputElement &&\n      newNode instanceof HTMLInputElement &&\n      newNode.type !== 'file'\n    ) {\n      const bind = aliasify('bind').slice(5)\n      let noBind = true\n      for (const key in newNode.dataset) {\n        if (key.startsWith(bind)) {\n          noBind = false\n          break\n        }\n      }\n      if (noBind) {\n        const newValue = newNode.value\n        if (!newNode.hasAttribute('value')) {\n          oldNode.value = ''\n          oldNode.removeAttribute('value')\n        } else if (oldNode.value !== newValue) {\n          oldNode.setAttribute('value', newValue)\n          oldNode.value = newValue\n        }\n      }\n    } else if (\n      oldNode instanceof HTMLTextAreaElement &&\n      newNode instanceof HTMLTextAreaElement\n    ) {\n      const newValue = newNode.value\n      if (newValue !== oldNode.value) {\n        oldNode.value = newValue\n      }\n      if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {\n        oldNode.firstChild.nodeValue = newValue\n      }\n    }\n  }\n\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (oldNode.nodeValue !== newNode.nodeValue) {\n      oldNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  if (!oldNode.isEqualNode(newNode)) {\n    morphChildren(oldNode as Element, newNode as Element)\n  }\n  return oldNode\n}\n\n// A bottom-up algorithm that populates a map of Element -> IdSet.\n// The ID set for a given element is the set of all IDs contained within its subtree.\n// As an optimization, we filter these IDs through the given list of persistent IDs,\n// because we don't need to bother considering IDed elements that won't be in the new content.\nfunction populateIdMapWithTree(\n  root: Element | null,\n  elements: Element[] | NodeListOf<Element>,\n) {\n  for (const elt of elements) {\n    if (ctxPersistentIds.has(elt.id)) {\n      let current: Element | null = elt\n      // walk up the parent hierarchy of that element, adding the ID of element to the parent's ID set\n      while (current && current !== root) {\n        let idSet = ctxIdMap.get(current)\n        // if the ID set doesn\u2019t exist, create it and insert it in the map\n        if (!idSet) {\n          idSet = new Set()\n          ctxIdMap.set(current, idSet)\n        }\n        idSet.add(elt.id)\n        current = current.parentElement\n      }\n    }\n  }\n}\n", "// Icon: material-symbols:settings-input-antenna\n// Slug: Patches signals.\n// Description: Patches signals.\n\nimport {\n  DefaultPatchSignalsOnlyIfMissing,\n  EventTypePatchSignals,\n} from '../../../engine/consts'\nimport type { WatcherPlugin } from '../../../engine/types'\nimport { isBoolString, jsStrToObject } from '../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const PatchSignals: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchSignals,\n  onGlobalInit: (ctx) =>\n    datastarSSEEventWatcher(\n      EventTypePatchSignals,\n      ({\n        signals: raw = '{}',\n        onlyIfMissing: onlyIfMissingRaw = `${DefaultPatchSignalsOnlyIfMissing}`,\n      }) =>\n        ctx.mergePatch(jsStrToObject(raw), {\n          ifMissing: isBoolString(onlyIfMissingRaw),\n        }),\n    ),\n}\n", "import { apply, load, setAlias } from '../engine'\nimport { Peek } from '../plugins/actions/peek'\nimport { SetAll } from '../plugins/actions/setAll'\nimport { ToggleAll } from '../plugins/actions/toggleAll'\nimport { Attr } from '../plugins/attributes/attr'\nimport { Bind } from '../plugins/attributes/bind'\nimport { Class } from '../plugins/attributes/class'\nimport { Computed } from '../plugins/attributes/computed'\nimport { Effect } from '../plugins/attributes/effect'\nimport { Indicator } from '../plugins/attributes/indicator'\nimport { JsonSignals } from '../plugins/attributes/jsonSignals'\nimport { On } from '../plugins/attributes/on'\nimport { OnIntersect } from '../plugins/attributes/onIntersect'\nimport { OnInterval } from '../plugins/attributes/onInterval'\nimport { OnLoad } from '../plugins/attributes/onLoad'\nimport { OnSignalPatch } from \"../plugins/attributes/onSignalPatch\";\nimport { Ref } from '../plugins/attributes/ref'\nimport { Show } from '../plugins/attributes/show'\nimport { Signals } from '../plugins/attributes/signals'\nimport { Text } from '../plugins/attributes/text'\nimport { DELETE } from '../plugins/backend/actions/delete'\nimport { GET } from '../plugins/backend/actions/get'\nimport { PATCH } from '../plugins/backend/actions/patch'\nimport { POST } from '../plugins/backend/actions/post'\nimport { PUT } from '../plugins/backend/actions/put'\nimport { PatchElements } from '../plugins/backend/watchers/patchElements'\nimport { PatchSignals } from '../plugins/backend/watchers/patchSignals'\n\nload(\n  // Backend\n  GET,\n  POST,\n  PUT,\n  PATCH,\n  DELETE,\n  PatchElements,\n  PatchSignals,\n  // Attributes\n  Attr,\n  Bind,\n  Class,\n  Computed,\n  Effect,\n  Indicator,\n  JsonSignals,\n  On,\n  OnIntersect,\n  OnInterval,\n  OnLoad,\n\tOnSignalPatch,\n  Ref,\n  Show,\n  Signals,\n  Text,\n  // Actions\n  Peek,\n  SetAll,\n  ToggleAll,\n)\n\napply()\n\nexport { apply, load, setAlias }\n"],
  "mappings": ";AACA,IAAMA,GAAM,YAAY,OACXC,GAAMD,GAAI,MAAM,EAAG,CAAC,EACpBE,GAAMF,GAAI,MAAM,CAAC,EAEjBG,EAAW,WACXC,GAAmB,mBAOnBC,GAA4B,IAiBlC,IAAMC,GAAmC,GASnCC,GAAwB,QAExBC,GAAwB,QAExBC,GAAyB,SAEzBC,GAA0B,UAE1BC,GAA0B,UAE1BC,GAAyB,SAEzBC,GAAyB,SAEzBC,GAAwB,QAGxBC,GAA0BR,GAI1BS,GAAyB,0BAEzBC,GAAwB,yBC5D9B,SAASC,GAAYC,EAA2B,CACrD,OAAOA,aAAc,aAAeA,aAAc,UACpD,CCJO,IAAMC,EAAUC,GACrBA,IAAQ,MACR,OAAOA,GAAQ,WACd,OAAO,eAAeA,CAAG,IAAM,OAAO,WACrC,OAAO,eAAeA,CAAG,IAAM,MAE5B,SAASC,GAAQD,EAAmC,CACzD,QAAWE,KAAQF,EACjB,GAAI,OAAO,OAAOA,EAAKE,CAAI,EACzB,MAAO,GAGX,MAAO,EACT,CAEO,SAASC,GACdH,EACAI,EACA,CACA,QAAWC,KAAOL,EAAK,CACrB,IAAMM,EAAMN,EAAIK,CAAG,EACfN,EAAOO,CAAG,GAAK,MAAM,QAAQA,CAAG,EAClCH,GAAaG,EAAKF,CAAE,EAEpBJ,EAAIK,CAAG,EAAID,EAAGE,CAAG,CAErB,CACF,CAEO,IAAMC,EAAY,CACvBC,EACAC,IACwB,CACxB,QAAWC,KAAQD,EAAO,CACxB,IAAME,EAAOD,EAAK,MAAM,GAAG,EACrBE,EAAUD,EAAK,IAAI,EACnBX,EAAMW,EAAK,OAAO,CAACE,EAAKR,IAASQ,EAAIR,CAAG,IAAM,CAAC,EAAIG,CAAM,EAC/DR,EAAIY,CAAO,EAAIH,EAAMC,CAAI,CAC3B,CACA,OAAOF,CACT,ECtCO,IAAMM,GAAgBC,GAAgBA,EAAI,KAAK,IAAM,OAE/CC,EAASD,GACpBA,EACG,QAAQ,qBAAsB,OAAO,EACrC,QAAQ,oBAAqB,OAAO,EACpC,QAAQ,oBAAqB,OAAO,EACpC,YAAY,EAEJE,EAASF,GACpBC,EAAMD,CAAG,EAAE,QAAQ,MAAQG,GAAMA,EAAE,CAAC,EAAE,YAAY,CAAC,EAExCC,GAASJ,GAAgBC,EAAMD,CAAG,EAAE,QAAQ,KAAM,GAAG,EAErDK,GAAUL,GACrBE,EAAMF,CAAG,EAAE,QAAQ,iBAAmBG,GAAMA,EAAE,CAAC,EAAE,YAAY,CAAC,EAEnDG,GAAiBC,GAAgB,CAC5C,GAAI,CACF,OAAO,KAAK,MAAMA,CAAG,CACvB,MAAQ,CAGN,OAAO,SAAS,WAAWA,CAAG,GAAG,EAAE,CACrC,CACF,EAEMC,GAAiD,CAAE,MAAAP,EAAO,MAAAG,GAAO,OAAAC,EAAO,EAEvE,SAASI,EAAaT,EAAaU,EAAiB,CACzD,QAAWC,KAAKD,EAAK,IAAI,MAAM,GAAK,CAAC,EAAG,CACtC,IAAME,EAAKJ,GAAQG,CAAC,EAChBC,IAAIZ,EAAMY,EAAGZ,CAAG,EACtB,CACA,OAAOA,CACT,CCjCA,IAAMa,GAAM,+BAOZ,SAASC,GAAMC,EAAcC,EAAgBC,EAAqB,CAAC,EAAG,CACpE,IAAMC,EAAI,IAAI,MACdA,EAAE,KAAO,GAAGC,CAAQ,IAAIJ,CAAI,SAC5B,IAAM,EAAIK,GAAMJ,CAAM,EAChBK,EAAI,IAAI,gBAAgB,CAC5B,SAAU,KAAK,UAAUJ,CAAQ,CACnC,CAAC,EAAE,SAAS,EACNK,EAAI,KAAK,UAAUL,EAAU,KAAM,CAAC,EAC1C,OAAAC,EAAE,QAAU,GAAGF,CAAM;AAAA,aAAgBH,EAAG,IAAIE,CAAI,IAAI,CAAC,IAAIM,CAAC;AAAA,WAAcC,CAAC,GAClEJ,CACT,CAMO,SAASK,EAAQC,EAAgBC,EAAkBC,EAAW,CAAC,EAAG,CACvE,IAAMC,EAAS,CACb,OAAQ,CACN,KAAMF,EAAI,OAAO,KACjB,KAAMA,EAAI,OAAO,IACnB,CACF,EACA,OAAOG,GAAM,OAAQJ,EAAQ,OAAO,OAAOG,EAAQD,CAAQ,CAAC,CAC9D,CAEO,SAASG,GAAWJ,EAAqBD,EAAgBE,EAAW,CAAC,EAAG,CAC7E,IAAMC,EAAS,CACb,OAAQ,CACN,KAAMF,EAAI,OAAO,KACjB,KAAMA,EAAI,OAAO,IACnB,EACA,QAAS,CACP,GAAIA,EAAI,GAAG,GACX,IAAKA,EAAI,GAAG,OACd,EACA,WAAY,CACV,OAAQA,EAAI,OACZ,IAAKA,EAAI,IACT,MAAOA,EAAI,MAEX,UAAWA,EAAI,SACjB,CACF,EACA,OAAOG,GAAM,UAAWJ,EAAQ,OAAO,OAAOG,EAAQD,CAAQ,CAAC,CACjE,CC9CO,IAAMI,EAA8B,GAAGC,CAAQ,gBCkEtD,IAAIC,GAAoC,CAAC,EACnCC,GAA6C,CAAC,EAChDC,GAAa,EACbC,GAAc,EACdC,GAAsB,EACtBC,EAEEC,GAAa,IAAY,CAC7BJ,IACF,EACMK,GAAW,IAAY,CACtB,EAAEL,KACLM,GAAM,EACNC,EAAS,EAEb,EAEMC,GAAaC,GACVC,GAAW,KAAK,EAAG,CACxB,cAAeD,EACfE,EAAQF,EACRG,EAAQ,CACV,CAAC,EAGGC,GAAiB,OAAO,UAAU,EAClCC,GAAeC,GAAkD,CACrE,IAAMC,EAAIC,GAAa,KAAK,EAAG,CAC7BL,EAAQ,GACR,OAAAG,CACF,CAAC,EAED,OAAAC,EAAEH,EAAc,EAAI,EACbG,CACT,EAEME,GAAUC,GAA2B,CACzC,IAAMC,EAAiB,CACrBC,EAAKF,EACLP,EAAQ,CACV,EACIT,GACFmB,GAAKF,EAAGjB,CAAS,EAEnB,IAAMoB,EAAOC,EAAcJ,CAAC,EAC5BhB,GAAW,EACX,GAAI,CACFgB,EAAEC,EAAI,CACR,QAAE,CACAhB,GAAS,EACTmB,EAAcD,CAAI,CACpB,CACA,OAAOE,GAAW,KAAK,EAAGL,CAAC,CAC7B,EAEMM,GAAWP,GAAmB,CAClC,IAAMI,EAAOC,EAAc,MAAS,EACpC,GAAI,CACF,OAAOL,EAAG,CACZ,QAAE,CACAK,EAAcD,CAAI,CACpB,CACF,EAEMjB,GAAQ,IAAM,CAClB,KAAOL,GAAcC,IAAqB,CACxC,IAAMgB,EAASnB,GAAcE,EAAW,EACxCF,GAAcE,IAAa,EAAI,OAC/B0B,GAAIT,EAASA,EAAON,GAAU,GAAoB,CACpD,CACAX,GAAc,EACdC,GAAsB,CACxB,EAEM0B,GAAUpB,GACV,WAAYA,EACPqB,GAAerB,CAAM,EAEvBsB,GAAatB,EAAQA,EAAOG,CAAM,EAGrCa,EAAiBO,GAAiD,CACtE,IAAMC,EAAU7B,EAChB,OAAAA,EAAY4B,EACLC,CACT,EAEMH,GAAkBb,GAA8B,CACpD,IAAMgB,EAAUR,EAAcR,CAAC,EAC/BiB,GAAcjB,CAAC,EACf,GAAI,CACF,IAAMkB,EAAWlB,EAAEL,EACnB,OAAOuB,KAAclB,EAAEL,EAASK,EAAE,OAAOkB,CAAQ,EACnD,QAAE,CACAV,EAAcQ,CAAO,EACrBG,GAAYnB,CAAC,CACf,CACF,EAEMc,GAAe,CAACM,EAAgBC,KACpCD,EAAExB,EAAS,EACJwB,EAAE,iBAAmBA,EAAE,cAAgBC,IAG1CC,GAAU,GAAyB,CACvC,IAAMC,EAAQ,EAAE3B,EAChB,GAAI,EAAE2B,EAAQ,IAAqB,CACjC,EAAE3B,EAAS2B,EAAQ,GACnB,IAAMC,EAAO,EAAEC,EACXD,EACFF,GAAOE,EAAKE,CAAmB,EAE/B3C,GAAcG,IAAqB,EAAI,CAE3C,CACF,EAEMyB,GAAM,CAAC,EAAgBY,IAA+B,CAC1D,GACEA,EAAS,IACRA,EAAS,IAAuCI,GAAW,EAAEC,EAAQ,CAAC,EACvE,CACA,IAAMrB,EAAOC,EAAc,CAAC,EAC5BS,GAAc,CAAC,EACf7B,GAAW,EACX,GAAI,CACF,EAAEiB,EAAI,CACR,QAAE,CACAhB,GAAS,EACTmB,EAAcD,CAAI,EAClBY,GAAY,CAAC,CACf,CACA,MACF,CACII,EAAS,KACX,EAAE3B,EAAS2B,EAAQ,KAErB,IAAIjB,EAAO,EAAEsB,EACb,KAAOtB,GAAM,CACX,IAAMuB,EAAMvB,EAAKwB,EACXC,EAAWF,EAAIjC,EACjBmC,EAAW,IACbpB,GAAIkB,EAAqBA,EAAIjC,EAASmC,EAAW,GAAoB,EAEvEzB,EAAOA,EAAK0B,CACd,CACF,EAEM/B,GAAmBD,GAA2B,CAClD,IAAMuB,EAAQvB,EAAEJ,EAChB,GACE2B,EAAS,IACRA,EAAS,IAAuCI,GAAW3B,EAAE4B,EAAQ5B,CAAC,GAEvE,GAAIa,GAAeb,CAAC,EAAG,CACrB,IAAMwB,EAAOxB,EAAEyB,EACXD,GACFS,GAAiBT,CAAI,CAEzB,OACSD,EAAS,KAClBvB,EAAEJ,EAAS2B,EAAQ,KAErB,OAAIpC,GACFmB,GAAKN,EAAGb,CAAS,EAEZa,EAAEL,CACX,EAEMD,GAAa,CAAI0B,KAAsBC,IAA4B,CACvE,GAAIA,EAAM,OAAQ,CAChB,IAAMa,EAAWb,EAAM,CAAC,EACxB,GAAID,EAAEzB,KAAYyB,EAAEzB,EAASuC,GAAW,CACtCd,EAAExB,EAAS,GACX,IAAM4B,EAAOJ,EAAEK,EACf,OAAID,IACFW,GAAUX,CAAI,EACTxC,IACHM,GAAM,GAGH,EACT,CACA,MAAO,EACT,CACA,IAAM8C,EAAehB,EAAEzB,EACvB,GAAIyB,EAAExB,EAAU,IACVkB,GAAaM,EAAGgB,CAAY,EAAG,CACjC,IAAMX,EAAQL,EAAEK,EACZA,GACFQ,GAAiBR,CAAK,CAE1B,CAEF,OAAItC,GACFmB,GAAKc,EAAGjC,CAAS,EAEZiD,CACT,EAEM3B,GAAc,GAAyB,CAC3C,IAAIoB,EAAM,EAAED,EACZ,KAAOC,GACLA,EAAMQ,GAAOR,EAAK,CAAC,EAErB,IAAMd,EAAM,EAAEU,EACVV,GACFsB,GAAOtB,CAAG,EAEZ,EAAEnB,EAAS,CACb,EAEMU,GAAO,CAACuB,EAAmBd,IAA4B,CAC3D,IAAMuB,EAAUvB,EAAIwB,EACpB,GAAID,GAAWA,EAAQR,IAASD,EAC9B,OAEF,IAAIW,EACEC,EAAgB1B,EAAInB,EAAU,EACpC,GAAI6C,IACFD,EAAUF,EAAUA,EAAQN,EAAWjB,EAAIa,EACvCY,GAAWA,EAAQV,IAASD,GAAK,CACnCd,EAAIwB,EAAYC,EAChB,MACF,CAEF,IAAMxB,EAAUa,EAAIa,EACpB,GACE1B,GACAA,EAAQU,IAASX,IAChB,CAAC0B,GAAiBE,GAAY3B,EAASD,CAAG,GAE3C,OAEF,IAAM6B,EACH7B,EAAIwB,EACLV,EAAIa,EACF,CACEZ,EAAMD,EACNH,EAAMX,EACN8B,EAAUP,EACVN,EAAUQ,EACVM,EAAU9B,CACZ,EACAwB,IACFA,EAAQK,EAAWD,GAEjBN,EACFA,EAAQN,EAAWY,EAEnB7B,EAAIa,EAAQgB,EAEV5B,EACFA,EAAQ+B,EAAWH,EAEnBf,EAAIJ,EAAQmB,CAEhB,EAEMP,GAAS,CAAC/B,EAAYoB,EAAOpB,EAAKoB,IAA2B,CACjE,IAAMI,EAAOxB,EAAKwB,EACZe,EAAWvC,EAAKuC,EAChBb,EAAW1B,EAAK0B,EAChBe,EAAWzC,EAAKyC,EAChBD,EAAWxC,EAAKwC,EAgBtB,GAfId,EACFA,EAASa,EAAWA,EAEpBnB,EAAKa,EAAYM,EAEfA,EACFA,EAASb,EAAWA,EAEpBN,EAAKE,EAAQI,EAEXe,EACFA,EAASD,EAAWA,EAEpBhB,EAAKY,EAAYI,EAEfA,EACFA,EAASC,EAAWA,UACX,EAAEjB,EAAKL,EAAQsB,GACxB,GAAI,WAAYjB,EAAM,CACpB,IAAIkB,EAAWlB,EAAKF,EACpB,GAAIoB,EAAU,CACZlB,EAAKlC,EAAS,GACd,GACEoD,EAAWX,GAAOW,EAAUlB,CAAI,QACzBkB,EACX,CACF,KAAa,kBAAmBlB,GAC9BrB,GAAWqB,CAAmB,EAGlC,OAAOE,CACT,EAEMG,GAAa7B,GAAqB,CACtC,IAAI2C,EAAO3C,EAAKyC,EACZG,EAEJC,EAAK,OAAa,CAChB,IAAMpC,EAAMT,EAAKoB,EAEbH,EAAQR,EAAInB,EAEhB,GAAI2B,EAAS,IAGPA,EACC,GASDA,EAAS,GAGAA,EAAS,EAKpB,EAAEA,EAAS,KACXoB,GAAYrC,EAAMS,CAAG,GAErBA,EAAInB,EACF2B,EAAS,GACXA,GAAS,GAETA,EAAQ,EAXRR,EAAInB,EACD2B,EAAQ,GACR,GAJHA,EAAQ,EAJRR,EAAInB,EAAS2B,EAAS,GAoBpBA,EAAS,GACXD,GAAOP,CAAkB,EAGvBQ,EAAS,GAAoC,CAC/C,IAAM6B,EAAUrC,EAAIU,EACpB,GAAI2B,EAAS,CACX9C,EAAO8C,EACHA,EAAQL,IACVG,EAAQ,CAAEvD,EAAc0D,EAAOH,CAAM,EACrCD,EAAO3C,EAAKyC,GAEd,QACF,CACF,CAGF,GAAKzC,EAAO2C,EAAQ,CAClBA,EAAO3C,EAAKyC,EACZ,QACF,CAEA,KAAOG,GAGL,GAFA5C,EAAO4C,EAAMvD,EACbuD,EAAQA,EAAMG,EACV/C,EAAM,CACR2C,EAAO3C,EAAKyC,EACZ,SAASI,CACX,CAGF,KACF,CACF,EAEMlC,GAAiBF,GAA4B,CACjDA,EAAIwB,EAAY,OAChBxB,EAAInB,EACDmB,EAAInB,EACH,IAID,CACL,EAEMuB,GAAeJ,GAA4B,CAC/C,IAAMwB,EAAYxB,EAAIwB,EAClBS,EAAWT,EAAYA,EAAUP,EAAWjB,EAAIa,EACpD,KAAOoB,GACLA,EAAWX,GAAOW,EAAUjC,CAAG,EAEjCA,EAAInB,GAAU,EAChB,EAEM+B,GAAa,CAACrB,EAAYS,IAA+B,CAC7D,IAAImC,EACAI,EAAa,EAEjBH,EAAK,OAAa,CAChB,IAAMtB,EAAMvB,EAAKwB,EACXC,EAAWF,EAAIjC,EAEjB2D,EAAQ,GAEZ,GAAIxC,EAAInB,EAAU,GAChB2D,EAAQ,YAEPxB,EAAY,MACZ,IAED,GAAInB,GAAOiB,CAAkC,EAAG,CAC9C,IAAML,EAAOK,EAAIJ,EACbD,EAAKuB,GACPd,GAAiBT,CAAI,EAEvB+B,EAAQ,EACV,WAECxB,EAAY,MACZ,GACD,EACIzB,EAAKyC,GAAYzC,EAAKwC,KACxBI,EAAQ,CAAEvD,EAAQW,EAAM+C,EAAOH,CAAM,GAEvC5C,EAAOuB,EAAID,EACXb,EAAMc,EACN,EAAEyB,EACF,QACF,CAEA,GAAI,CAACC,GAASjD,EAAK0B,EAAU,CAC3B1B,EAAOA,EAAK0B,EACZ,QACF,CAEA,KAAOsB,GAAY,CACjB,EAAEA,EACF,IAAME,EAAWzC,EAAIU,EACfgC,EAAkBD,EAAST,EAOjC,GANIU,GACFnD,EAAO4C,EAAOvD,EACduD,EAAQA,EAAOG,GAEf/C,EAAOkD,EAELD,GACF,GAAI3C,GAAOG,CAAkC,EAAG,CAC1C0C,GACFxB,GAAiBuB,CAAQ,EAE3BzC,EAAMT,EAAKoB,EACX,QACF,OAEAX,EAAInB,GAAU,IAGhB,GADAmB,EAAMT,EAAKoB,EACPpB,EAAK0B,EAAU,CACjB1B,EAAOA,EAAK0B,EACZ,SAASmB,CACX,CACAI,EAAQ,EACV,CAEA,OAAOA,CACT,CACF,EAEMtB,GAAoB3B,GAAqB,CAC7C,EAAG,CACD,IAAMS,EAAMT,EAAKoB,EACXgC,EAAUpD,EAAKyC,EACfY,EAAW5C,EAAInB,GAElB+D,EAAY,MACZ,KAED5C,EAAInB,EAAS+D,EAAY,GACrBA,EAAY,GACdrC,GAAOP,CAAkB,GAG7BT,EAAOoD,CACT,OAASpD,EACX,EAEMqC,GAAc,CAACiB,EAAiB7C,IAA+B,CACnE,IAAM8C,EAAW9C,EAAIwB,EACrB,GAAIsB,EAAU,CACZ,IAAIvD,EAAOS,EAAIa,EACf,EAAG,CACD,GAAItB,IAASsD,EACX,MAAO,GAET,GAAItD,IAASuD,EACX,MAEFvD,EAAOA,EAAK0B,CACd,OAAS1B,EACX,CACA,MAAO,EACT,EAEMwD,GAAoBC,GACxBA,EAAK,MAAM,GAAG,EAAE,OAAO,CAACC,EAAKC,IAAQD,EAAIC,CAAG,EAAGC,CAAI,EAE/CC,GAAWJ,GACfrD,GACE,IACEqD,EACG,MAAM,GAAG,EACT,OACC,CAACK,EAAKH,IAASG,GAAO,OAAO,OAAOA,EAAKH,CAAG,EAAIG,EAAIH,CAAG,EAAI,OAC3DC,CACF,IAAM,MACZ,EAEWG,GAAS,OAAO,QAAQ,EAC/BC,GAAO,CAACjD,EAAYkD,EAAS,KAAY,CAC7C,IAAMC,EAAQ,MAAM,QAAQnD,CAAK,EACjC,GAAImD,GAASC,EAAOpD,CAAK,EAAG,CAC1B,IAAMqD,EAAWF,EAAQ,CAAC,EAAI,CAAC,EAC/B,QAAWP,KAAO5C,EAChBqD,EAAQT,CAAG,EAAIzE,GACb8E,GAAMjD,EAAiC4C,CAAG,EAAG,GAAGM,EAASN,CAAG,GAAG,CACjE,EAEF,IAAMU,EAAOnF,GAAO,CAAC,EACrB,OAAO,IAAI,MAAMkF,EAAS,CACxB,IAAK,CAACE,EAAGC,IAAiB,CACxB,GAAI,EAAEA,IAAS,UAAY,CAAC,OAAO,OAAOH,EAASG,CAAI,GACrD,OAAIL,GAASK,KAAQ,MAAM,WACzBF,EAAK,EACED,EAAQG,CAAI,KAEf,CAAC,OAAO,OAAOH,EAASG,CAAI,GAAKH,EAAQG,CAAI,EAAE,GAAK,QACtDH,EAAQG,CAAI,EAAIrF,GAAO,EAAE,EACzBD,EAAS,CAAE,CAACgF,EAASM,CAAI,EAAG,EAAG,CAAC,EAChCF,EAAKA,EAAK,EAAI,CAAC,GAEVD,EAAQG,CAAI,EAAE,EAG3B,EACA,IAAK,CAACD,EAAGC,EAAc3C,KACjBA,IAAamC,GACX,OAAO,OAAOK,EAASG,CAAI,IAC7B,OAAOH,EAAQG,CAAI,EACnBtF,EAAS,CAAE,CAACgF,EAASM,CAAI,EAAGR,EAAO,CAAC,EACpCM,EAAKA,EAAK,EAAI,CAAC,GAGbH,GAASK,IAAS,UACpBH,EAAQG,CAAI,EAAI3C,EAChB3C,EAAS,CAAE,CAACgF,EAAO,MAAM,EAAG,EAAE,CAAC,EAAGG,CAAQ,CAAC,EAC3CC,EAAKA,EAAK,EAAI,CAAC,GAEX,OAAO,OAAOD,EAASG,CAAI,EACzB3C,GAAY,KACVwC,EAAQG,CAAI,EAAE,IAAI,GACpBtF,EAAS,CAAE,CAACgF,EAASM,CAAI,EAAG,IAAK,CAAC,EAGhCH,EAAQG,CAAI,EAAEP,GAAKpC,EAAU,GAAGqC,EAASM,CAAI,GAAG,CAAC,GACnDtF,EAAS,CAAE,CAACgF,EAASM,CAAI,EAAG3C,CAAS,CAAC,EAItCA,GAAY,OACV,OAAO,OAAOA,EAAUrC,EAAc,GACxC6E,EAAQG,CAAI,EAAI3C,EAChB3C,EAAS,CAAE,CAACgF,EAASM,CAAI,EAAG,EAAG,CAAC,IAEhCH,EAAQG,CAAI,EAAIrF,GAAO8E,GAAKpC,EAAU,GAAGqC,EAASM,CAAI,GAAG,CAAC,EAC1DtF,EAAS,CAAE,CAACgF,EAASM,CAAI,EAAG3C,CAAS,CAAC,GAExCyC,EAAKA,EAAK,EAAI,CAAC,GAMhB,IAET,eAAgB,CAACC,EAAGC,KACd,OAAO,OAAOH,EAASG,CAAI,GACzBH,EAAQG,CAAI,EAAE,IAAI,GACpBtF,EAAS,CAAE,CAACgF,EAASM,CAAI,EAAG,IAAK,CAAC,EAI/B,IAET,QAAS,KACPF,EAAK,EACE,QAAQ,QAAQD,CAAO,GAEhC,IAAIE,EAAGC,EAAM,CACX,OAAAF,EAAK,EACEE,KAAQH,CACjB,CACF,CAAC,CACH,CACA,OAAOrD,CACT,EAEM9B,EAAY6E,GAA8B,CAI9C,GAHIA,GACFU,EAAUhG,GAAcsF,CAAG,EAEzB,CAACpF,IAAc,CAAC+F,GAAQjG,EAAY,EAAG,CACzC,IAAMkG,EAAWlG,GACjBA,GAAe,CAAC,EAChB,SAAS,cACP,IAAI,YAAuBmG,EAA6B,CACtD,OAAQD,CACV,CAAC,CACH,CACF,CACF,EAEME,GAAa,CACjBC,EACA,CAAE,UAAAC,CAAU,EAA6B,CAAC,IACjC,CACThG,GAAW,EACX,QAAW6E,KAAOkB,EACZA,EAAMlB,CAAG,GAAK,KACXmB,GACH,OAAOlB,EAAKD,CAAG,EAGjBoB,GAAWF,EAAMlB,CAAG,EAAGA,EAAKC,EAAM,GAAIkB,CAAS,EAGnD/F,GAAS,CACX,EAEMgG,GAAa,CACjBF,EACAG,EACAC,EACAhB,EACAa,IACS,CACT,GAAIX,EAAOU,CAAK,EAAG,CAGb,OAAO,OAAOI,EAAcD,CAAM,IACjCb,EAAOc,EAAaD,CAAM,CAAC,GAAK,MAAM,QAAQC,EAAaD,CAAM,CAAC,KAGrEC,EAAaD,CAAM,EAAI,CAAC,GAG1B,QAAWrB,KAAOkB,EACZA,EAAMlB,CAAG,GAAK,KACXmB,GACH,OAAOG,EAAaD,CAAM,EAAErB,CAAG,EAGjCoB,GACEF,EAAMlB,CAAG,EACTA,EACAsB,EAAaD,CAAM,EACnB,GAAGf,EAASe,CAAM,IAClBF,CACF,CAGN,MAAaA,GAAa,OAAO,OAAOG,EAAcD,CAAM,IAC1DC,EAAaD,CAAM,EAAIH,EAE3B,EAEA,SAASK,GACP,CAAE,QAAAC,EAAU,KAAM,QAAAC,EAAU,MAAO,EAAyB,CAAC,EAC7DtB,EAAiBF,EACjB,CAEA,IAAMyB,EAA+B,CAAC,EAChCzC,EAA8B,CAAC,CAACkB,EAAK,EAAE,CAAC,EAE9C,KAAOlB,EAAM,QAAQ,CACnB,GAAM,CAAC0C,EAAMrB,CAAM,EAAIrB,EAAM,IAAI,EAEjC,QAAWe,KAAO2B,EACZnB,EAAOmB,EAAK3B,CAAG,CAAC,EAClBf,EAAM,KAAK,CAAC0C,EAAK3B,CAAG,EAAG,GAAGM,EAASN,CAAG,GAAG,CAAC,EACjCwB,EAAQ,KAAKlB,EAASN,CAAG,GAAK,CAACyB,EAAQ,KAAKnB,EAASN,CAAG,IACjE0B,EAAQpB,EAASN,CAAG,EAAIH,GAAQS,EAASN,CAAG,EAGlD,CAEA,OAAOa,EAAU,CAAC,EAAGa,CAAO,CAC9B,CAEA,IAAMzB,EAA4BI,GAAK,CAAC,CAAC,EAOnCuB,GAAyB,CAAC,EAC1BC,GAA6B,CAAC,EAChCC,GAAyB,CAAC,EAGxBC,GAAW,IAAI,IAEjBC,GAA4C,KAE5CC,GAAQ,GACL,SAASC,GAAS9E,EAAe,CACtC6E,GAAQ7E,CACV,CACO,SAAS+E,EAASC,EAAc,CACrC,OAAOH,GAAQ,QAAQA,EAAK,IAAIG,CAAI,GAAK,QAAQA,CAAI,EACvD,CAEO,SAASC,MAAQC,EAAiC,CACvD,QAAWC,KAAUD,EAAe,CAClC,IAAME,EAAmB,CACvB,OAAAD,EACA,QAAAX,GACA,KAAA3B,EACA,SAAAsB,GACA,OAAAhG,GACA,SAAAM,GACA,OAAAI,GACA,WAAAgF,GACA,KAAAxE,GACA,QAAAoD,GACA,QAAAK,GACA,WAAA/E,GACA,SAAAC,EACF,EACA,GAAImH,EAAO,OAAS,SAClBX,GAAQW,EAAO,IAAI,EAAIA,UACdA,EAAO,OAAS,YACzBV,GAAQ,KAAKU,CAAM,EACnBA,EAAO,eAAeC,CAAG,UAChBD,EAAO,OAAS,UACzBA,EAAO,eAAeC,CAAG,MAEzB,OAAMC,EAAQ,oBAAqBD,CAAG,CAE1C,CAGAX,GAAQ,KAAK,CAACa,EAAGC,IAAM,CACrB,IAAMC,EAAUD,EAAE,KAAK,OAASD,EAAE,KAAK,OACvC,OAAIE,IAAY,EAAUA,EACnBF,EAAE,KAAK,cAAcC,EAAE,IAAI,CACpC,CAAC,EAEDb,GAAeD,GAAQ,IAAKU,GAAW,OAAO,IAAIA,EAAO,IAAI,aAAa,CAAC,CAC7E,CAEA,SAASM,GAASC,EAAgC,CAChD,IAAMC,EAAS,IAAIZ,EAAS,QAAQ,CAAC,IACrC,QAAWa,KAAMF,EACf,GAAI,CAACE,EAAG,QAAQD,CAAM,EACpB,QAAW/C,KAAOgD,EAAG,QACnBC,GAAqBD,EAAIhD,EAAKgD,EAAG,QAAQhD,CAAG,CAAE,CAItD,CAGO,SAASkD,GAAMjD,EAAkB,SAAS,KAAM,CAErD,eAAe,IAAM,CACnB4C,GAAS,CAAC5C,CAAI,CAAC,EACf4C,GAAS5C,EAAK,iBAA4B,GAAG,CAAC,EAIzC+B,KACHA,GAAmB,IAAI,iBAAiBmB,EAAO,EAC/CnB,GAAiB,QAAQ/B,EAAM,CAC7B,QAAS,GACT,UAAW,GACX,WAAY,EACd,CAAC,EAEL,CAAC,CACH,CAEA,SAASgD,GACPD,EACAI,EACAhG,EACM,CACN,IAAMiG,EAASC,EAAMrB,GAAQmB,EAAQ,MAAMnB,GAAM,MAAM,EAAImB,CAAO,EAC5Db,EAASV,GAAQ,KAAK,CAAClB,EAAG4C,IAAMzB,GAAayB,CAAC,EAAE,KAAKF,CAAM,CAAC,EAClE,GAAId,EAAQ,CAEV,GAAI,CAACvC,EAAK,GAAGwD,CAAY,EAAIH,EAAO,MAAMd,EAAO,KAAK,MAAM,EAAE,MAAM,KAAK,EAEnEkB,EAAS,CAAC,CAACzD,EACbyD,IACFzD,EAAMsD,EAAMtD,CAAG,GAEjB,IAAM0D,EAAW,CAAC,CAACtG,EAGboF,EAAsB,CAC1B,OAAAD,EACA,QAAAX,GACA,KAAA3B,EACA,SAAAsB,GACA,OAAAhG,GACA,SAAAM,GACA,OAAAI,GACA,WAAAgF,GACA,KAAAxE,GACA,QAAAoD,GACA,QAAAK,GACA,WAAA/E,GACA,SAAAC,GACA,GAAA4H,EACA,OAAAK,EACA,IAAArD,EACA,MAAA5C,EACA,KAAM,IAAI,IACV,WAAY,EACZ,GAAI,CACN,EACAoF,EAAI,WAAamB,GAAW,KAAK,EAAGnB,CAAG,GACnCD,EAAO,iBAAmB,QAAaA,EAAO,iBAAmB,MACnEC,EAAI,GAAKoB,GAA2BpB,CAAG,GAIzC,IAAMqB,EAAStB,EAAO,QAAU,UAChC,GAAIkB,GACF,GAAII,IAAW,SACb,MAAMrB,EAAI,WAAW,GAAGD,EAAO,IAAI,eAAe,UAE3CsB,IAAW,OACpB,MAAMrB,EAAI,WAAW,GAAGD,EAAO,IAAI,aAAa,EAGlD,IAAMuB,EAASvB,EAAO,QAAU,UAChC,GAAImB,GACF,GAAII,IAAW,SACb,MAAMtB,EAAI,WAAW,GAAGD,EAAO,IAAI,iBAAiB,UAE7CuB,IAAW,OACpB,MAAMtB,EAAI,WAAW,GAAGD,EAAO,IAAI,eAAe,EAIpD,GAAIsB,IAAW,aAAeC,IAAW,YAAa,CACpD,GAAIL,GAAUC,EACZ,MAAMlB,EAAI,WAAW,GAAGD,EAAO,IAAI,qBAAqB,EAE1D,GAAI,CAACkB,GAAU,CAACC,EACd,MAAMlB,EAAI,WAAW,GAAGD,EAAO,IAAI,oBAAoB,CAE3D,CAEA,QAAWwB,KAAUP,EAAc,CACjC,GAAM,CAACQ,EAAO,GAAGC,CAAG,EAAIF,EAAO,MAAM,GAAG,EACxCvB,EAAI,KAAK,IAAIc,EAAMU,CAAK,EAAG,IAAI,IAAIC,EAAI,IAAKC,GAAMA,EAAE,YAAY,CAAC,CAAC,CAAC,CACrE,CAEA,IAAMC,EAAU5B,EAAO,OAAOC,CAAG,EACjC,GAAI2B,EAAS,CACX,IAAIC,EAAWrC,GAAS,IAAIiB,CAAE,EAC1BoB,EACFA,EAAS,IAAIf,CAAM,IAAI,GAEvBe,EAAW,IAAI,IACfrC,GAAS,IAAIiB,EAAIoB,CAAQ,GAE3BA,EAAS,IAAIf,EAAQc,CAAO,CAC9B,CACF,CACF,CAGA,SAAShB,GAAQkB,EAA6B,CAC5C,IAAMtB,EAAS,IAAIZ,EAAS,QAAQ,CAAC,IAErC,OAAW,CACT,OAAAd,EACA,KAAAiD,EACA,cAAAC,EACA,WAAAC,EACA,aAAAC,CACF,IAAKJ,EACH,GAAIC,IAAS,YAAa,CACxB,QAAW3C,KAAQ8C,EACjB,GAAIC,GAAY/C,CAAI,EAAG,CACrB,IAAMyC,EAAWrC,GAAS,IAAIJ,CAAI,EAElC,GAAII,GAAS,OAAOJ,CAAI,EAAG,CACzB,QAAWwC,KAAWC,EAAU,OAAO,EACrCD,EAAQ,EAEVC,EAAU,MAAM,CAClB,CACF,CAGF,QAAWzC,KAAQ6C,EACbE,GAAY/C,CAAI,IAClBkB,GAAS,CAAClB,CAAI,CAAC,EACfkB,GAASlB,EAAK,iBAA4B,GAAG,CAAC,EAGpD,SAAW2C,IAAS,cAEdI,GAAYrD,CAAM,GAAK,CAACA,EAAO,QAAQ0B,CAAM,EAAG,CAClD,IAAM/C,EAAMsD,EAAMiB,EAAe,MAAM,CAAC,CAAC,EACnCnH,EAAQiE,EAAO,aAAakD,CAAc,EAChD,GAAInH,IAAU,KAAM,CAClB,IAAMgH,EAAWrC,GAAS,IAAIV,CAAM,EAChC+C,IACFA,EAAS,IAAIpE,CAAG,IAAI,EACpBoE,EAAS,OAAOpE,CAAG,EAEvB,MACEiD,GAAqB5B,EAAQrB,EAAK5C,CAAK,CAE3C,CAGN,CAEA,SAASwG,GACPpB,EAC2B,CAC3B,IAAImC,EAAO,GAELC,EAAcpC,EAAI,QAA8B,OAGtD,GAAIoC,GAAY,aAAc,CAqB5B,IAAMC,EACJ,4JACIC,EAAatC,EAAI,MAAM,KAAK,EAAE,MAAMqC,CAAW,EACrD,GAAIC,EAAY,CACd,IAAMC,EAAUD,EAAW,OAAS,EAC9BE,EAAOF,EAAWC,CAAO,EAAE,KAAK,EACjCC,EAAK,WAAW,QAAQ,IAC3BF,EAAWC,CAAO,EAAI,WAAWC,CAAI,MAEvCL,EAAOG,EAAW,KAAK;AAAA,CAAK,CAC9B,CACF,MACEH,EAAOnC,EAAI,MAAM,KAAK,EAGxBmC,EAAOA,EAAK,QACV,8CACA,CAACM,EAAOC,IAIJA,EAAW,SAAS,GAAG,GACvBD,EAAM,OAASN,EAAK,QACpBA,EAAKA,EAAK,QAAQM,CAAK,EAAIA,EAAM,MAAM,IAAM,KAE7CC,EAAaA,EAAW,MAAM,EAAG,EAAE,EAE5B,GADOA,EAAW,MAAM,GAAG,EAClB,OAAO,CAACnF,EAAaoF,IAAiB,GAAGpF,CAAG,KAAKoF,CAAI,KAAM,GAAG,CAAC,KAGnED,EAAW,MAAM,GAAG,EACrB,OACX,CAACnF,EAAaoF,IAAiB,GAAGpF,CAAG,KAAKoF,CAAI,KAC9C,GACF,CAEJ,EAGA,IAAMC,EAAU,IAAI,IACdC,EAAW,OAAO,MAAMC,EAAG,YAAYC,EAAG,IAAK,IAAI,EACzD,QAAWN,KAASN,EAAK,SAASU,CAAQ,EAAG,CAC3C,IAAMG,EAAIP,EAAM,CAAC,EACXQ,EAAI,YAAYC,GAAKF,CAAC,CAAC,GAC7BJ,EAAQ,IAAIK,EAAGD,CAAC,EAChBb,EAAOA,EAAK,QAAQW,GAAME,EAAID,GAAKE,CAAC,CACtC,CAEA,IAAME,EAAU,CAACrF,EAAgB8B,IACxB,GAAG9B,CAAM,GAAGsF,GAAMxD,CAAI,EAAE,WAAW,MAAO,GAAG,CAAC,GAIjDyD,EAAgB,IAAI,IACpBC,EAAY,OAAO,KAAK,OAAO,KAAKlE,EAAO,EAAE,KAAK,GAAG,CAAC,OAAQ,IAAI,EAClEmE,EAAgB,CAAC,GAAGpB,EAAK,SAASmB,CAAS,CAAC,EAC5CE,EAAc,IAAI,IAClBC,EAAY,IAAI,IACtB,GAAIF,EAAc,OAAQ,CACxB,IAAMG,EAAe,GAAGC,CAAQ,OAChC,QAAWlB,KAASc,EAAe,CACjC,IAAMK,EAAanB,EAAM,CAAC,EACpBoB,EAASzE,GAAQwE,CAAU,EACjC,GAAI,CAACC,EACH,SAEFR,EAAc,IAAIO,CAAU,EAE5B,IAAMhE,EAAOuD,EAAQO,EAAcE,CAAU,EAG7CzB,EAAOA,EAAK,QAAQ,IAAIyB,CAAU,IAAK,GAAGhE,CAAI,GAAG,EACjD4D,EAAY,IAAI5D,CAAI,EACpB6D,EAAU,IAAI,IAAIK,IAAgBD,EAAO,GAAG7D,EAAK,GAAG8D,CAAI,CAAC,CAC3D,CACF,CAGA,OAAW,CAACd,EAAGC,CAAC,IAAKL,EACnBT,EAAOA,EAAK,QAAQa,EAAGC,CAAC,EAG1BjD,EAAI,UAAYmC,EAEhB,GAAI,CACF,IAAMzI,EAAK,SACT,KACA,IACA,GAAI0I,GAAY,UAAY,CAAC,EAC7B,GAAGoB,EACHrB,CACF,EACA,MAAO,IAAI2B,IAAgB,CACzB,GAAI,CACF,OAAOpK,EAAGsG,EAAI,GAAIvC,EAAM,GAAGqG,EAAM,GAAGL,CAAS,CAC/C,OAAS9J,EAAQ,CACf,MAAMqG,EAAI,WAAW,oBAAqB,CACxC,MAAOrG,EAAE,OACX,CAAC,CACH,CACF,CACF,OAASoK,EAAY,CACnB,MAAM/D,EAAI,WAAW,qBAAsB,CACzC,MAAO+D,EAAM,OACf,CAAC,CACH,CACF,CAEA,SAASb,GAAKc,EAAa,CACzB,IAAIC,EAAO,KACPlD,EAAIiD,EAAI,OACZ,KAAOjD,KACLkD,IAASA,GAAQ,GAAKD,EAAI,WAAWjD,CAAC,EAExC,OAAQkD,IAAS,GAAG,SAAS,EAAE,CACjC,CC5nCO,IAAMC,GAAqB,CAChC,KAAM,SACN,KAAM,OACN,GAAI,CAAC,CAAE,KAAAC,CAAK,EAAGC,IACND,EAAKC,CAAE,CAElB,ECDO,IAAMC,GAAuB,CAClC,KAAM,SACN,KAAM,SACN,GAAI,CACF,CAAE,SAAAC,EAAU,WAAAC,EAAY,KAAAC,CAAK,EAC7BC,EACAC,IACG,CACHF,EAAK,IAAM,CACT,IAAMG,EAASL,EAASI,CAAM,EAC9BE,GAAaD,EAAQ,IAAMF,CAAK,EAChCF,EAAWI,CAAM,CACnB,CAAC,CACH,CACF,ECdO,IAAME,GAA0B,CACrC,KAAM,SACN,KAAM,YACN,GAAI,CACF,CAAE,SAAAC,EAAU,WAAAC,EAAY,KAAAC,CAAK,EAC7BC,IACG,CACHD,EAAK,IAAM,CACT,IAAME,EAASJ,EAASG,CAAM,EAC9BE,GAAaD,EAASE,GAAkB,CAACA,CAAQ,EACjDL,EAAWG,CAAM,CACnB,CAAC,CACH,CACF,ECjBO,IAAMG,GAAwB,CACnC,KAAM,YACN,KAAM,OACN,OAAQ,OACR,aAAc,GACd,OAAQ,CAAC,CAAE,GAAAC,EAAI,OAAAC,EAAQ,IAAAC,EAAK,GAAAC,CAAG,IAAM,CACnC,IAAMC,EAAW,CAACF,EAAaG,IAAa,CACtCA,IAAQ,IAAMA,IAAQ,GACxBL,EAAG,aAAaE,EAAK,EAAE,EACdG,IAAQ,IAASA,IAAQ,MAAQA,IAAQ,OAClDL,EAAG,gBAAgBE,CAAG,EAEtBF,EAAG,aAAaE,EAAKG,CAAG,CAE5B,EACA,GAAIH,IAAQ,GAAI,CACd,IAAMI,EAAW,IAAI,iBAAiB,IAAM,CAC1CA,EAAS,WAAW,EACpB,IAAMC,EAAMJ,EAAG,EACf,OAAW,CAACD,EAAKG,CAAG,IAAK,OAAO,QAAQE,CAAG,EACzCH,EAASF,EAAKG,CAAG,EAEnBC,EAAS,QAAQN,EAAI,CACnB,gBAAiB,OAAO,KAAKO,CAAG,CAClC,CAAC,CACH,CAAC,EACKC,EAAUP,EAAO,IAAM,CAC3BK,EAAS,WAAW,EACpB,IAAMC,EAAMJ,EAAG,EACf,QAAWD,KAAOK,EAChBH,EAASF,EAAKK,EAAIL,CAAG,CAAC,EAExBI,EAAS,QAAQN,EAAI,CACnB,gBAAiB,OAAO,KAAKO,CAAG,CAClC,CAAC,CACH,CAAC,EAED,MAAO,IAAM,CACXD,EAAS,WAAW,EACpBE,EAAQ,CACV,CACF,CAEA,IAAMC,EAAIC,EAAMR,CAAG,EACbI,EAAW,IAAI,iBAAiB,IAAM,CAC1CA,EAAS,WAAW,EACpB,IAAMK,EAAQR,EAAW,EACzBC,EAASK,EAAGE,CAAK,EACjBL,EAAS,QAAQN,EAAI,CACnB,gBAAiB,CAACW,CAAK,CACzB,CAAC,CACH,CAAC,EACKH,EAAUP,EAAO,IAAM,CAC3BK,EAAS,WAAW,EACpB,IAAMK,EAAQR,EAAW,EACzBC,EAASK,EAAGE,CAAK,EACjBL,EAAS,QAAQN,EAAI,CACnB,gBAAiB,CAACW,CAAK,CACzB,CAAC,CACH,CAAC,EAED,MAAO,IAAM,CACXL,EAAS,WAAW,EACpBE,EAAQ,CACV,CACF,CACF,EChEA,IAAMI,GAAe,+CACfC,GAAW,qCACXC,GAAa,eAENC,GAAwB,CACnC,KAAM,YACN,KAAM,OACN,OAAQ,YACR,OAAQ,YACR,eAAgB,GAChB,OAAQ,CAAC,CACP,GAAAC,EACA,IAAAC,EACA,KAAAC,EACA,MAAAC,EACA,OAAAC,EACA,WAAAC,EACA,WAAAC,EACA,QAAAC,EACA,QAAAC,CACF,IAAM,CACJ,IAAMC,EAAaR,EAAMS,EAAaT,EAAKC,CAAI,EAAIC,EAEnD,GACGH,aAAc,kBAAoBH,GAAS,KAAKG,EAAG,IAAI,GACxDA,aAAc,oBACd,CACA,GAAI,MAAM,QAAQQ,EAAQC,CAAU,GAAKF,EAAQE,CAAU,CAAC,EAAG,CAE7D,IAAME,EAAiB,SAAS,iBAC9B,IAAIC,EAAS,MAAM,CAAC,IAAIX,CAAG,MAAMW,EAAS,MAAM,CAAC,KAAKT,CAAK,IAC7D,EAEIU,EAAa,EACXC,EAAkC,CAAC,EACzC,QAAWC,KAASJ,EAAgB,CAOlC,GANKH,EAAQ,GAAGC,CAAU,IAAII,CAAU,EAAE,IACxCC,EAAQ,GAAGL,CAAU,IAAII,CAAU,EAAE,EACnCE,EACA,OAGAf,IAAOe,EACT,MAEFF,GACF,CACAR,EAAWW,EAAU,CAAC,EAAGF,CAAO,CAAC,EAEjC,IAAMG,EAAa,IAAM,CACvBZ,EACEW,EAAU,CAAC,EAAG,CAAE,CAAC,GAAGP,CAAU,IAAII,CAAU,EAAE,EAAGb,EAAG,KAAM,CAAC,CAC7D,CACF,EAEAA,EAAG,iBAAiB,SAAUiB,CAAU,EACxCjB,EAAG,iBAAiB,QAASiB,CAAU,EAEvC,IAAMC,EAAUd,EACd,IAAOJ,EAAG,MAAQO,EAAQE,CAAU,EAAEI,CAAU,CAClD,EAEA,MAAO,IAAM,CACXK,EAAQ,EACRlB,EAAG,oBAAoB,SAAUiB,CAAU,EAC3CjB,EAAG,oBAAoB,QAASiB,CAAU,CAC5C,CACF,CAGAZ,EAAWW,EAAU,CAAC,EAAG,CAAE,CAACP,CAAU,EAAGT,EAAG,KAAM,CAAC,EAAG,CAAE,UAAW,EAAK,CAAC,EAEzE,IAAMiB,EAAa,IACjBZ,EAAWW,EAAU,CAAC,EAAG,CAAE,CAACP,CAAU,EAAGT,EAAG,KAAM,CAAC,CAAC,EACtDA,EAAG,iBAAiB,SAAUiB,CAAU,EACxCjB,EAAG,iBAAiB,QAASiB,CAAU,EAEvC,IAAMC,EAAUd,EAAO,IAAOJ,EAAG,MAAQO,EAAQE,CAAU,CAAE,EAE7D,MAAO,IAAM,CACXS,EAAQ,EACRlB,EAAG,oBAAoB,SAAUiB,CAAU,EAC3CjB,EAAG,oBAAoB,QAASiB,CAAU,CAC5C,CACF,CAEA,GAAIjB,aAAc,iBAAkB,CAClC,GAAIA,EAAG,OAAS,WAAY,CAC1B,GAAI,MAAM,QAAQQ,EAAQC,CAAU,GAAKF,EAAQE,CAAU,CAAC,EAAG,CAE7D,IAAME,EAAiB,SAAS,iBAC9B,IAAIC,EAAS,MAAM,CAAC,IAAIX,CAAG,MAAMW,EAAS,MAAM,CAAC,KAAKT,CAAK,IAC7D,EAEIU,EAAa,EACXC,EAA4C,CAAC,EACnD,QAAWC,KAASJ,EAAgB,CAClC,GAAI,CAACH,EAAQ,GAAGC,CAAU,IAAII,CAAU,EAAE,EAAG,CAC3C,IAAMM,EAAMJ,EAAM,aAAa,OAAO,EACtCD,EAAQ,GAAGL,CAAU,IAAII,CAAU,EAAE,EAAIM,EACpCJ,EAA2B,QAC1BI,EACA,GACDJ,EAA2B,OAClC,CAEA,GAAIf,IAAOe,EACT,MAEFF,GACF,CACAR,EAAWW,EAAU,CAAC,EAAGF,CAAO,CAAC,EAEjC,IAAMG,EAAa,IAAM,CACvB,IAAME,EAAMnB,EAAG,aAAa,OAAO,EACnCK,EACEW,EACE,CAAC,EACD,CACE,CAAC,GAAGP,CAAU,IAAII,CAAU,EAAE,EAAGM,EAC7BnB,EAAG,QACDmB,EACA,GACFnB,EAAG,OACT,CACF,CACF,CACF,EAEAA,EAAG,iBAAiB,SAAUiB,CAAU,EACxCjB,EAAG,iBAAiB,QAASiB,CAAU,EAEvC,IAAMC,EAAUd,EAAO,IAAM,CAC3B,IAAMe,EAAMnB,EAAG,aAAa,OAAO,EACnCA,EAAG,QAAUmB,EACTA,IAAQZ,EAAQE,CAAU,EAAEI,CAAU,EACtCN,EAAQE,CAAU,EAAEI,CAAU,CACpC,CAAC,EAED,MAAO,IAAM,CACXK,EAAQ,EACRlB,EAAG,oBAAoB,SAAUiB,CAAU,EAC3CjB,EAAG,oBAAoB,QAASiB,CAAU,CAC5C,CACF,CAEA,IAAME,EAAMnB,EAAG,aAAa,OAAO,EACnCK,EACEW,EACE,CAAC,EACD,CAAE,CAACP,CAAU,EAAGU,EAAOnB,EAAG,QAAUmB,EAAM,GAAMnB,EAAG,OAAQ,CAC7D,CACF,EAEA,IAAMiB,EAAa,IAAM,CACvB,IAAME,EAAMnB,EAAG,aAAa,OAAO,EACnCK,EACEW,EACE,CAAC,EACD,CAAE,CAACP,CAAU,EAAGU,EAAOnB,EAAG,QAAUmB,EAAM,GAAMnB,EAAG,OAAQ,CAC7D,CACF,CACF,EACAA,EAAG,iBAAiB,SAAUiB,CAAU,EACxCjB,EAAG,iBAAiB,QAASiB,CAAU,EAEvC,IAAMC,EAAUd,EAAO,IAAM,CAC3B,IAAMe,EAAMnB,EAAG,aAAa,OAAO,EACnCA,EAAG,QAAUmB,EAAMA,IAAQZ,EAAQE,CAAU,EAAIF,EAAQE,CAAU,CACrE,CAAC,EAED,MAAO,IAAM,CACXS,EAAQ,EACRlB,EAAG,oBAAoB,SAAUiB,CAAU,EAC3CjB,EAAG,oBAAoB,QAASiB,CAAU,CAC5C,CACF,CAEA,GAAIjB,EAAG,OAAS,QAAS,CAElBA,EAAG,aAAa,MAAM,GAAG,QAC5BA,EAAG,aAAa,OAAQS,CAAU,EAGpCJ,EAAWW,EAAU,CAAC,EAAG,CAAE,CAACP,CAAU,EAAGT,EAAG,KAAM,CAAC,EAAG,CACpD,UAAW,EACb,CAAC,EAED,IAAMiB,EAAa,IACjBjB,EAAG,SAAWK,EAAWW,EAAU,CAAC,EAAG,CAAE,CAACP,CAAU,EAAGT,EAAG,KAAM,CAAC,CAAC,EACpEA,EAAG,iBAAiB,SAAUiB,CAAU,EACxCjB,EAAG,iBAAiB,QAASiB,CAAU,EAEvC,IAAMC,EAAUd,EACd,IAAOJ,EAAG,QAAUA,EAAG,QAAUO,EAAQE,CAAU,CACrD,EAEA,MAAO,IAAM,CACXS,EAAQ,EACRlB,EAAG,oBAAoB,SAAUiB,CAAU,EAC3CjB,EAAG,oBAAoB,QAASiB,CAAU,CAC5C,CACF,CAEA,GAAInB,GAAW,KAAKE,EAAG,IAAI,EAAG,CAC5BK,EAAWW,EAAU,CAAC,EAAG,CAAE,CAACP,CAAU,EAAG,CAACT,EAAG,KAAM,CAAC,EAAG,CACrD,UAAW,EACb,CAAC,EAED,IAAMiB,EAAa,IACjBZ,EAAWW,EAAU,CAAC,EAAG,CAAE,CAACP,CAAU,EAAG,CAACT,EAAG,KAAM,CAAC,CAAC,EACvDA,EAAG,iBAAiB,SAAUiB,CAAU,EACxCjB,EAAG,iBAAiB,QAASiB,CAAU,EAEvC,IAAMC,EAAUd,EAAO,IAAOJ,EAAG,MAAQO,EAAQE,CAAU,CAAE,EAE7D,MAAO,IAAM,CACXS,EAAQ,EACRlB,EAAG,oBAAoB,SAAUiB,CAAU,EAC3CjB,EAAG,oBAAoB,QAASiB,CAAU,CAC5C,CACF,CAEA,GAAIjB,EAAG,OAAS,OAAQ,CACtB,IAAMiB,EAAa,IAAM,CACvB,IAAMG,EAAQ,CAAC,GAAIpB,EAAG,OAAS,CAAC,CAAE,EAC5BqB,EAAwB,CAAC,EACzBC,EAAqB,CAAC,EACtBC,EAAqB,CAAC,EAC5B,QAAQ,IACNH,EAAM,IACHI,GACC,IAAI,QAAeC,GAAY,CAC7B,IAAMC,EAAS,IAAI,WACnBA,EAAO,OAAS,IAAM,CACpB,GAAI,OAAOA,EAAO,QAAW,SAC3B,MAAMpB,EAAW,wBAAyB,CACxC,WAAY,OAAOoB,EAAO,MAC5B,CAAC,EAEH,IAAMC,EAAQD,EAAO,OAAO,MAAM9B,EAAY,EAC9C,GAAI,CAAC+B,GAAO,OACV,MAAMrB,EAAW,iBAAkB,CACjC,OAAQoB,EAAO,MACjB,CAAC,EAEHL,EAAY,KAAKM,EAAM,OAAO,QAAQ,EACtCL,EAAS,KAAKK,EAAM,OAAO,IAAI,EAC/BJ,EAAS,KAAKC,EAAE,IAAI,CACtB,EACAE,EAAO,UAAY,IAAMD,EAAQ,EACjCC,EAAO,cAAcF,CAAC,CACxB,CAAC,CACL,CACF,EAAE,KAAK,IAAM,CACXnB,EACEW,EACE,CAAC,EACD,CACE,CAACP,CAAU,EAAGY,EACd,CAAC,GAAGZ,CAAU,OAAO,EAAGa,EACxB,CAAC,GAAGb,CAAU,OAAO,EAAGc,CAC1B,CACF,CACF,CACF,CAAC,CACH,EAEA,OAAAvB,EAAG,iBAAiB,SAAUiB,CAAU,EACxCjB,EAAG,iBAAiB,QAASiB,CAAU,EAEhC,IAAM,CACXjB,EAAG,oBAAoB,SAAUiB,CAAU,EAC3CjB,EAAG,oBAAoB,QAASiB,CAAU,CAC5C,CACF,CAEF,CAEA,GAAIjB,aAAc,kBAAmB,CACnC,GAAIA,EAAG,SAAU,CAEfK,EACEW,EACE,CAAC,EACD,CACE,CAACP,CAAU,EAAG,CAAC,GAAGT,EAAG,eAAe,EAAE,IACnC4B,GAAWA,EAAO,KACrB,CACF,CACF,EACA,CACE,UAAW,EACb,CACF,EAEA,IAAMX,EAAa,IACjBZ,EACEW,EACE,CAAC,EACD,CACE,CAACP,CAAU,EAAG,CAAC,GAAGT,EAAG,eAAe,EAAE,IACnC4B,GAAWA,EAAO,KACrB,CACF,CACF,CACF,EACF5B,EAAG,iBAAiB,SAAUiB,CAAU,EACxCjB,EAAG,iBAAiB,QAASiB,CAAU,EAEvC,IAAMC,EAAUd,EAAO,IAAM,CAC3B,IAAMyB,EAAwBtB,EAAQE,CAAU,EAChD,QAAWmB,KAAU5B,EAAG,QACtB4B,EAAO,SAAWC,EAAY,SAASD,EAAO,KAAK,CAEvD,CAAC,EAED,MAAO,IAAM,CACXV,EAAQ,EACRlB,EAAG,oBAAoB,SAAUiB,CAAU,EAC3CjB,EAAG,oBAAoB,QAASiB,CAAU,CAC5C,CACF,CAGAZ,EACEW,EACE,CAAC,EACD,CACE,CAACP,CAAU,EAAGT,EAAG,KACnB,CACF,EACA,CACE,UAAW,EACb,CACF,EAEA,IAAMiB,EAAa,IACjBZ,EACEW,EACE,CAAC,EACD,CACE,CAACP,CAAU,EAAGT,EAAG,KACnB,CACF,CACF,EACFA,EAAG,iBAAiB,SAAUiB,CAAU,EACxCjB,EAAG,iBAAiB,QAASiB,CAAU,EAGvC,IAAMC,EAAUd,EADI,IAAOJ,EAAG,MAAQO,EAAQE,CAAU,CACtB,EAElC,MAAO,IAAM,CACXS,EAAQ,EACRlB,EAAG,oBAAoB,SAAUiB,CAAU,EAC3CjB,EAAG,oBAAoB,QAASiB,CAAU,CAC5C,CACF,CAEAZ,EAAWW,EAAU,CAAC,EAAG,CAAE,CAACP,CAAU,EAAGT,EAAG,aAAa,OAAO,CAAE,CAAC,EAAG,CACpE,UAAW,EACb,CAAC,EAED,IAAMkB,EAAUd,EAAO,IAAM,CAC3B,IAAM0B,EAAWvB,EAAQE,CAAU,EAC/BT,EAAG,aAAa,OAAO,IAAM8B,GAC/B9B,EAAG,aAAa,QAAS8B,CAAQ,CAErC,CAAC,EACKb,EAAcc,GAClB1B,EACEW,EACE,CAAC,EACD,CAAE,CAACP,CAAU,EAAIsB,EAAI,QAAoC,KAAM,CACjE,CACF,EACF,OAAA/B,EAAG,iBAAiB,SAAUiB,CAAU,EACxCjB,EAAG,iBAAiB,QAASiB,CAAU,EAEhC,IAAM,CACXC,EAAQ,EACRlB,EAAG,oBAAoB,SAAUiB,CAAU,EAC3CjB,EAAG,oBAAoB,QAASiB,CAAU,CAC5C,CACF,CACF,ECnYO,IAAMe,GAAyB,CACpC,KAAM,YACN,KAAM,QACN,OAAQ,OACR,aAAc,GACd,OAAQ,CAAC,CAAE,IAAAC,EAAK,GAAAC,EAAI,OAAAC,EAAQ,KAAAC,EAAM,GAAAC,CAAG,IAAM,CACrCJ,IACFA,EAAMK,EAAaC,EAAMN,CAAG,EAAGG,CAAI,GAGrC,IAAMI,EAAW,IAAM,CACrBC,EAAS,WAAW,EAEpB,IAAMC,EAAUT,EACZ,CAAE,CAACA,CAAG,EAAGI,EAAY,CAAE,EACvBA,EAA4B,EAEhC,QAAWM,KAAKD,EAAS,CACvB,IAAME,EAAaD,EAAE,MAAM,KAAK,EAAE,OAAQE,GAAOA,EAAG,OAAS,CAAC,EAC9D,GAAIH,EAAQC,CAAC,EACX,QAAWG,KAAQF,EACjBV,EAAG,UAAU,IAAIY,CAAI,MAGvB,SAAWA,KAAQF,EACjBV,EAAG,UAAU,OAAOY,CAAI,CAG9B,CAEAL,EAAS,QAAQP,EAAI,CAAE,gBAAiB,CAAC,OAAO,CAAE,CAAC,CACrD,EAEMO,EAAW,IAAI,iBAAiBD,CAAQ,EACxCO,EAAUZ,EAAOK,CAAQ,EAE/B,MAAO,IAAM,CACXC,EAAS,WAAW,EACpBM,EAAQ,EAER,IAAML,EAAUT,EACZ,CAAE,CAACA,CAAG,EAAGI,EAAY,CAAE,EACvBA,EAA4B,EAEhC,QAAWM,KAAKD,EAAS,CACvB,IAAME,EAAaD,EAAE,MAAM,KAAK,EAAE,OAAQE,GAAOA,EAAG,OAAS,CAAC,EAC9D,QAAWC,KAAQF,EACjBV,EAAG,UAAU,OAAOY,CAAI,CAE5B,CACF,CACF,CACF,ECnDO,IAAME,GAA4B,CACvC,KAAM,YACN,KAAM,WACN,OAAQ,OACR,OAAQ,OACR,aAAc,GACd,OAAQ,CAAC,CAAE,IAAAC,EAAK,KAAAC,EAAM,GAAAC,EAAI,SAAAC,EAAU,WAAAC,CAAW,IAAM,CACnDA,EAAWC,EAAU,CAAC,EAAG,CAAE,CAACC,EAAaN,EAAKC,CAAI,CAAC,EAAGE,EAASD,CAAE,CAAE,CAAC,CAAC,CACvE,CACF,ECXO,IAAMK,GAA0B,CACrC,KAAM,YACN,KAAM,SACN,OAAQ,SACR,OAAQ,OACR,OAAQ,CAAC,CAAE,OAAAC,EAAQ,GAAAC,CAAG,IAAMD,EAAOC,CAAE,CACvC,ECTO,IAAMC,EAAqB,GAAGC,CAAQ,OAChCC,GAAU,UACVC,GAAW,WACXC,GAAQ,QACRC,GAAW,WACXC,GAAiB,WA+BvB,SAASC,GACdC,EACAC,EACA,CACA,SAAS,iBACPT,EACCU,GAAyC,CACxC,GAAIA,EAAM,OAAO,OAASF,EAAW,CACnC,GAAM,CAAE,QAAAG,CAAQ,EAAID,EAAM,OAC1BD,EAAGE,CAAO,CACZ,CACF,CACF,CACF,CCtCO,IAAMC,GAA6B,CACxC,KAAM,YACN,KAAM,YACN,OAAQ,YACR,OAAQ,YACR,eAAgB,GAChB,OAAQ,CAAC,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,EAAM,WAAAC,EAAY,MAAAC,CAAM,IAAM,CAChD,IAAMC,EAAaJ,EAAMK,EAAaL,EAAKC,CAAI,EAAIE,EAEnDD,EAAWI,EAAU,CAAC,EAAG,CAAE,CAACF,CAAU,EAAG,EAAM,CAAC,EAAG,CAAE,UAAW,EAAK,CAAC,EAEtE,IAAMG,EAAYC,GAAyC,CACzD,GAAM,CAAE,KAAAC,EAAM,GAAIC,CAAI,EAAIF,EAAM,OAChC,GAAIE,IAAQX,EAGZ,OAAQU,EAAM,CACZ,KAAKE,GACHT,EAAWI,EAAU,CAAC,EAAG,CAAE,CAACF,CAAU,EAAG,EAAK,CAAC,CAAC,EAChD,MACF,KAAKQ,GACHV,EAAWI,EAAU,CAAC,EAAG,CAAE,CAACF,CAAU,EAAG,EAAM,CAAC,CAAC,EACjD,KACJ,CACF,EACA,gBAAS,iBAAiBS,EAAoBN,CAAO,EAC9C,IAAM,CACXL,EAAWI,EAAU,CAAC,EAAG,CAAE,CAACF,CAAU,EAAG,EAAM,CAAC,CAAC,EACjD,SAAS,oBAAoBS,EAAoBN,CAAO,CAC1D,CACF,CACF,ECtCO,IAAMO,GAA+B,CAC1C,KAAM,YACN,KAAM,cACN,OAAQ,SACR,OAAQ,CAAC,CAAE,GAAAC,EAAI,OAAAC,EAAQ,MAAAC,EAAO,SAAAC,EAAU,KAAAC,CAAK,IAAM,CACjD,IAAMC,EAASD,EAAK,IAAI,OAAO,EAAI,EAAI,EACnCE,EAA+B,CAAC,EAChCJ,IACFI,EAAUC,GAAcL,CAAK,GAG/B,IAAMM,EAAW,IAAM,CACrBC,EAAS,WAAW,EACpBT,EAAG,YAAc,KAAK,UAAUG,EAASG,CAAO,EAAG,KAAMD,CAAM,EAC/DI,EAAS,QAAQT,EAAI,CACnB,UAAW,EACb,CAAC,CACH,EACMS,EAAW,IAAI,iBAAiBD,CAAQ,EACxCE,EAAUT,EAAOO,CAAQ,EAE/B,MAAO,IAAM,CACXC,EAAS,WAAW,EACpBC,EAAQ,CACV,CACF,CACF,ECjCO,SAASC,EAAQC,EAAmB,CACzC,GAAI,CAACA,GAAQA,EAAK,MAAQ,EAAG,MAAO,GACpC,QAAWC,KAAOD,EAAM,CACtB,GAAIC,EAAI,SAAS,IAAI,EACnB,MAAO,CAACA,EAAI,QAAQ,KAAM,EAAE,EAE9B,GAAIA,EAAI,SAAS,GAAG,EAClB,MAAO,CAACA,EAAI,QAAQ,IAAK,EAAE,EAAI,IAEjC,GAAI,CACF,OAAO,OAAO,WAAWA,CAAG,CAC9B,MAAY,CAAC,CACf,CACA,MAAO,EACT,CAEO,SAASC,EAAOC,EAAmBC,EAAaC,EAAe,GAAO,CAC3E,OAAKF,EACEA,EAAK,IAAIC,EAAI,YAAY,CAAC,EADfC,CAEpB,CChBO,SAASC,GACdC,EACAC,EACsB,CACtB,MAAO,IAAIC,IAAgB,CACzB,WAAW,IAAM,CACfF,EAAS,GAAGE,CAAI,CAClB,EAAGD,CAAI,CACT,CACF,CAEO,SAASE,GACdH,EACAC,EACAG,EAAU,GACVC,EAAW,GACW,CACtB,IAAIC,EAAQ,EACZ,MAAO,IAAIJ,IAAgB,CACzBI,GAAS,aAAaA,CAAK,EAEvBF,GAAW,CAACE,GACdN,EAAS,GAAGE,CAAI,EAGlBI,EAAQ,WAAW,IAAM,CACnBD,GACFL,EAAS,GAAGE,CAAI,EAElBI,GAAS,aAAaA,CAAK,CAC7B,EAAGL,CAAI,CACT,CACF,CAEO,SAASM,GACdP,EACAC,EACAG,EAAU,GACVC,EAAW,GACW,CACtB,IAAIG,EAAU,GAEd,MAAO,IAAIN,IAAgB,CACrBM,IAEAJ,GACFJ,EAAS,GAAGE,CAAI,EAGlBM,EAAU,GACV,WAAW,IAAM,CACfA,EAAU,GACNH,GACFL,EAAS,GAAGE,CAAI,CAEpB,EAAGD,CAAI,EACT,CACF,CAEO,SAASQ,GACdT,EACAU,EACsB,CACtB,IAAMC,EAAYD,EAAK,IAAI,OAAO,EAClC,GAAIC,EAAW,CACb,IAAMV,EAAOW,EAAQD,CAAS,EAC9BX,EAAWD,GAAMC,EAAUC,CAAI,CACjC,CAEA,IAAMY,EAAeH,EAAK,IAAI,UAAU,EACxC,GAAIG,EAAc,CAChB,IAAMZ,EAAOW,EAAQC,CAAY,EAC3BT,EAAUU,EAAOD,EAAc,UAAW,EAAK,EAC/CR,EAAW,CAACS,EAAOD,EAAc,UAAW,EAAK,EACvDb,EAAWG,GAASH,EAAUC,EAAMG,EAASC,CAAQ,CACvD,CAEA,IAAMU,EAAeL,EAAK,IAAI,UAAU,EACxC,GAAIK,EAAc,CAChB,IAAMd,EAAOW,EAAQG,CAAY,EAC3BX,EAAU,CAACU,EAAOC,EAAc,YAAa,EAAK,EAClDV,EAAWS,EAAOC,EAAc,QAAS,EAAK,EACpDf,EAAWO,GAASP,EAAUC,EAAMG,EAASC,CAAQ,CACvD,CAEA,OAAOL,CACT,CC1EO,IAAMgB,GAA0B,CAAC,CAAC,SAAS,oBAE3C,SAASC,EACdC,EACAC,EACsB,CACtB,GAAIA,EAAK,IAAI,gBAAgB,GAAKH,GAAyB,CACzD,IAAMI,EAAKF,EACXA,EAAW,IAAIG,IACb,SAAS,oBAAoB,IAAMD,EAAG,GAAGC,CAAI,CAAC,CAClD,CAEA,OAAOH,CACT,CCfO,IAAMI,GAAsB,CACjC,KAAM,YACN,KAAM,KACN,OAAQ,OACR,OAAQ,OACR,SAAU,CAAC,KAAK,EAChB,OAASC,GAAQ,CACf,GAAM,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,EAAM,GAAAC,EAAI,WAAAC,EAAY,SAAAC,CAAS,EAAIN,EAChDO,EAAsCN,EACtCE,EAAK,IAAI,QAAQ,IAAGI,EAAS,QACjC,IAAIC,EAAYC,GAAgB,CAC9B,GAAIA,EAAK,CAQP,GAPIN,EAAK,IAAI,SAAS,GACpBM,EAAI,eAAe,EAEjBN,EAAK,IAAI,MAAM,GACjBM,EAAI,gBAAgB,EAIpB,EAAEA,EAAI,WAAaA,aAAe,aAAeN,EAAK,IAAI,SAAS,GAEnE,OAEFH,EAAI,IAAMS,CACZ,CACAJ,EAAW,EACXD,EAAGK,CAAG,EACNH,EAAS,CACX,EACAE,EAAWE,GAAaF,EAAUL,CAAI,EACtCK,EAAWG,EAAqBH,EAAUL,CAAI,EAC9C,IAAMS,EAAuC,CAC3C,QAAST,EAAK,IAAI,SAAS,EAC3B,QAASA,EAAK,IAAI,SAAS,EAC3B,KAAMA,EAAK,IAAI,MAAM,CACvB,EACA,GAAIA,EAAK,IAAI,SAAS,EAAG,CACvBI,EAAS,SACT,IAAMM,EAAKL,EACXA,EAAYC,GAAgB,CACrBR,EAAG,SAASQ,GAAK,MAAqB,GACzCI,EAAGJ,CAAG,CAEV,CACF,CAEA,IAAIK,EAAYC,EAAMb,CAAG,EAUzB,GATAY,EAAYE,EAAaF,EAAWX,CAAI,GAGtCW,IAAcG,GACdH,IAAcI,KAEdX,EAAS,UAGPN,aAAc,iBAAmBa,IAAc,SAAU,CAC3D,IAAMD,EAAKL,EACXA,EAAYC,GAAgB,CAC1BA,GAAK,eAAe,EACpBI,EAAGJ,CAAG,CACR,CACF,CACA,OAAAF,EAAO,iBAAiBO,EAAWN,EAAUI,CAAW,EACjD,IAAM,CACXL,EAAO,oBAAoBO,EAAWN,CAAQ,CAChD,CACF,CACF,EC1EA,IAAMW,GAAO,IAAI,QAEJC,GAA+B,CAC1C,KAAM,YACN,KAAM,cACN,OAAQ,SACR,OAAQ,CAAC,CAAE,GAAAC,EAAI,KAAAC,EAAM,GAAAC,EAAI,WAAAC,EAAY,SAAAC,CAAS,IAAM,CAClD,IAAIC,EAAW,IAAM,CACnBF,EAAW,EACXD,EAAG,EACHE,EAAS,CACX,EACAC,EAAWC,GAAaD,EAAUJ,CAAI,EACtCI,EAAWE,EAAqBF,EAAUJ,CAAI,EAC9C,IAAMO,EAAU,CAAE,UAAW,CAAE,EAC3BP,EAAK,IAAI,MAAM,EACjBO,EAAQ,UAAY,EACXP,EAAK,IAAI,MAAM,IACxBO,EAAQ,UAAY,IAEtB,IAAIC,EAAwC,IAAI,qBAC7CC,GAAY,CACX,QAAWC,KAASD,EACdC,EAAM,iBACRN,EAAS,EACLI,GAAYX,GAAK,IAAIE,CAAE,GACzBS,EAAS,WAAW,EAI5B,EACAD,CACF,EACA,OAAAC,EAAS,QAAQT,CAAE,EACfC,EAAK,IAAI,MAAM,GACjBH,GAAK,IAAIE,CAAE,EAEN,IAAM,CACNC,EAAK,IAAI,MAAM,GAClBH,GAAK,OAAOE,CAAE,EAEZS,IACFA,EAAS,WAAW,EACpBA,EAAW,KAEf,CACF,CACF,EC/CO,IAAMG,GAA8B,CACzC,KAAM,YACN,KAAM,aACN,OAAQ,SACR,OAAQ,OACR,OAAQ,CAAC,CAAE,KAAAC,EAAM,GAAAC,EAAI,WAAAC,EAAY,SAAAC,CAAS,IAAM,CAC9C,IAAIC,EAAW,IAAM,CACnBF,EAAW,EACXD,EAAG,EACHE,EAAS,CACX,EACAC,EAAWC,EAAqBD,EAAUJ,CAAI,EAC9C,IAAIM,EAAW,IACTC,EAAeP,EAAK,IAAI,UAAU,EACpCO,IACFD,EAAWE,EAAQD,CAAY,EACfE,EAAOF,EAAc,UAAW,EAAK,GAEnDH,EAAS,GAGb,IAAMM,EAAa,YAAYN,EAAUE,CAAQ,EACjD,MAAO,IAAM,CACX,cAAcI,CAAU,CAC1B,CACF,CACF,ECzBO,IAAMC,GAA0B,CACrC,KAAM,YACN,KAAM,SACN,OAAQ,SACR,OAAQ,OACR,OAAQ,CAAC,CAAE,GAAAC,EAAI,KAAAC,EAAM,WAAAC,EAAY,SAAAC,CAAS,IAAM,CAC9C,IAAIC,EAAW,IAAM,CACnBF,EAAW,EACXF,EAAG,EACHG,EAAS,CACX,EACAC,EAAWC,EAAqBD,EAAUH,CAAI,EAC9C,IAAIK,EAAO,EACLC,EAAYN,EAAK,IAAI,OAAO,EAC9BM,IACFD,EAAOE,EAAQD,CAAS,GAG1BH,EAAWK,GAAML,EAAUE,CAAI,EAC/BF,EAAS,CACX,CACF,EChBO,IAAMM,GAAiC,CAC5C,KAAM,YACN,KAAM,gBACN,OAAQ,OACR,SAAU,CAAC,OAAO,EAClB,aAAc,GACd,OAAQ,CAAC,CACP,GAAAC,EACA,IAAAC,EACA,KAAAC,EACA,OAAAC,EACA,GAAAC,EACA,SAAAC,EACA,WAAAC,EACA,WAAAC,EACA,SAAAC,CACF,IAAM,CAEJ,GAAMP,GAAOA,IAAQ,SACnB,MAAMK,EAAW,GAAGH,EAAO,IAAI,eAAe,EAIhD,IAAMM,EAAaT,EAAG,aAAa,6BAA6B,EAC5DU,EAA+B,CAAC,EAChCD,IACFC,EAAUC,GAAcF,CAAU,GAGpC,IAAMG,EAA0BC,GAC7BC,GAAgC,CAC/B,IAAMC,EAAUV,EAASK,EAASI,EAAI,MAAM,EACvCE,GAAQD,CAAO,IAClBR,EAAW,EACXH,EAAGW,CAAO,EACVP,EAAS,EAEb,EACAN,CACF,EAEA,gBAAS,iBAAiBe,EAA6BL,CAAQ,EACxD,IAAM,CACX,SAAS,oBAAoBK,EAA6BL,CAAQ,CACpE,CACF,CACF,ECnDO,IAAMM,GAAuB,CAClC,KAAM,YACN,KAAM,MACN,OAAQ,YACR,OAAQ,YACR,eAAgB,GAChB,OAAQ,CAAC,CAAE,GAAAC,EAAI,IAAAC,EAAK,KAAAC,EAAM,MAAAC,EAAO,WAAAC,CAAW,IAAM,CAChD,IAAMC,EAAaJ,EAAMK,EAAaL,EAAKC,CAAI,EAAIC,EAEnDC,EAAWG,EAAU,CAAC,EAAG,CAAE,CAACF,CAAU,EAAGL,CAAG,CAAC,CAAC,CAChD,CACF,ECdA,IAAMQ,GAAO,OACPC,GAAU,UAEHC,GAAwB,CACnC,KAAM,YACN,KAAM,OACN,OAAQ,SACR,OAAQ,OACR,aAAc,GACd,OAAQ,CAAC,CAAE,GAAAC,EAAI,OAAAC,EAAQ,GAAAC,CAAG,IAAM,CAC9B,IAAMC,EAAS,IAAM,CACnBC,EAAS,WAAW,EACDF,EAAG,EAEhBF,EAAG,MAAM,UAAYH,IAAMG,EAAG,MAAM,eAAeF,EAAO,EAE9DE,EAAG,MAAM,YAAYF,GAASD,EAAI,EAEpCO,EAAS,QAAQJ,EAAI,CAAE,gBAAiB,CAAC,OAAO,CAAE,CAAC,CACrD,EACMI,EAAW,IAAI,iBAAiBD,CAAM,EACtCE,EAAUJ,EAAOE,CAAM,EAE7B,MAAO,IAAM,CACXC,EAAS,WAAW,EACpBC,EAAQ,CACV,CACF,CACF,EC1BO,IAAMC,GAA2B,CACtC,KAAM,YACN,KAAM,UACN,aAAc,GACd,OAAQ,CAAC,CAAE,IAAAC,EAAK,KAAAC,EAAM,GAAAC,EAAI,WAAAC,CAAW,IAAM,CACzC,IAAMC,EAAYH,EAAK,IAAI,WAAW,EAEtC,GAAID,EACFA,EAAMK,EAAaL,EAAKC,CAAI,EAC5BE,EAAWG,EAAU,CAAC,EAAG,CAAE,CAACN,CAAG,EAAGE,EAAG,CAAE,CAAC,EAAG,CAAE,UAAAE,CAAU,CAAC,MACnD,CACL,IAAMG,EAAQL,EAAwB,EAChCM,EAA+B,CAAC,EACtC,QAAWR,KAAOO,EAChBC,EAAQR,CAAG,EAAIO,EAAMP,CAAG,EAE1BG,EAAWG,EAAU,CAAC,EAAGE,CAAO,EAAG,CAAE,UAAAJ,CAAU,CAAC,CAClD,CACF,CACF,ECrBO,IAAMK,GAAwB,CACnC,KAAM,YACN,KAAM,OACN,OAAQ,SACR,OAAQ,OACR,aAAc,GACd,OAAQ,CAAC,CAAE,GAAAC,EAAI,OAAAC,EAAQ,GAAAC,CAAG,IAAM,CAC9B,IAAMC,EAAS,IAAM,CACnBC,EAAS,WAAW,EACpBJ,EAAG,YAAc,GAAGE,EAAG,CAAC,GACxBE,EAAS,QAAQJ,EAAI,CAAE,UAAW,EAAK,CAAC,CAC1C,EACMI,EAAW,IAAI,iBAAiBD,CAAM,EACtCE,EAAUJ,EAAOE,CAAM,EAE7B,MAAO,IAAM,CACXC,EAAS,WAAW,EACpBC,EAAQ,CACV,CACF,CACF,ECAA,IAAMC,GAAuB,IAAI,QAGpBC,EAAmB,CAC9BC,EACAC,KACkB,CAClB,KAAM,SACN,KAAAD,EACA,GAAI,MAAOE,EAAKC,EAAaC,IAAoB,CAC/C,GAAM,CAAE,GAAAC,CAAG,EAAIH,EAGfJ,GAAqB,IAAIO,CAAE,GAAG,MAAM,EAGpC,IAAMC,EAAa,IAAI,gBACvBR,GAAqB,IAAIO,EAAIC,CAAU,EAEvC,GAAI,CAEF,MAAMC,GAAIL,EAAKD,EAAQE,EAAKC,EAAME,EAAW,MAAM,CACrD,QAAE,CAEIR,GAAqB,IAAIO,CAAE,IAAMC,GACnCR,GAAqB,OAAOO,CAAE,CAElC,CACF,CACF,GAEMG,EAAc,CAClBC,EACAJ,EACAK,IAEA,SAAS,cACP,IAAI,YAA8BC,EAAoB,CACpD,OAAQ,CAAE,KAAAF,EAAM,GAAAJ,EAAI,QAAAK,CAAQ,CAC9B,CAAC,CACH,EAEIE,GAAkBC,GAAa,GAAGA,CAAG,GAAG,SAAS,mBAAmB,EAyB7DN,GAAM,MACjB,CAAE,GAAAF,EAAI,IAAAS,EAAK,SAAAC,EAAU,WAAAC,CAAW,EAChCf,EACAE,EACA,CACE,SAAAc,EACA,QAASC,EACT,YAAAC,EAAc,OACd,cAAAC,EAAgB,CAAE,QAAS,KAAM,QAAS,SAAU,EACpD,eAAAC,EAAiB,GACjB,cAAAC,EAAgBC,GAChB,YAAAC,EAAc,EACd,eAAAC,EAAiB,IACjB,cAAAC,EAAgB,EAClB,EAAe,CAAC,EAChBC,IACG,CACH,IAAMC,EAAS3B,EAAO,YAAY,EAC9B4B,EAAY,IAAM,CAAC,EACvB,GAAI,CACF,GAAI,CAAC1B,GAAK,OACR,MAAMa,EAAW,mBAAoB,CAAE,OAAAY,CAAO,CAAC,EAGjD,IAAME,EAAsC,CAC1C,OAAQ,iDACR,CAACC,EAAgB,EAAG,EACtB,EACIZ,IAAgB,SAClBW,EAAe,cAAc,EAAI,oBAEnC,IAAME,EAAU,OAAO,OAAO,CAAC,EAAGF,EAAgBZ,CAAW,EAKvDe,EAA4B,CAChC,OAAAhC,EACA,QAAA+B,EACA,eAAAX,EACA,cAAAC,EACA,YAAAE,EACA,eAAAC,EACA,cAAAC,EACA,OAAQC,EACR,OAAQ,MAAOO,GAAuB,CAChCA,EAAS,QAAU,KACrB1B,EAAY2B,GAAO9B,EAAI,CAAE,OAAQ6B,EAAS,OAAO,SAAS,CAAE,CAAC,CACjE,EACA,UAAYpB,GAAQ,CAClB,GAAI,CAACA,EAAI,MAAM,WAAWsB,CAAQ,EAAG,OACrC,IAAM3B,EAAOK,EAAI,MACXuB,EAAyC,CAAC,EAEhD,QAAWC,KAAQxB,EAAI,KAAK,MAAM;AAAA,CAAI,EAAG,CACvC,IAAMyB,EAAID,EAAK,QAAQ,GAAG,EACpBE,EAAIF,EAAK,MAAM,EAAGC,CAAC,EACnBE,EAAIH,EAAK,MAAMC,EAAI,CAAC,GACxBF,EAAaG,CAAC,IAAM,CAAC,GAAG,KAAKC,CAAC,CAClC,CAEA,IAAM/B,EAAU,OAAO,YACrB,OAAO,QAAQ2B,CAAY,EAAE,IAAI,CAAC,CAACG,EAAGC,CAAC,IAAM,CAACD,EAAGC,EAAE,KAAK;AAAA,CAAI,CAAC,CAAC,CAChE,EAEAjC,EAAYC,EAAMJ,EAAIK,CAAO,CAC/B,EACA,QAAUgC,GAAU,CAClB,GAAI9B,GAAe8B,CAAK,EAEtB,MAAM1B,EAAW,qBAAsB,CAAE,IAAAb,CAAI,CAAC,EAG5CuC,IACF,QAAQ,MAAMA,EAAM,OAAO,EAC3BlC,EAAYmC,GAAUtC,EAAI,CAAE,QAASqC,EAAM,OAAQ,CAAC,EAExD,CACF,EAEME,EAAc,IAAI,IAAIzC,EAAK,OAAO,SAAS,IAAI,EAC/C0C,EAAc,IAAI,gBAAgBD,EAAY,MAAM,EAE1D,GAAIzB,IAAgB,OAAQ,CAC1B,IAAM2B,EAAM,KAAK,UAAU/B,EAASK,CAAa,CAAC,EAC9CnB,IAAW,MACb4C,EAAY,IAAIT,EAAUU,CAAG,EAE7Bb,EAAI,KAAOa,CAEf,SAAW3B,IAAgB,OAAQ,CACjC,IAAM4B,EACJ9B,EAAW,SAAS,cAAcA,CAAQ,EAAIZ,EAAG,QAAQ,MAAM,EAEjE,GAAI,CAAC0C,EACH,MAAM/B,EACJC,EAAW,kBAAoB,yBAC/B,CAAE,OAAAW,EAAQ,SAAAX,CAAS,CACrB,EAIF,GAAI,CAAC8B,EAAO,cAAc,EAAG,CAC3BA,EAAO,eAAe,EACtBlB,EAAU,EACV,MACF,CAIA,IAAMmB,EAAW,IAAI,SAASD,CAAM,EAChCE,EAAY5C,EAEhB,GAAIA,IAAO0C,GAAUjC,aAAe,YAElCmC,EAAYnC,EAAI,cACX,CAEL,IAAMoC,EAAkBpC,GAAeA,EAAI,eAAe,EAC1DiC,EAAO,iBAAiB,SAAUG,CAAc,EAChDrB,EAAY,IAAMkB,EAAO,oBAAoB,SAAUG,CAAc,CACvE,CAGA,GAAID,aAAqB,kBAAmB,CAC1C,IAAMjD,EAAOiD,EAAU,aAAa,MAAM,EACtCjD,GAAMgD,EAAS,OAAOhD,EAAMiD,EAAU,KAAK,CACjD,CAEA,IAAME,EAAYJ,EAAO,aAAa,SAAS,IAAM,sBAEhDI,IACHnB,EAAQ,cAAc,EAAI,qCAG5B,IAAMoB,EAAa,IAAI,gBAAgBJ,CAAe,EACtD,GAAI/C,IAAW,MACb,OAAW,CAACoD,EAAKC,CAAK,IAAKF,EACzBP,EAAY,OAAOQ,EAAKC,CAAK,OAEtBH,EAwGPlB,EAAI,KAAOe,EAGbf,EAAI,KAAOmB,CAEf,KACE,OAAMpC,EAAW,wBAAyB,CAAE,OAAAY,EAAQ,YAAAT,CAAY,CAAC,EAGnEX,EAAY+C,GAASlD,EAAI,CAAC,CAAC,EAC3BuC,EAAY,OAASC,EAAY,SAAS,EAE1C,GAAI,CACF,MAAMW,GAAiBZ,EAAY,SAAS,EAAGvC,EAAI4B,CAAG,CACxD,OAASS,EAAO,CACd,GAAI,CAAC9B,GAAe8B,CAAK,EACvB,MAAM1B,EAAW,iBAAkB,CAAE,OAAAf,EAAQ,IAAAE,EAAK,MAAAuC,CAAM,CAAC,CAM7D,CACF,QAAE,CACAlC,EAAYiD,GAAUpD,EAAI,CAAC,CAAC,EAC5BwB,EAAU,CACZ,CACF,EAsBA,eAAe6B,GACbC,EACAC,EACe,CACf,IAAMC,EAASF,EAAO,UAAU,EAC5BG,EAAS,MAAMD,EAAO,KAAK,EAC/B,KAAO,CAACC,EAAO,MACbF,EAAQE,EAAO,KAAK,EACpBA,EAAS,MAAMD,EAAO,KAAK,CAE/B,CAEA,SAASE,GAASC,EAAyD,CACzE,IAAIC,EACAC,EACAC,EACAC,EAAyB,GAG7B,OAAO,SAAiBC,EAAiB,CAClCJ,EAMHA,EAASK,GAAOL,EAAQI,CAAG,GAL3BJ,EAASI,EACTH,EAAW,EACXC,EAAc,IAMhB,IAAMI,EAAYN,EAAO,OACrBO,EAAY,EAChB,KAAON,EAAWK,GAAW,CACvBH,IACEH,EAAOC,CAAQ,IAAM,KAAIM,EAAY,EAAEN,GAC3CE,EAAyB,IAI3B,IAAIK,EAAU,GACd,KAAOP,EAAWK,GAAaE,IAAY,GAAI,EAAEP,EAC/C,OAAQD,EAAOC,CAAQ,EAAG,CACxB,IAAK,IACCC,IAAgB,KAElBA,EAAcD,EAAWM,GAE3B,MAGF,IAAK,IACHJ,EAAyB,GAC3B,IAAK,IACHK,EAAUP,EACV,KACJ,CAGF,GAAIO,IAAY,GAAI,MAGpBT,EAAOC,EAAO,SAASO,EAAWC,CAAO,EAAGN,CAAW,EACvDK,EAAYN,EACZC,EAAc,EAChB,CAEIK,IAAcD,EAChBN,EAAS,OACFO,IAGPP,EAASA,EAAO,SAASO,CAAS,EAClCN,GAAYM,EAEhB,CACF,CAEA,SAASE,GACPC,EACAC,EACAC,EACA,CACA,IAAIC,EAAUC,GAAW,EACnBC,EAAU,IAAI,YAGpB,OAAO,SAAgB1C,EAAkB6B,EAAqB,CAC5D,GAAI,CAAC7B,EAAK,OAERuC,IAAYC,CAAO,EACnBA,EAAUC,GAAW,UACZZ,EAAc,EAAG,CAI1B,IAAMc,EAAQD,EAAQ,OAAO1C,EAAK,SAAS,EAAG6B,CAAW,CAAC,EACpDe,EAAcf,GAAe7B,EAAK6B,EAAc,CAAC,IAAM,GAAK,EAAI,GAChEb,EAAQ0B,EAAQ,OAAO1C,EAAK,SAAS4C,CAAW,CAAC,EAEvD,OAAQD,EAAO,CACb,IAAK,OACHH,EAAQ,KAAOA,EAAQ,KAAO,GAAGA,EAAQ,IAAI;AAAA,EAAKxB,CAAK,GAAKA,EAC5D,MACF,IAAK,QACHwB,EAAQ,MAAQxB,EAChB,MACF,IAAK,KACHqB,EAAMG,EAAQ,GAAKxB,CAAM,EACzB,MACF,IAAK,QAAS,CACZ,IAAM6B,EAAQ,CAAC7B,EACV,OAAO,MAAM6B,CAAK,GAErBP,EAASE,EAAQ,MAAQK,CAAM,EAEjC,KACF,CACF,CACF,CACF,CACF,CAEA,IAAMb,GAAS,CAACc,EAAeC,IAAkB,CAC/C,IAAMvC,EAAM,IAAI,WAAWsC,EAAE,OAASC,EAAE,MAAM,EAC9C,OAAAvC,EAAI,IAAIsC,CAAC,EACTtC,EAAI,IAAIuC,EAAGD,EAAE,MAAM,EACZtC,CACT,EAEMiC,GAAa,KAA2B,CAK5C,KAAM,GACN,MAAO,GACP,GAAI,GACJ,MAAO,MACT,GAiBA,SAASvB,GACP8B,EACAjF,EACA,CACE,OAAQkF,EACR,QAASC,EACT,OAAQC,EACR,UAAAC,EACA,QAAAC,EACA,QAAAC,EACA,eAAAvE,EACA,MAAOwE,EACP,cAAAvE,EAAgB,IAChB,YAAAE,EAAc,EACd,eAAAC,EAAiB,IACjB,cAAAC,EAAgB,GAChB,UAAAoE,EACA,GAAGC,CACL,EACA,CACA,OAAO,IAAI,QAAc,CAACC,EAASC,IAAW,CAE5C,IAAMjE,EAAkC,CACtC,OAAQ,oBACR,GAAGwD,CACL,EAEIU,EACJ,SAASC,GAAqB,CAC5BD,EAAqB,MAAM,EACtB,SAAS,QAAQE,EAAO,CAC/B,CAEK/E,GACH,SAAS,iBAAiB,mBAAoB8E,CAAkB,EAGlE,IAAIE,EAAa,EACjB,SAASC,GAAU,CACjB,SAAS,oBAAoB,mBAAoBH,CAAkB,EACnE,OAAO,aAAaE,CAAU,EAC9BH,EAAqB,MAAM,CAC7B,CAGAX,GAAa,iBAAiB,QAAS,IAAM,CAC3Ce,EAAQ,EACRN,EAAQ,CACV,CAAC,EAED,IAAMO,EAAQV,GAAc,OAAO,MAC7BW,EAASf,IAAgB,IAAM,CAAC,GAElCgB,EAAU,EACVC,EAAoBpF,EACxB,eAAe8E,GAAS,CACtBF,EAAuB,IAAI,gBAC3B,GAAI,CACF,IAAMhE,EAAW,MAAMqE,EAAMjB,EAAO,CAClC,GAAGS,EACH,QAAA/D,EACA,OAAQkE,EAAqB,MAC/B,CAAC,EAGDO,EAAU,EACVnF,EAAgBoF,EAEhB,MAAMF,EAAOtE,CAAQ,EAErB,IAAMyE,EAAiB,MACrBC,EACA1E,EACAlC,GACA8F,KACGe,KACA,CACH,IAAMnG,GAAkC,CACtC,CAACV,EAAI,EAAG,MAAMkC,EAAS,KAAK,CAC9B,EACA,QAAW4E,MAAKD,GAAU,CACxB,IAAIpE,GAAIP,EAAS,QAAQ,IAAI,YAAY6E,EAAMD,EAAC,CAAC,EAAE,EACnD,GAAIhB,EAAW,CACb,IAAMkB,GAAKlB,EAAkBgB,EAAC,EAC1BE,KAAGvE,GAAI,OAAOuE,IAAM,SAAWA,GAAI,KAAK,UAAUA,EAAC,EACzD,CACIvE,KAAG/B,GAAQoG,EAAC,EAAIrE,GACtB,CAEAjC,EAAYoG,EAAcvG,EAAIK,EAAO,EACrC4F,EAAQ,CACV,EAEMW,EAAK/E,EAAS,QAAQ,IAAI,cAAc,EAC9C,GAAI+E,GAAI,SAAS,WAAW,EAC1B,OAAO,MAAMN,EACXO,GACAhF,EACA,WACA4D,EACA,WACA,OACA,mBACF,EAGF,GAAImB,GAAI,SAAS,kBAAkB,EACjC,OAAO,MAAMN,EACXQ,GACAjF,EACA,UACA4D,EACA,eACF,EAGF,GAAImB,GAAI,SAAS,iBAAiB,EAAG,CACnC,IAAMG,EAAS,SAAS,cAAc,QAAQ,EACxCC,EAAyBnF,EAAS,QAAQ,IAC9C,4BACF,EAEA,GAAImF,EACF,OAAW,CAACrH,GAAMsD,CAAK,IAAK,OAAO,QACjC,KAAK,MAAM+D,CAAsB,CACnC,EACED,EAAO,aAAapH,GAAMsD,CAAe,EAG7C8D,EAAO,YAAc,MAAMlF,EAAS,KAAK,EACzC,SAAS,KAAK,YAAYkF,CAAM,EAChCd,EAAQ,EACR,MACF,CAEA,MAAM5C,GACJxB,EAAS,KACT6B,GACEW,GACG4C,GAAO,CACFA,EAEFtF,EAAQ,eAAe,EAAIsF,EAG3B,OAAOtF,EAAQ,eAAe,CAElC,EACCmD,GAAU,CACTuB,EAAoBpF,EAAgB6D,CACtC,EACAO,CACF,CACF,CACF,EAEAC,IAAU,EACVW,EAAQ,EACRN,EAAQ,CACV,OAASnF,EAAK,CACZ,GAAI,CAACqF,EAAqB,OAAO,QAE/B,GAAI,CAEF,IAAMqB,EAAgB3B,IAAU/E,CAAG,GAAKS,EACxC,OAAO,aAAa+E,CAAU,EAC9BA,EAAa,OAAO,WAAWD,EAAQmB,CAAQ,EAC/CjG,EAAgB,KAAK,IACnBA,EAAgBE,EAChBC,CACF,EACI,EAAEgF,GAAW/E,GACflB,EAAYgH,GAAgBnH,EAAI,CAAC,CAAC,EAElCiG,EAAQ,EACRL,EAAO,sBAAsB,GAE7B,QAAQ,MACN,4BAA4BX,EAAM,SAAS,CAAC,gBAAgBiC,CAAQ,KACtE,CAEJ,OAASE,EAAU,CAEjBnB,EAAQ,EACRL,EAAOwB,CAAQ,CACjB,CAEJ,CACF,CAEArB,EAAO,CACT,CAAC,CACH,CCttBO,IAAMsB,GAASC,EAAiB,SAAU,QAAQ,ECAlD,IAAMC,GAAMC,EAAiB,MAAO,KAAK,ECAzC,IAAMC,GAAQC,EAAiB,QAAS,OAAO,ECA/C,IAAMC,GAAOC,EAAiB,OAAQ,MAAM,ECA5C,IAAMC,GAAMC,EAAiB,MAAO,KAAK,ECqBzC,IAAMC,GAA+B,CAC1C,KAAM,UACN,KAAMC,GACN,MAAM,aAAaC,EAAK,CACtBC,GAAwBF,GAAyBG,GAC/CC,GAAgBH,EAAKE,CAAI,CAC3B,CACF,CACF,EAEA,SAASC,GACPH,EACA,CACE,SAAAI,EACA,SAAAC,EACA,KAAAC,EAAOC,GACP,kBAAAC,CACF,EACA,CACA,GAAIF,IAASG,IAA0BJ,EAAU,CAC/C,IAAMK,EAAU,SAAS,iBAAiBL,CAAQ,EAClD,GAAI,CAACK,EAAQ,OACX,MAAMC,EAAQ,iBAAkBX,EAAK,CACnC,aAAcK,CAChB,CAAC,EAGH,GAAIG,GAAqBI,GACvB,SAAS,oBAAoB,IAAM,CACjC,QAAWC,KAAUH,EACnBG,EAAO,OAAO,CAElB,CAAC,MAED,SAAWA,KAAUH,EACnBG,EAAO,OAAO,CAGpB,KAAO,CACL,IAAMC,EAAW,SAAS,cAAc,UAAU,EAClDA,EAAS,UAAYV,EAErB,QAAWW,IAAQ,CAAC,GAAGD,EAAS,QAAQ,UAAU,EAAG,CACnD,IAAME,EAAOD,EAAK,SAClB,GAAIC,IAAS,EAAG,CACd,GAAIA,IAAS,GAAK,CAACD,EAAK,UAAW,KAAK,EACtC,SAEF,MAAMJ,EAAQ,kBAAmBX,CAAG,CACtC,CAEA,IAAMiB,EAAeZ,GAAY,IAAKU,EAAiB,EAAE,GACnDL,EAAU,SAAS,iBAAiBO,CAAY,EACtD,GAAI,CAACP,EAAQ,OACX,MAAMC,EAAQ,iBAAkBX,EAAK,CACnC,aAAAiB,CACF,CAAC,EAGCT,GAAqBI,GACvB,SAAS,oBAAoB,IAC3BM,GAAelB,EAAKM,EAAMS,EAAmBL,CAAO,CACtD,EAEAQ,GAAelB,EAAKM,EAAMS,EAAmBL,CAAO,CAExD,CACF,CACF,CAEA,IAAMS,GAAU,IAAI,QACpB,SAASC,GAAQP,EAAuB,CACtC,IAAMQ,EACJR,aAAkB,kBACd,CAACA,CAAM,EACPA,EAAO,iBAAiB,QAAQ,EACtC,QAAWS,KAAOD,EAChB,GAAI,CAACF,GAAQ,IAAIG,CAAG,EAAG,CACrB,IAAMC,EAAS,SAAS,cAAc,QAAQ,EAC9C,OAAW,CAAE,KAAAC,EAAM,MAAAC,CAAM,IAAKH,EAAI,WAChCC,EAAO,aAAaC,EAAMC,CAAK,EAEjCF,EAAO,KAAOD,EAAI,KAClBA,EAAI,YAAYC,CAAM,EACtBJ,GAAQ,IAAII,CAAM,CACpB,CAEJ,CAEA,SAASL,GACPlB,EACAM,EACAoB,EACAC,EACA,CACA,QAAWd,KAAUc,EACnB,GAAIrB,IAASG,GACXI,EAAO,OAAO,UAEdP,IAASsB,IACTtB,IAASuB,GAETC,GAAMjB,EAAQa,EAASpB,CAAI,EAC3Bc,GAAQP,CAAM,MACT,CACL,IAAMkB,EAASL,EAAQ,UAAU,EAAI,EACrC,GAAIpB,IAAS0B,GACXnB,EAAO,YAAYkB,CAAM,UAChBzB,IAAS2B,GAClBpB,EAAO,QAAQkB,CAAM,UACZzB,IAAS4B,GAClBrB,EAAO,OAAOkB,CAAM,UACXzB,IAAS6B,GAClBtB,EAAO,OAAOkB,CAAM,UACXzB,IAAS8B,GAClBvB,EAAO,MAAMkB,CAAM,MAEnB,OAAMpB,EAAQ,mBAAoBX,EAAK,CAAE,KAAAM,CAAK,CAAC,EAEjDc,GAAQW,CAAM,CAChB,CAEJ,CAEA,IAAMM,GAAkB,IAAI,IACtBC,EAAW,IAAI,IACfC,GAAmB,IAAI,IACvBC,GAAe,IAAI,IACnBC,GAAY,SAAS,cAAc,KAAK,EAC9CA,GAAU,OAAS,GAEnB,SAASX,GACPY,EACAC,EACArC,EACM,CACN,IAAMsC,EAASC,EAAS,cAAc,EACtC,GACGH,EAAO,aAAaE,CAAM,GAAKD,EAAO,aAAaC,CAAM,GAC1DF,EAAO,eAAe,QAAQ,IAAIE,CAAM,GAAG,EAE3C,OAGF,IAAME,EAAgB,SAAS,cAAc,KAAK,EAClDA,EAAc,OAAOH,CAAiB,EACtC,SAAS,KAAK,sBAAsB,WAAYF,EAAS,EAGzD,IAAMM,EAAgBL,EAAO,iBAAiB,MAAM,EACpD,OAAW,CAAE,GAAAM,EAAI,QAAAC,CAAQ,IAAKF,EACxBV,GAAgB,IAAIW,CAAE,EACxBR,GAAa,IAAIQ,CAAE,EAEnBX,GAAgB,IAAIW,EAAIC,CAAO,EAG/BP,EAAO,KACLL,GAAgB,IAAIK,EAAO,EAAE,EAC/BF,GAAa,IAAIE,EAAO,EAAE,EAE1BL,GAAgB,IAAIK,EAAO,GAAIA,EAAO,OAAO,GAIjDH,GAAiB,MAAM,EACvB,IAAMW,EAAgBJ,EAAc,iBAAiB,MAAM,EAC3D,OAAW,CAAE,GAAAE,EAAI,QAAAC,CAAQ,IAAKC,EACxBX,GAAiB,IAAIS,CAAE,EACzBR,GAAa,IAAIQ,CAAE,EACVX,GAAgB,IAAIW,CAAE,IAAMC,GACrCV,GAAiB,IAAIS,CAAE,EAI3BX,GAAgB,MAAM,EAEtB,QAAWW,KAAMR,GACfD,GAAiB,OAAOS,CAAE,EAG5BR,GAAa,MAAM,EAOnBF,EAAS,MAAM,EAEfa,GACE7C,IAAS,QAAUoC,EAAO,cAAiBA,EAC3CK,CACF,EACAI,GAAsBL,EAAeI,CAAa,EAElDE,GACE9C,IAAS,QAAUoC,EAAO,cAAiBA,EAC3CI,EACAxC,IAAS,QAAWoC,EAAkB,KACtCA,EAAO,WACT,EAEAD,GAAU,OAAO,CACnB,CAMA,SAASW,GACPC,EACAC,EACAC,EAA8B,KAC9BC,EAAwB,KAClB,CAGJH,aAAqB,qBACrBC,aAAqB,sBAGrBD,EAAYA,EAAU,QACtBC,EAAYA,EAAU,SAExBC,IAAmBF,EAAU,WAG7B,QAAWI,KAAYH,EAAU,WAAY,CAE3C,GAAIC,GAAkBA,IAAmBC,EAAU,CACjD,IAAME,EAAYC,GAAcF,EAAUF,EAAgBC,CAAQ,EAClE,GAAIE,EAAW,CAEb,GAAIA,IAAcH,EAAgB,CAChC,IAAIK,EAAsBL,EAE1B,KAAOK,GAAUA,IAAWF,GAAW,CACrC,IAAMG,EAAWD,EACjBA,EAASA,EAAO,YAChBE,GAAWD,CAAQ,CACrB,CACF,CACAE,GAAUL,EAAWD,CAAQ,EAC7BF,EAAiBG,EAAU,YAC3B,QACF,CACF,CAGA,IAAMM,EAAOP,EAAS,GAEtB,GAAIA,aAAoB,SAAWlB,GAAiB,IAAIyB,CAAI,EAAG,CAI7D,IAAMC,EAAa,OAAOD,CAAI,EAM1BE,EAAUD,EACd,KAAQC,EAAUA,EAAQ,YAAwB,CAChD,IAAMC,EAAQ7B,EAAS,IAAI4B,CAAO,EAC9BC,IACFA,EAAM,OAAOH,CAAI,EACZG,EAAM,MACT7B,EAAS,OAAO4B,CAAO,EAG7B,CAEAE,GAAWf,EAAWY,EAAYV,CAAc,EAChDQ,GAAUE,EAAYR,CAAQ,EAC9BF,EAAiBU,EAAW,YAC5B,QACF,CAIA,GAAI3B,EAAS,IAAImB,CAAQ,EAAG,CAE1B,IAAMY,EAAgB,SAAS,cAC5BZ,EAAqB,OACxB,EACAJ,EAAU,aAAagB,EAAed,CAAc,EACpDQ,GAAUM,EAAeZ,CAAQ,EACjCF,EAAiBc,EAAc,WACjC,KAAO,CAEL,IAAMC,EAAiB,SAAS,WAAWb,EAAU,EAAI,EACzDJ,EAAU,aAAaiB,EAAgBf,CAAc,EACrDA,EAAiBe,EAAe,WAClC,CACF,CAGA,KAAOf,GAAkBA,IAAmBC,GAAU,CACpD,IAAMK,EAAWN,EACjBA,EAAiBA,EAAe,YAChCO,GAAWD,CAAQ,CACrB,CACF,CAKA,SAASF,GACP5C,EACAwD,EACAf,EACa,CACb,IAAIE,EAAY,KACZc,EAAczD,EAAK,YACnB0D,EAAwB,EACxBC,EAAqB,EAGnBC,EAAiBrC,EAAS,IAAIvB,CAAI,GAAG,MAAQ,EAE/C6C,EAASW,EACb,KAAOX,GAAUA,IAAWJ,GAAU,CAEpC,GAAIoB,GAAYhB,EAAQ7C,CAAI,EAAG,CAC7B,IAAI8D,EAAe,GACbC,EAASxC,EAAS,IAAIsB,CAAM,EAC5BmB,EAASzC,EAAS,IAAIvB,CAAI,EAEhC,GAAIgE,GAAUD,GACZ,QAAW9B,KAAM8B,EAKf,GAAIC,EAAO,IAAI/B,CAAE,EAAG,CAClB6B,EAAe,GACf,KACF,EAIJ,GAAIA,EACF,OAAOjB,EAKT,GAAI,CAACF,GAAa,CAACpB,EAAS,IAAIsB,CAAM,EAAG,CAEvC,GAAI,CAACe,EACH,OAAOf,EAGTF,EAAYE,CACd,CACF,CAyBA,GAvBAc,GAAsBpC,EAAS,IAAIsB,CAAM,GAAG,MAAQ,EAChDc,EAAqBC,IAMrBjB,IAAc,MAAQc,GAAeI,GAAYhB,EAAQY,CAAW,IAGtEC,IACAD,EAAcA,EAAY,YAKtBC,GAAyB,IAC3Bf,EAAY,SAMZE,EAAO,SAAS,SAAS,aAAa,GAAG,MAE7CA,EAASA,EAAO,WAClB,CAEA,OAAOF,GAAa,IACtB,CAEA,SAASkB,GAAYI,EAAeC,EAAwB,CAE1D,IAAMC,EAASF,EAAoB,GACnC,OACEA,EAAQ,WAAaC,EAAQ,UAC5BD,EAAoB,UAAaC,EAAoB,UAIrD,CAACC,GAASA,IAAWD,EAAoB,GAE9C,CAKA,SAASnB,GAAW/C,EAAY,CAE1BuB,EAAS,IAAIvB,CAAI,EAEnBqD,GAAW3B,GAAW1B,EAAM,IAAI,EAGhCA,EAAK,YAAY,YAAYA,CAAI,CAErC,CAKA,IAAMqD,GAEJN,GAAW,KAAK,KAAKrB,GAAU,YAAcA,GAAU,YAAY,EAErE,SAASsB,GACPiB,EACAC,EACM,CAGN,IAAMjE,EAAOiE,EAAQ,SAIrB,GAAIjE,IAAS,EAAsB,CACjC,IAAM4B,EAASC,EAAS,cAAc,EACtC,GACGmC,EAAoB,aAAapC,CAAM,GACvCqC,EAAoB,aAAarC,CAAM,EAExC,OAAOoC,EAGT,IAAMG,GACHF,EAAwB,aAAapC,EAAS,eAAe,CAAC,GAAK,IACpE,MAAM,GAAG,EAEX,OAAW,CAAE,KAAArB,EAAM,MAAAC,CAAM,IAAMwD,EAAoB,WAE9CD,EAAoB,aAAaxD,CAAI,IAAMC,GAC5C,CAAC0D,EAAc,SAASC,EAAM5D,CAAI,CAAC,GAEjCwD,EAAoB,aAAaxD,EAAMC,CAAK,EAIlD,IAAM4D,EAAYL,EAAoB,WACtC,QAASM,EAAID,EAAS,OAAS,EAAGC,GAAK,EAAGA,IAAK,CAC7C,GAAM,CAAE,KAAA9D,CAAK,EAAI6D,EAASC,CAAC,EAEzB,CAAEL,EAAoB,aAAazD,CAAI,GACvC,CAAC2D,EAAc,SAASC,EAAM5D,CAAI,CAAC,GAEjCwD,EAAoB,gBAAgBxD,CAAI,CAE9C,CAKA,GACEwD,aAAmB,kBACnBC,aAAmB,kBACnBA,EAAQ,OAAS,OACjB,CACA,IAAMM,EAAO1C,EAAS,MAAM,EAAE,MAAM,CAAC,EACjC2C,EAAS,GACb,QAAWC,KAAOR,EAAQ,QACxB,GAAIQ,EAAI,WAAWF,CAAI,EAAG,CACxBC,EAAS,GACT,KACF,CAEF,GAAIA,EAAQ,CACV,IAAME,EAAWT,EAAQ,MACpBA,EAAQ,aAAa,OAAO,EAGtBD,EAAQ,QAAUU,IAC3BV,EAAQ,aAAa,QAASU,CAAQ,EACtCV,EAAQ,MAAQU,IAJhBV,EAAQ,MAAQ,GAChBA,EAAQ,gBAAgB,OAAO,EAKnC,CACF,SACEA,aAAmB,qBACnBC,aAAmB,oBACnB,CACA,IAAMS,EAAWT,EAAQ,MACrBS,IAAaV,EAAQ,QACvBA,EAAQ,MAAQU,GAEdV,EAAQ,YAAcA,EAAQ,WAAW,YAAcU,IACzDV,EAAQ,WAAW,UAAYU,EAEnC,CACF,CAEA,OAAI1E,IAAS,GAAmBA,IAAS,IACnCgE,EAAQ,YAAcC,EAAQ,YAChCD,EAAQ,UAAYC,EAAQ,WAI3BD,EAAQ,YAAYC,CAAO,GAC9B7B,GAAc4B,EAAoBC,CAAkB,EAE/CD,CACT,CAMA,SAAS7B,GACPwC,EACAvF,EACA,CACA,QAAWwF,KAAOxF,EAChB,GAAImC,GAAiB,IAAIqD,EAAI,EAAE,EAAG,CAChC,IAAI1B,EAA0B0B,EAE9B,KAAO1B,GAAWA,IAAYyB,GAAM,CAClC,IAAIxB,EAAQ7B,EAAS,IAAI4B,CAAO,EAE3BC,IACHA,EAAQ,IAAI,IACZ7B,EAAS,IAAI4B,EAASC,CAAK,GAE7BA,EAAM,IAAIyB,EAAI,EAAE,EAChB1B,EAAUA,EAAQ,aACpB,CACF,CAEJ,CC7iBO,IAAM2B,GAA8B,CACzC,KAAM,UACN,KAAMC,GACN,aAAeC,GACbC,GACEF,GACA,CAAC,CACC,QAASG,EAAM,KACf,cAAeC,EAAmB,GAAGC,EAAgC,EACvE,IACEJ,EAAI,WAAWK,GAAcH,CAAG,EAAG,CACjC,UAAWI,GAAaH,CAAgB,CAC1C,CAAC,CACL,CACJ,ECEAI,GAEEC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GAEAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACDC,GACCC,GACAC,GACAC,GACAC,GAEAC,GACAC,GACAC,EACF,EAEAC,GAAM",
  "names": ["lol", "DSP", "DSS", "DATASTAR", "DATASTAR_REQUEST", "DefaultSseRetryDurationMs", "DefaultPatchSignalsOnlyIfMissing", "ElementPatchModeOuter", "ElementPatchModeInner", "ElementPatchModeRemove", "ElementPatchModeReplace", "ElementPatchModePrepend", "ElementPatchModeAppend", "ElementPatchModeBefore", "ElementPatchModeAfter", "DefaultElementPatchMode", "EventTypePatchElements", "EventTypePatchSignals", "isHTMLOrSVG", "el", "isPojo", "obj", "isEmpty", "prop", "updateLeaves", "fn", "key", "val", "pathToObj", "target", "paths", "path", "keys", "lastKey", "acc", "isBoolString", "str", "kebab", "camel", "x", "snake", "pascal", "jsStrToObject", "raw", "caseFns", "modifyCasing", "mods", "c", "fn", "url", "dserr", "type", "reason", "metadata", "e", "DATASTAR", "snake", "q", "c", "initErr", "reason", "ctx", "metadata", "errCtx", "dserr", "runtimeErr", "DATASTAR_SIGNAL_PATCH_EVENT", "DATASTAR", "currentPatch", "queuedEffects", "batchDepth", "notifyIndex", "queuedEffectsLength", "activeSub", "startBatch", "endBatch", "flush", "dispatch", "signal", "initialValue", "signalOper", "value_", "flags_", "computedSymbol", "computed", "getter", "c", "computedOper", "effect", "fn", "e", "fn_", "link", "prev", "setCurrentSub", "effectOper", "peek", "run", "update", "updateComputed", "updateSignal", "sub", "prevSub", "startTracking", "oldValue", "endTracking", "s", "value", "notify", "flags", "subs", "subs_", "sub_", "checkDirty", "deps_", "dep", "dep_", "depFlags", "nextDep_", "shallowPropagate", "newValue", "propagate", "currentValue", "unlink", "prevDep", "depsTail_", "nextDep", "recursedCheck", "subsTail_", "isValidLink", "newLink", "prevDep_", "prevSub_", "nextSub_", "toRemove", "next", "stack", "top", "subSubs", "prev_", "checkDepth", "dirty", "firstSub", "hasMultipleSubs", "nextSub", "subFlags", "checkLink", "depsTail", "getPath", "path", "acc", "key", "root", "hasPath", "obj", "DELETE", "deep", "prefix", "isArr", "isPojo", "deepObj", "keys", "_", "prop", "pathToObj", "isEmpty", "oldPatch", "DATASTAR_SIGNAL_PATCH_EVENT", "mergePatch", "patch", "ifMissing", "mergeInner", "target", "targetParent", "filtered", "include", "exclude", "pathObj", "node", "actions", "plugins", "pluginRegexs", "removals", "mutationObserver", "alias", "setAlias", "aliasify", "name", "load", "pluginsToLoad", "plugin", "ctx", "initErr", "a", "b", "lenDiff", "applyEls", "els", "ignore", "el", "applyAttributePlugin", "apply", "observe", "attrKey", "rawKey", "camel", "i", "rawModifiers", "hasKey", "hasValue", "runtimeErr", "generateReactiveExpression", "keyReq", "valReq", "rawMod", "label", "mod", "t", "cleanup", "cleanups", "mutations", "type", "attributeName", "addedNodes", "removedNodes", "isHTMLOrSVG", "expr", "attrPlugin", "statementRe", "statements", "lastIdx", "last", "match", "signalName", "part", "escaped", "escapeRe", "DSP", "DSS", "k", "v", "djb2", "nameGen", "snake", "actionsCalled", "actionsRe", "actionMatches", "actionNames", "actionFns", "actionPrefix", "DATASTAR", "actionName", "action", "args", "error", "str", "hash", "Peek", "peek", "fn", "SetAll", "filtered", "mergePatch", "peek", "value", "filter", "masked", "updateLeaves", "ToggleAll", "filtered", "mergePatch", "peek", "filter", "masked", "updateLeaves", "oldValue", "Attr", "el", "effect", "key", "rx", "syncAttr", "val", "observer", "obj", "cleanup", "k", "kebab", "value", "dataURIRegex", "textType", "numberType", "Bind", "el", "key", "mods", "value", "effect", "mergePatch", "runtimeErr", "getPath", "hasPath", "signalName", "modifyCasing", "allBoundInputs", "aliasify", "inputIndex", "pathObj", "input", "pathToObj", "syncSignal", "cleanup", "val", "files", "allContents", "allMimes", "allNames", "f", "resolve", "reader", "match", "option", "signalValue", "newValue", "evt", "Class", "key", "el", "effect", "mods", "rx", "modifyCasing", "kebab", "callback", "observer", "classes", "k", "classNames", "cn", "name", "cleanup", "Computed", "key", "mods", "rx", "computed", "mergePatch", "pathToObj", "modifyCasing", "Effect", "effect", "rx", "DATASTAR_SSE_EVENT", "DATASTAR", "STARTED", "FINISHED", "ERROR", "RETRYING", "RETRIES_FAILED", "datastarSSEEventWatcher", "eventType", "fn", "event", "argsRaw", "Indicator", "el", "key", "mods", "mergePatch", "value", "signalName", "modifyCasing", "pathToObj", "watcher", "event", "type", "elt", "STARTED", "FINISHED", "DATASTAR_SSE_EVENT", "JsonSignals", "el", "effect", "value", "filtered", "mods", "spaces", "filters", "jsStrToObject", "callback", "observer", "cleanup", "tagToMs", "args", "arg", "tagHas", "tags", "tag", "defaultValue", "delay", "callback", "wait", "args", "debounce", "leading", "trailing", "timer", "throttle", "waiting", "modifyTiming", "mods", "delayArgs", "tagToMs", "debounceArgs", "tagHas", "throttleArgs", "supportsViewTransitions", "modifyViewTransition", "callback", "mods", "cb", "args", "On", "ctx", "el", "key", "mods", "rx", "startBatch", "endBatch", "target", "callback", "evt", "modifyTiming", "modifyViewTransition", "evtListOpts", "cb", "eventName", "kebab", "modifyCasing", "DATASTAR_SSE_EVENT", "DATASTAR_SIGNAL_PATCH_EVENT", "once", "OnIntersect", "el", "mods", "rx", "startBatch", "endBatch", "callback", "modifyTiming", "modifyViewTransition", "options", "observer", "entries", "entry", "OnInterval", "mods", "rx", "startBatch", "endBatch", "callback", "modifyViewTransition", "duration", "durationArgs", "tagToMs", "tagHas", "intervalId", "OnLoad", "rx", "mods", "startBatch", "endBatch", "callback", "modifyViewTransition", "wait", "delayArgs", "tagToMs", "delay", "OnSignalPatch", "el", "key", "mods", "plugin", "rx", "filtered", "runtimeErr", "startBatch", "endBatch", "filtersRaw", "filters", "jsStrToObject", "callback", "modifyTiming", "evt", "watched", "isEmpty", "DATASTAR_SIGNAL_PATCH_EVENT", "Ref", "el", "key", "mods", "value", "mergePatch", "signalName", "modifyCasing", "pathToObj", "NONE", "DISPLAY", "Show", "el", "effect", "rx", "update", "observer", "cleanup", "Signals", "key", "mods", "rx", "mergePatch", "ifMissing", "modifyCasing", "pathToObj", "patch", "pathObj", "Text", "el", "effect", "rx", "update", "observer", "cleanup", "activeSSEControllers", "createHttpMethod", "name", "method", "ctx", "url", "args", "el", "controller", "sse", "dispatchSSE", "type", "argsRaw", "DATASTAR_SSE_EVENT", "isWrongContent", "err", "evt", "filtered", "runtimeErr", "selector", "userHeaders", "contentType", "filterSignals", "openWhenHidden", "retryInterval", "DefaultSseRetryDurationMs", "retryScaler", "retryMaxWaitMs", "retryMaxCount", "abort", "action", "cleanupFn", "initialHeaders", "DATASTAR_REQUEST", "headers", "req", "response", "ERROR", "DATASTAR", "argsRawLines", "line", "i", "k", "v", "error", "RETRYING", "urlInstance", "queryParams", "res", "formEl", "formData", "submitter", "preventDefault", "multipart", "formParams", "key", "value", "STARTED", "fetchEventSource", "FINISHED", "getBytes", "stream", "onChunk", "reader", "result", "getLines", "onLine", "buffer", "position", "fieldLength", "discardTrailingNewline", "arr", "concat", "bufLength", "lineStart", "lineEnd", "getMessages", "onId", "onRetry", "onMessage", "message", "newMessage", "decoder", "field", "valueOffset", "retry", "a", "b", "input", "inputSignal", "inputHeaders", "inputOnOpen", "onmessage", "onclose", "onerror", "inputFetch", "overrides", "rest", "resolve", "reject", "curRequestController", "onVisibilityChange", "create", "retryTimer", "dispose", "fetch", "onopen", "retries", "baseRetryInterval", "dispatchNonSSE", "dispatchType", "argNames", "n", "kebab", "o", "ct", "EventTypePatchElements", "EventTypePatchSignals", "script", "scriptAttributesHeader", "id", "interval", "RETRIES_FAILED", "innerErr", "DELETE", "createHttpMethod", "GET", "createHttpMethod", "PATCH", "createHttpMethod", "POST", "createHttpMethod", "PUT", "createHttpMethod", "PatchElements", "EventTypePatchElements", "ctx", "datastarSSEEventWatcher", "args", "onPatchElements", "elements", "selector", "mode", "DefaultElementPatchMode", "useViewTransition", "ElementPatchModeRemove", "targets", "initErr", "supportsViewTransitions", "target", "template", "node", "type", "selectorOrId", "applyToTargets", "scripts", "execute", "elScripts", "old", "script", "name", "value", "element", "capturedTargets", "ElementPatchModeOuter", "ElementPatchModeInner", "morph", "cloned", "ElementPatchModeReplace", "ElementPatchModePrepend", "ElementPatchModeAppend", "ElementPatchModeBefore", "ElementPatchModeAfter", "oldIdTagNameMap", "ctxIdMap", "ctxPersistentIds", "duplicateIds", "ctxPantry", "oldElt", "newElt", "ignore", "aliasify", "normalizedElt", "oldIdElements", "id", "tagName", "newIdElements", "populateIdMapWithTree", "morphChildren", "oldParent", "newParent", "insertionPoint", "endPoint", "newChild", "bestMatch", "findBestMatch", "cursor", "tempNode", "removeNode", "morphNode", "ncId", "movedChild", "current", "idSet", "moveBefore", "newEmptyChild", "newClonedChild", "startPoint", "nextSibling", "siblingSoftMatchCount", "displaceMatchCount", "nodeMatchCount", "isSoftMatch", "isIdSetMatch", "oldSet", "newSet", "oldNode", "newNode", "oldId", "preserveAttrs", "kebab", "oldAttrs", "i", "bind", "noBind", "key", "newValue", "root", "elt", "PatchSignals", "EventTypePatchSignals", "ctx", "datastarSSEEventWatcher", "raw", "onlyIfMissingRaw", "DefaultPatchSignalsOnlyIfMissing", "jsStrToObject", "isBoolString", "load", "GET", "POST", "PUT", "PATCH", "DELETE", "PatchElements", "PatchSignals", "Attr", "Bind", "Class", "Computed", "Effect", "Indicator", "JsonSignals", "On", "OnIntersect", "OnInterval", "OnLoad", "OnSignalPatch", "Ref", "Show", "Signals", "Text", "Peek", "SetAll", "ToggleAll", "apply"]
}
